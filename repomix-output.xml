This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend-new/.gitignore
backend-new/package.json
backend-new/prisma.config.ts
backend-new/prisma/migrations/20260105150207_init/migration.sql
backend-new/prisma/migrations/20260107233753_init/migration.sql
backend-new/prisma/migrations/migration_lock.toml
backend-new/prisma/schema.prisma
backend-new/prisma/seed.ts
backend-new/repomix-output.xml
backend-new/src/controllers/authController.ts
backend-new/src/controllers/configController.ts
backend-new/src/controllers/esgDataController.ts
backend-new/src/controllers/userController.ts
backend-new/src/index.ts
backend-new/src/interfaces/crudDelegate.ts
backend-new/src/middleware/authMiddleware.ts
backend-new/src/repositories/configRepository.ts
backend-new/src/repositories/prisma.ts
backend-new/src/repositories/userRepository.ts
backend-new/src/routes/authRoutes.ts
backend-new/src/routes/esgRoutes.ts
backend-new/src/routes/userRoutes.ts
backend-new/src/schemas/esgSchemas.ts
backend-new/src/schemas/userSchema.ts
backend-new/src/services/authService.ts
backend-new/src/services/configService.ts
backend-new/src/services/esgGenericService.ts
backend-new/src/services/userService.ts
backend-new/src/types/auth.ts
backend-new/src/utils/jwtUtils.ts
backend-new/src/utils/modelRegistry.ts
backend-new/src/utils/passwordUtils.ts
backend-new/tsconfig.json
backend/database.js
backend/legacy-code.xml
backend/package.json
backend/server.js
frontend/admin.html
frontend/admin.js
frontend/assets.html
frontend/assets.js
frontend/auth.css
frontend/dashboard.css
frontend/dashboard.html
frontend/dashboard.js
frontend/import.css
frontend/importer.html
frontend/importer.js
frontend/login.html
frontend/login.js
frontend/main.css
frontend/main.js
frontend/nav.html
frontend/register.html
frontend/register.js
frontend/units.html
frontend/units.js
shared/validators.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend-new/.gitignore">
node_modules
# Keep environment variables out of version control
.env

/generated/prisma
/dev.db
</file>

<file path="backend-new/package.json">
{
  "name": "backend-new",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc",
    "start": "node dist/index.js",
    "prisma:seed": "ts-node prisma/seed.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@prisma/adapter-better-sqlite3": "^7.2.0",
    "@prisma/client": "^7.2.0",
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.3",
    "zod": "^4.3.5"
  },
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^25.0.3",
    "prisma": "^7.2.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.9.3"
  }
}
</file>

<file path="backend-new/prisma.config.ts">
// This file was generated by Prisma, and assumes you have installed the following:
// npm install --save-dev prisma dotenv
import "dotenv/config";
import { defineConfig } from "prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: "file:./dev.db",
  },
});
</file>

<file path="backend-new/prisma/migrations/20260105150207_init/migration.sql">
-- CreateTable
CREATE TABLE "Company" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "cnpj" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "phone" TEXT,
    "role" TEXT NOT NULL DEFAULT 'USER',
    "companyId" TEXT,
    "unitId" INTEGER,
    "parentId" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "User_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "User_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "User_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "User" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "UserPermission" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "userId" TEXT NOT NULL,
    "sourceType" TEXT NOT NULL,
    CONSTRAINT "UserPermission_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Unit" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "city" TEXT NOT NULL,
    "state" TEXT NOT NULL,
    "country" TEXT NOT NULL,
    "numberOfWorkers" INTEGER NOT NULL,
    "companyId" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "Unit_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "Company_name_key" ON "Company"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Company_cnpj_key" ON "Company"("cnpj");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "UserPermission_userId_sourceType_key" ON "UserPermission"("userId", "sourceType");
</file>

<file path="backend-new/prisma/migrations/20260107233753_init/migration.sql">
-- CreateTable
CREATE TABLE "AssetTypology" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "unitId" INTEGER NOT NULL,
    "sourceType" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "assetFields" TEXT NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "responsibleContactId" INTEGER,
    "reportingFrequency" TEXT NOT NULL DEFAULT 'anual',
    CONSTRAINT "AssetTypology_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ManagedOption" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "fieldKey" TEXT NOT NULL,
    "value" TEXT NOT NULL
);

-- CreateTable
CREATE TABLE "MobileCombustionData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "inputType" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "vehicleType" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "MobileCombustionData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "StationaryCombustionData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "StationaryCombustionData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ProductionSalesData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "product" TEXT NOT NULL,
    "quantitySold" INTEGER NOT NULL,
    "measureUnit" TEXT NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ProductionSalesData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "LubricantsIppuData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "emissionSource" TEXT,
    "lubricantType" TEXT,
    "consumption" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "LubricantsIppuData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "FugitiveEmissionsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "emissionSource" TEXT,
    "gasType" TEXT,
    "quantityReplaced" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FugitiveEmissionsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "FertilizersData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "fertilizerType" TEXT,
    "quantityKg" REAL,
    "unitMeasure" TEXT,
    "percentNitrogen" REAL,
    "percentCarbonate" REAL,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FertilizersData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EffluentsControlledData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "treatmentOrDest" TEXT NOT NULL,
    "treatmentType" TEXT,
    "finalDestType" TEXT,
    "qtyEffluentM3" REAL NOT NULL,
    "unitEffluent" TEXT NOT NULL,
    "qtyOrganic" REAL NOT NULL,
    "unitOrganic" TEXT NOT NULL,
    "qtyNitrogen" REAL NOT NULL,
    "unitNitrogen" TEXT NOT NULL,
    "organicRemovedSludge" REAL,
    "unitSludge" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EffluentsControlledData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "DomesticEffluentsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "workerType" TEXT NOT NULL,
    "numWorkers" INTEGER NOT NULL,
    "avgWorkHours" REAL NOT NULL,
    "septicTankOwner" TEXT NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "DomesticEffluentsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "LandUseChangeData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "prevLandUse" TEXT NOT NULL,
    "biome" TEXT,
    "phytophysiognomy" TEXT,
    "areaType" TEXT,
    "areaHectares" REAL NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "LandUseChangeData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "SolidWasteData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "finalDestination" TEXT,
    "wasteType" TEXT,
    "quantityGenerated" REAL,
    "unitMeasure" TEXT,
    "cityStateDest" TEXT,
    "locationControlled" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "internalTracking" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "SolidWasteData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ElectricityPurchaseData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "energySource" TEXT,
    "specifySource" TEXT,
    "consumption" REAL,
    "measureUnit" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "traceability" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ElectricityPurchaseData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "PurchasedGoodsServicesData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "itemDescription" TEXT,
    "itemType" TEXT,
    "quantity" REAL,
    "unitMeasure" TEXT,
    "acquisitionValue" REAL,
    "thirdPartyGoods" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "PurchasedGoodsServicesData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "CapitalGoodsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "capitalGood" TEXT,
    "quantity" INTEGER,
    "unitMeasure" TEXT,
    "acquisitionValue" REAL,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "CapitalGoodsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "UpstreamTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "transportMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "origin" TEXT,
    "destination" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "UpstreamTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "BusinessTravelLandData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "tripDescription" TEXT,
    "travelMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "kmReimbursed" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "BusinessTravelLandData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "DownstreamTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "transportMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "origin" TEXT,
    "destination" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "DownstreamTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "WasteTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "WasteTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "HomeOfficeData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "workRegime" TEXT,
    "numEmployees" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "HomeOfficeData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "AirTravelData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "tripDescription" TEXT,
    "airportCodeOrigin" TEXT,
    "airportCodeDest" TEXT,
    "tripCount" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "AirTravelData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EmployeeCommutingData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "identifier" TEXT,
    "methodUsed" TEXT,
    "reportType" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distanceKm" REAL,
    "employeeAddress" TEXT,
    "workAddress" TEXT,
    "daysCommuted" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EmployeeCommutingData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EnergyGenerationData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "generationSource" TEXT,
    "totalGeneration" REAL,
    "measureUnit" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EnergyGenerationData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "PlantedForestData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "areaId" TEXT,
    "speciesName" TEXT,
    "areaPrePreLast" REAL,
    "agePrePreLast" INTEGER,
    "agePreLast" INTEGER,
    "areaHarvestedPreLast" REAL,
    "currentArea" REAL,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "PlantedForestData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ConservationAreaData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "description" TEXT,
    "biome" TEXT,
    "phytophysiognomy" TEXT,
    "plantedArea" TEXT,
    "plantingStatus" TEXT,
    "areaStartYear" REAL,
    "areaEndYear" REAL,
    "changeReason" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ConservationAreaData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "ManagedOption_fieldKey_value_key" ON "ManagedOption"("fieldKey", "value");
</file>

<file path="backend-new/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "sqlite"
</file>

<file path="backend-new/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
}

model Company {
  id   String  @id @default(uuid())
  name String  @unique
  cnpj String? @unique

  // Relations
  users User[]
  units Unit[]

  createdAt DateTime @default(now())
}

model User {
  id       String  @id @default(uuid())
  email    String  @unique
  password String
  name     String // Moved from Contact
  phone    String? // Moved from Contact
  role     String  @default("USER") // MASTER, ADMIN, USER

  // Multi-tenancy
  companyId String?
  company   Company? @relation(fields: [companyId], references: [id])

  // Unit Assignment: A user now "belongs" to a unit (optional for MASTER/ADMIN)
  unitId Int?
  unit   Unit? @relation(fields: [unitId], references: [id])

  // Hierarchy
  parentId String?
  parent   User?   @relation("UserHierarchy", fields: [parentId], references: [id])
  children User[]  @relation("UserHierarchy")

  // Permissions: These define which Spreadsheets (SourceTypes) the user manages
  permissions UserPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserPermission {
  id         String @id @default(uuid())
  userId     String
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  sourceType String // e.g., "combustao_movel", "solid_waste"

  @@unique([userId, sourceType])
}

model Unit {
  id              Int    @id @default(autoincrement())
  name            String
  city            String
  state           String
  country         String
  numberOfWorkers Int

  // Multi-tenancy
  companyId String
  company   Company @relation(fields: [companyId], references: [id])

  // Users belonging to this unit
  users User[]

  createdAt                   DateTime                     @default(now())
  assetTypologies             AssetTypology[]
  mobileCombustionDatas       MobileCombustionData[]
  stationaryCombustionDatas   StationaryCombustionData[]
  productionSalesDatas        ProductionSalesData[]
  lubricantsIppuDatas         LubricantsIppuData[]
  fugitiveEmissionsDatas      FugitiveEmissionsData[]
  fertilizersDatas            FertilizersData[]
  effluentsControlledDatas    EffluentsControlledData[]
  domesticEffluentsDatas      DomesticEffluentsData[]
  landUseChangeDatas          LandUseChangeData[]
  solidWasteDatas             SolidWasteData[]
  electricityPurchaseDatas    ElectricityPurchaseData[]
  purchasedGoodsServicesDatas PurchasedGoodsServicesData[]
  capitalGoodsDatas           CapitalGoodsData[]
  upstreamTransportDatas      UpstreamTransportData[]
  businessTravelLandDatas     BusinessTravelLandData[]
  downstreamTransportDatas    DownstreamTransportData[]
  wasteTransportDatas         WasteTransportData[]
  homeOfficeDatas             HomeOfficeData[]
  airTravelDatas              AirTravelData[]
  employeeCommutingDatas      EmployeeCommutingData[]
  energyGenerationDatas       EnergyGenerationData[]
  plantedForestDatas          PlantedForestData[]
  conservationAreaDatas       ConservationAreaData[]
}

// --- CONFIGURATION & METADATA ---

model AssetTypology {
  id                   Int     @id @default(autoincrement())
  unitId               Int
  unit                 Unit    @relation(fields: [unitId], references: [id], onDelete: Cascade)
  sourceType           String
  description          String
  assetFields          String // JSON string
  isActive             Boolean @default(true)
  responsibleContactId Int?
  reportingFrequency   String  @default("anual")
}

model ManagedOption {
  id       Int    @id @default(autoincrement())
  fieldKey String
  value    String

  @@unique([fieldKey, value])
}

// --- ESG DATA TABLES ---

// 1. Mobile Combustion
model MobileCombustionData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription   String?
  isCompanyControlled Boolean
  inputType           String? // 'consumo' or 'distancia'
  fuelType            String?
  consumption         Float?
  consumptionUnit     String?
  distance            Float?
  distanceUnit        String?
  vehicleType         String?

  comments  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 2. Stationary Combustion
model StationaryCombustionData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription   String?
  fuelType            String?
  consumption         Float?
  unitMeasure         String? // Renamed from 'unit' to avoid conflict with relation
  isCompanyControlled Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 3. Production & Sales
model ProductionSalesData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  product      String
  quantitySold Int
  measureUnit  String
  comments     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 4. Lubricants & IPPU
model LubricantsIppuData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  emissionSource      String?
  lubricantType       String?
  consumption         Float?
  unitMeasure         String?
  isCompanyControlled Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 5. Fugitive Emissions
model FugitiveEmissionsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  emissionSource      String?
  gasType             String?
  quantityReplaced    Float?
  unitMeasure         String?
  isCompanyControlled Boolean
  comments            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 6. Fertilizers
model FertilizersData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  fertilizerType      String?
  quantityKg          Float?
  unitMeasure         String?
  percentNitrogen     Float?
  percentCarbonate    Float?
  isCompanyControlled Boolean
  comments            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 7. Controlled Effluents
model EffluentsControlledData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  treatmentOrDest String
  treatmentType   String?
  finalDestType   String?

  qtyEffluentM3 Float
  unitEffluent  String

  qtyOrganic  Float
  unitOrganic String

  qtyNitrogen  Float
  unitNitrogen String

  organicRemovedSludge Float?
  unitSludge           String?

  comments String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 8. Domestic Effluents
model DomesticEffluentsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  workerType      String
  numWorkers      Int
  avgWorkHours    Float
  septicTankOwner String
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 9. Land Use Change
model LandUseChangeData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  prevLandUse      String
  biome            String?
  phytophysiognomy String?
  areaType         String?
  areaHectares     Float
  comments         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 10. Solid Waste
model SolidWasteData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  finalDestination   String?
  wasteType          String?
  quantityGenerated  Float?
  unitMeasure        String?
  cityStateDest      String?
  locationControlled String?

  responsible      String?
  deptResponsible  String?
  email            String?
  phone            String?
  internalTracking String?
  comments         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 11. Electricity Purchase
model ElectricityPurchaseData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  energySource  String?
  specifySource String?
  consumption   Float?
  measureUnit   String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  traceability    String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 12. Purchased Goods & Services
model PurchasedGoodsServicesData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  itemDescription  String?
  itemType         String?
  quantity         Float?
  unitMeasure      String?
  acquisitionValue Float?
  thirdPartyGoods  String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 13. Capital Goods
model CapitalGoodsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  capitalGood      String?
  quantity         Int?
  unitMeasure      String?
  acquisitionValue Float?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 14. Upstream Transport
model UpstreamTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  transportMode   String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?
  origin          String?
  destination     String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 15. Business Travel (Land)
model BusinessTravelLandData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  tripDescription String?
  travelMode      String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  distance        Float?
  distanceUnit    String?
  kmReimbursed    String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 16. Downstream Transport
model DownstreamTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  transportMode   String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?
  origin          String?
  destination     String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 17. Waste Transport
model WasteTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 18. Home Office
model HomeOfficeData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  workRegime   String?
  numEmployees Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 19. Air Travel
model AirTravelData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  tripDescription   String?
  airportCodeOrigin String?
  airportCodeDest   String?
  tripCount         Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 20. Employee Commuting
model EmployeeCommutingData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  identifier      String?
  methodUsed      String?
  reportType      String?
  fuelType        String?
  consumption     Float?
  consumptionUnit String?
  distanceKm      Float?
  employeeAddress String?
  workAddress     String?
  daysCommuted    Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 21. Energy Generation
model EnergyGenerationData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription String?
  generationSource  String?
  totalGeneration   Float?
  measureUnit       String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 22. Planted Forest
model PlantedForestData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  areaId      String?
  speciesName String?

  areaPrePreLast       Float?
  agePrePreLast        Int?
  agePreLast           Int?
  areaHarvestedPreLast Float?
  currentArea          Float?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 23. Conservation Area
model ConservationAreaData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  description      String?
  biome            String?
  phytophysiognomy String?

  plantedArea    String?
  plantingStatus String?
  areaStartYear  Float?
  areaEndYear    Float?
  changeReason   String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
</file>

<file path="backend-new/prisma/seed.ts">
import * as bcrypt from 'bcrypt'
import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";
import { PrismaClient } from "../generated/prisma";

const adapter = new PrismaBetterSqlite3({
    url: "file:./dev.db"
})

const prisma = new PrismaClient({ adapter });

async function main() {
    await prisma.assetTypology.deleteMany();
    await prisma.unit.deleteMany();
    await prisma.company.deleteMany();

    const masterPass = await bcrypt.hash('master123', 10)
    await prisma.user.upsert({
        where: { email: 'master@ecofinance.com' },
        update: {},
        create: {
            email: 'master@ecofinance.com',
            password: masterPass,
            name: 'System Master',
            role: 'MASTER'
        },
    });
    console.log('Seed: MASTER user created.');

    const company = await prisma.company.upsert({
        where: { name: 'EcoFinance Demo Corp' },
        update: {},
        create: {
            name: 'EcoFinance Demo Corp',
            cnpj: '12.345.678/0001-90'
        }
    });
    console.log('Seed: Company ensured.');

    const unit = await prisma.unit.upsert({
        where: { id: 1 },
        update: {},
        create: {
            name: 'Sao Paulo HQ',
            city: 'Sao Paulo',
            state: 'SP',
            country: 'Brasil',
            numberOfWorkers: 150,
            companyId: company.id
        }
    });
    console.log(`Seed: Unit ensured with ID: ${unit.id}`);
}

main().catch(e => console.error(e)).finally(() => prisma.$disconnect());
</file>

<file path="backend-new/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
dev.db
package.json
prisma.config.ts
prisma/migrations/20260105150207_init/migration.sql
prisma/migrations/20260107233753_init/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
prisma/seed.ts
src/controllers/authController.ts
src/controllers/configController.ts
src/controllers/esgDataController.ts
src/controllers/userController.ts
src/index.ts
src/interfaces/crudDelegate.ts
src/middleware/authMiddleware.ts
src/repositories/configRepository.ts
src/repositories/prisma.ts
src/repositories/userRepository.ts
src/routes/authRoutes.ts
src/routes/esgRoutes.ts
src/routes/userRoutes.ts
src/schemas/esgSchemas.ts
src/schemas/userSchema.ts
src/services/authService.ts
src/services/configService.ts
src/services/esgGenericService.ts
src/services/userService.ts
src/types/auth.ts
src/utils/jwtUtils.ts
src/utils/modelRegistry.ts
src/utils/passwordUtils.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
node_modules
# Keep environment variables out of version control
.env

/generated/prisma
</file>

<file path="package.json">
{
  "name": "backend-new",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc",
    "start": "node dist/index.js",
    "prisma:seed": "ts-node prisma/seed.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@prisma/adapter-better-sqlite3": "^7.2.0",
    "@prisma/client": "^7.2.0",
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.3",
    "zod": "^4.3.5"
  },
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^25.0.3",
    "prisma": "^7.2.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.9.3"
  }
}
</file>

<file path="prisma.config.ts">
// This file was generated by Prisma, and assumes you have installed the following:
// npm install --save-dev prisma dotenv
import "dotenv/config";
import { defineConfig } from "prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: "file:./dev.db",
  },
});
</file>

<file path="prisma/migrations/20260105150207_init/migration.sql">
-- CreateTable
CREATE TABLE "Company" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "cnpj" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "phone" TEXT,
    "role" TEXT NOT NULL DEFAULT 'USER',
    "companyId" TEXT,
    "unitId" INTEGER,
    "parentId" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "User_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "User_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "User_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "User" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "UserPermission" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "userId" TEXT NOT NULL,
    "sourceType" TEXT NOT NULL,
    CONSTRAINT "UserPermission_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Unit" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "city" TEXT NOT NULL,
    "state" TEXT NOT NULL,
    "country" TEXT NOT NULL,
    "numberOfWorkers" INTEGER NOT NULL,
    "companyId" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "Unit_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "Company_name_key" ON "Company"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Company_cnpj_key" ON "Company"("cnpj");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "UserPermission_userId_sourceType_key" ON "UserPermission"("userId", "sourceType");
</file>

<file path="prisma/migrations/20260107233753_init/migration.sql">
-- CreateTable
CREATE TABLE "AssetTypology" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "unitId" INTEGER NOT NULL,
    "sourceType" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "assetFields" TEXT NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "responsibleContactId" INTEGER,
    "reportingFrequency" TEXT NOT NULL DEFAULT 'anual',
    CONSTRAINT "AssetTypology_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ManagedOption" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "fieldKey" TEXT NOT NULL,
    "value" TEXT NOT NULL
);

-- CreateTable
CREATE TABLE "MobileCombustionData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "inputType" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "vehicleType" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "MobileCombustionData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "StationaryCombustionData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "StationaryCombustionData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ProductionSalesData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "product" TEXT NOT NULL,
    "quantitySold" INTEGER NOT NULL,
    "measureUnit" TEXT NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ProductionSalesData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "LubricantsIppuData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "emissionSource" TEXT,
    "lubricantType" TEXT,
    "consumption" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "LubricantsIppuData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "FugitiveEmissionsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "emissionSource" TEXT,
    "gasType" TEXT,
    "quantityReplaced" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FugitiveEmissionsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "FertilizersData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "fertilizerType" TEXT,
    "quantityKg" REAL,
    "unitMeasure" TEXT,
    "percentNitrogen" REAL,
    "percentCarbonate" REAL,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FertilizersData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EffluentsControlledData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "treatmentOrDest" TEXT NOT NULL,
    "treatmentType" TEXT,
    "finalDestType" TEXT,
    "qtyEffluentM3" REAL NOT NULL,
    "unitEffluent" TEXT NOT NULL,
    "qtyOrganic" REAL NOT NULL,
    "unitOrganic" TEXT NOT NULL,
    "qtyNitrogen" REAL NOT NULL,
    "unitNitrogen" TEXT NOT NULL,
    "organicRemovedSludge" REAL,
    "unitSludge" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EffluentsControlledData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "DomesticEffluentsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "workerType" TEXT NOT NULL,
    "numWorkers" INTEGER NOT NULL,
    "avgWorkHours" REAL NOT NULL,
    "septicTankOwner" TEXT NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "DomesticEffluentsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "LandUseChangeData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "prevLandUse" TEXT NOT NULL,
    "biome" TEXT,
    "phytophysiognomy" TEXT,
    "areaType" TEXT,
    "areaHectares" REAL NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "LandUseChangeData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "SolidWasteData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "finalDestination" TEXT,
    "wasteType" TEXT,
    "quantityGenerated" REAL,
    "unitMeasure" TEXT,
    "cityStateDest" TEXT,
    "locationControlled" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "internalTracking" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "SolidWasteData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ElectricityPurchaseData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "energySource" TEXT,
    "specifySource" TEXT,
    "consumption" REAL,
    "measureUnit" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "traceability" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ElectricityPurchaseData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "PurchasedGoodsServicesData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "itemDescription" TEXT,
    "itemType" TEXT,
    "quantity" REAL,
    "unitMeasure" TEXT,
    "acquisitionValue" REAL,
    "thirdPartyGoods" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "PurchasedGoodsServicesData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "CapitalGoodsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "capitalGood" TEXT,
    "quantity" INTEGER,
    "unitMeasure" TEXT,
    "acquisitionValue" REAL,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "CapitalGoodsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "UpstreamTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "transportMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "origin" TEXT,
    "destination" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "UpstreamTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "BusinessTravelLandData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "tripDescription" TEXT,
    "travelMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "kmReimbursed" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "BusinessTravelLandData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "DownstreamTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "transportMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "origin" TEXT,
    "destination" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "DownstreamTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "WasteTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "WasteTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "HomeOfficeData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "workRegime" TEXT,
    "numEmployees" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "HomeOfficeData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "AirTravelData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "tripDescription" TEXT,
    "airportCodeOrigin" TEXT,
    "airportCodeDest" TEXT,
    "tripCount" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "AirTravelData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EmployeeCommutingData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "identifier" TEXT,
    "methodUsed" TEXT,
    "reportType" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distanceKm" REAL,
    "employeeAddress" TEXT,
    "workAddress" TEXT,
    "daysCommuted" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EmployeeCommutingData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EnergyGenerationData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "generationSource" TEXT,
    "totalGeneration" REAL,
    "measureUnit" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EnergyGenerationData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "PlantedForestData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "areaId" TEXT,
    "speciesName" TEXT,
    "areaPrePreLast" REAL,
    "agePrePreLast" INTEGER,
    "agePreLast" INTEGER,
    "areaHarvestedPreLast" REAL,
    "currentArea" REAL,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "PlantedForestData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ConservationAreaData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "description" TEXT,
    "biome" TEXT,
    "phytophysiognomy" TEXT,
    "plantedArea" TEXT,
    "plantingStatus" TEXT,
    "areaStartYear" REAL,
    "areaEndYear" REAL,
    "changeReason" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ConservationAreaData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "ManagedOption_fieldKey_value_key" ON "ManagedOption"("fieldKey", "value");
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "sqlite"
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
}

model Company {
  id   String  @id @default(uuid())
  name String  @unique
  cnpj String? @unique

  // Relations
  users User[]
  units Unit[]

  createdAt DateTime @default(now())
}

model User {
  id       String  @id @default(uuid())
  email    String  @unique
  password String
  name     String // Moved from Contact
  phone    String? // Moved from Contact
  role     String  @default("USER") // MASTER, ADMIN, USER

  // Multi-tenancy
  companyId String?
  company   Company? @relation(fields: [companyId], references: [id])

  // Unit Assignment: A user now "belongs" to a unit (optional for MASTER/ADMIN)
  unitId Int?
  unit   Unit? @relation(fields: [unitId], references: [id])

  // Hierarchy
  parentId String?
  parent   User?   @relation("UserHierarchy", fields: [parentId], references: [id])
  children User[]  @relation("UserHierarchy")

  // Permissions: These define which Spreadsheets (SourceTypes) the user manages
  permissions UserPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserPermission {
  id         String @id @default(uuid())
  userId     String
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  sourceType String // e.g., "combustao_movel", "solid_waste"

  @@unique([userId, sourceType])
}

model Unit {
  id              Int    @id @default(autoincrement())
  name            String
  city            String
  state           String
  country         String
  numberOfWorkers Int

  // Multi-tenancy
  companyId String
  company   Company @relation(fields: [companyId], references: [id])

  // Users belonging to this unit
  users User[]

  createdAt                   DateTime                     @default(now())
  assetTypologies             AssetTypology[]
  mobileCombustionDatas       MobileCombustionData[]
  stationaryCombustionDatas   StationaryCombustionData[]
  productionSalesDatas        ProductionSalesData[]
  lubricantsIppuDatas         LubricantsIppuData[]
  fugitiveEmissionsDatas      FugitiveEmissionsData[]
  fertilizersDatas            FertilizersData[]
  effluentsControlledDatas    EffluentsControlledData[]
  domesticEffluentsDatas      DomesticEffluentsData[]
  landUseChangeDatas          LandUseChangeData[]
  solidWasteDatas             SolidWasteData[]
  electricityPurchaseDatas    ElectricityPurchaseData[]
  purchasedGoodsServicesDatas PurchasedGoodsServicesData[]
  capitalGoodsDatas           CapitalGoodsData[]
  upstreamTransportDatas      UpstreamTransportData[]
  businessTravelLandDatas     BusinessTravelLandData[]
  downstreamTransportDatas    DownstreamTransportData[]
  wasteTransportDatas         WasteTransportData[]
  homeOfficeDatas             HomeOfficeData[]
  airTravelDatas              AirTravelData[]
  employeeCommutingDatas      EmployeeCommutingData[]
  energyGenerationDatas       EnergyGenerationData[]
  plantedForestDatas          PlantedForestData[]
  conservationAreaDatas       ConservationAreaData[]
}

// --- CONFIGURATION & METADATA ---

model AssetTypology {
  id                   Int     @id @default(autoincrement())
  unitId               Int
  unit                 Unit    @relation(fields: [unitId], references: [id], onDelete: Cascade)
  sourceType           String
  description          String
  assetFields          String // JSON string
  isActive             Boolean @default(true)
  responsibleContactId Int?
  reportingFrequency   String  @default("anual")
}

model ManagedOption {
  id       Int    @id @default(autoincrement())
  fieldKey String
  value    String

  @@unique([fieldKey, value])
}

// --- ESG DATA TABLES ---

// 1. Mobile Combustion
model MobileCombustionData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription   String?
  isCompanyControlled Boolean
  inputType           String? // 'consumo' or 'distancia'
  fuelType            String?
  consumption         Float?
  consumptionUnit     String?
  distance            Float?
  distanceUnit        String?
  vehicleType         String?

  comments  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 2. Stationary Combustion
model StationaryCombustionData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription   String?
  fuelType            String?
  consumption         Float?
  unitMeasure         String? // Renamed from 'unit' to avoid conflict with relation
  isCompanyControlled Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 3. Production & Sales
model ProductionSalesData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  product      String
  quantitySold Int
  measureUnit  String
  comments     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 4. Lubricants & IPPU
model LubricantsIppuData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  emissionSource      String?
  lubricantType       String?
  consumption         Float?
  unitMeasure         String?
  isCompanyControlled Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 5. Fugitive Emissions
model FugitiveEmissionsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  emissionSource      String?
  gasType             String?
  quantityReplaced    Float?
  unitMeasure         String?
  isCompanyControlled Boolean
  comments            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 6. Fertilizers
model FertilizersData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  fertilizerType      String?
  quantityKg          Float?
  unitMeasure         String?
  percentNitrogen     Float?
  percentCarbonate    Float?
  isCompanyControlled Boolean
  comments            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 7. Controlled Effluents
model EffluentsControlledData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  treatmentOrDest String
  treatmentType   String?
  finalDestType   String?

  qtyEffluentM3 Float
  unitEffluent  String

  qtyOrganic  Float
  unitOrganic String

  qtyNitrogen  Float
  unitNitrogen String

  organicRemovedSludge Float?
  unitSludge           String?

  comments String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 8. Domestic Effluents
model DomesticEffluentsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  workerType      String
  numWorkers      Int
  avgWorkHours    Float
  septicTankOwner String
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 9. Land Use Change
model LandUseChangeData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  prevLandUse      String
  biome            String?
  phytophysiognomy String?
  areaType         String?
  areaHectares     Float
  comments         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 10. Solid Waste
model SolidWasteData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  finalDestination   String?
  wasteType          String?
  quantityGenerated  Float?
  unitMeasure        String?
  cityStateDest      String?
  locationControlled String?

  responsible      String?
  deptResponsible  String?
  email            String?
  phone            String?
  internalTracking String?
  comments         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 11. Electricity Purchase
model ElectricityPurchaseData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  energySource  String?
  specifySource String?
  consumption   Float?
  measureUnit   String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  traceability    String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 12. Purchased Goods & Services
model PurchasedGoodsServicesData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  itemDescription  String?
  itemType         String?
  quantity         Float?
  unitMeasure      String?
  acquisitionValue Float?
  thirdPartyGoods  String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 13. Capital Goods
model CapitalGoodsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  capitalGood      String?
  quantity         Int?
  unitMeasure      String?
  acquisitionValue Float?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 14. Upstream Transport
model UpstreamTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  transportMode   String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?
  origin          String?
  destination     String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 15. Business Travel (Land)
model BusinessTravelLandData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  tripDescription String?
  travelMode      String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  distance        Float?
  distanceUnit    String?
  kmReimbursed    String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 16. Downstream Transport
model DownstreamTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  transportMode   String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?
  origin          String?
  destination     String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 17. Waste Transport
model WasteTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 18. Home Office
model HomeOfficeData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  workRegime   String?
  numEmployees Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 19. Air Travel
model AirTravelData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  tripDescription   String?
  airportCodeOrigin String?
  airportCodeDest   String?
  tripCount         Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 20. Employee Commuting
model EmployeeCommutingData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  identifier      String?
  methodUsed      String?
  reportType      String?
  fuelType        String?
  consumption     Float?
  consumptionUnit String?
  distanceKm      Float?
  employeeAddress String?
  workAddress     String?
  daysCommuted    Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 21. Energy Generation
model EnergyGenerationData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription String?
  generationSource  String?
  totalGeneration   Float?
  measureUnit       String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 22. Planted Forest
model PlantedForestData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  areaId      String?
  speciesName String?

  areaPrePreLast       Float?
  agePrePreLast        Int?
  agePreLast           Int?
  areaHarvestedPreLast Float?
  currentArea          Float?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 23. Conservation Area
model ConservationAreaData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  description      String?
  biome            String?
  phytophysiognomy String?

  plantedArea    String?
  plantingStatus String?
  areaStartYear  Float?
  areaEndYear    Float?
  changeReason   String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
</file>

<file path="prisma/seed.ts">
import * as bcrypt from 'bcrypt'
import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";
import { PrismaClient } from "../generated/prisma";

const adapter = new PrismaBetterSqlite3({
    url: "file:./dev.db"
})

const prisma = new PrismaClient({ adapter });

async function main() {
    await prisma.assetTypology.deleteMany();
    await prisma.unit.deleteMany();
    await prisma.company.deleteMany();

    const masterPass = await bcrypt.hash('master123', 10)
    await prisma.user.upsert({
        where: { email: 'master@ecofinance.com' },
        update: {},
        create: {
            email: 'master@ecofinance.com',
            password: masterPass,
            name: 'System Master',
            role: 'MASTER'
        },
    });
    console.log('Seed: MASTER user created.');

    const company = await prisma.company.upsert({
        where: { name: 'EcoFinance Demo Corp' },
        update: {},
        create: {
            name: 'EcoFinance Demo Corp',
            cnpj: '12.345.678/0001-90'
        }
    });
    console.log('Seed: Company ensured.');

    const unit = await prisma.unit.upsert({
        where: { id: 1 },
        update: {},
        create: {
            name: 'Sao Paulo HQ',
            city: 'Sao Paulo',
            state: 'SP',
            country: 'Brasil',
            numberOfWorkers: 150,
            companyId: company.id
        }
    });
    console.log(`Seed: Unit ensured with ID: ${unit.id}`);
}

main().catch(e => console.error(e)).finally(() => prisma.$disconnect());
</file>

<file path="src/controllers/authController.ts">
import { Request, Response } from 'express';
import * as authService from '../services/authService';

export const handleLogin = async (req: Request, res: Response) => {
    try {
        const token = await authService.login(req.body.email, req.body.password);
        res.json({ token });
    } catch (error: any) {
        res.status(401).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/configController.ts">
import { Request, Response } from 'express';
import * as configService from '../services/configService';

// --- ASSET TYPOLOGIES ---

export const getTypologies = async (req: Request, res: Response) => {
    try {
        const { unitId, sourceType } = req.query;

        const data = await configService.getTypologies(
            unitId ? Number(unitId) : undefined,
            sourceType ? String(sourceType) : undefined
        );

        res.json(data);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
};

export const createTypology = async (req: Request, res: Response) => {
    try {
        const result = await configService.createTypology(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        // Distinguish Zod validation errors from Server errors
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};

export const deleteTypology = async (req: Request, res: Response) => {
    try {
        const id = Number(req.params.id);
        if (isNaN(id)) return res.status(400).json({ error: "Invalid ID" });

        await configService.deleteTypology(id);
        res.status(204).send();
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

// --- MANAGED OPTIONS ---

export const getOptions = async (req: Request, res: Response) => {
    try {
        const { fieldKey } = req.query;
        if (!fieldKey) return res.status(400).json({ error: "fieldKey required" });

        const options = await configService.getOptions(String(fieldKey));
        res.json(options);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
};

export const createOption = async (req: Request, res: Response) => {
    try {
        const result = await configService.createOption(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};
</file>

<file path="src/controllers/esgDataController.ts">
import { Request, Response } from 'express';
import { getServiceOrThrow } from '../utils/modelRegistry';

export const getByUnit = async (req: Request, res: Response) => {
    try {
        const { sourceType } = req.params;
        const { unitId, year } = req.query;

        if (!unitId) return res.status(400).json({ error: "unitId is required" });

        const service = getServiceOrThrow(sourceType);
        const data = await service.getByUnitAndYear(Number(unitId), year ? Number(year) : undefined);

        res.json(data);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

export const createEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType } = req.params;
        const service = getServiceOrThrow(sourceType);

        const result = await service.create(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        // Zod validation error handling
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};

export const updateEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType, id } = req.params;
        const service = getServiceOrThrow(sourceType);

        const result = await service.update(Number(id), req.body);
        res.json(result);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

export const deleteEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType, id } = req.params;
        const service = getServiceOrThrow(sourceType);

        await service.delete(Number(id));
        res.status(204).send();
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};
</file>

<file path="src/controllers/userController.ts">
import { Request, Response } from 'express';
import * as userService from '../services/userService';
import { createUserSchema } from "../schemas/userSchema";

export const createUser = async (req: Request, res: Response) => {
    try {
        const validatedData = createUserSchema.parse(req.body);

        const newUser = await userService.registerUser(validatedData, req.user);

        const { password, ...safeUser } = newUser;
        res.status(201).json(safeUser);
    } catch (error: any) {
        if (error.name === 'ZodError') {
            return res.status(400).json({ errors: error.errors });
        }

        res.status(400).json({ error: error.message });
    }
};
</file>

<file path="src/index.ts">
import express from 'express';
import cors from 'cors';
import * as dotenv from 'dotenv';

import authRoutes from './routes/authRoutes';
import userRoutes from './routes/userRoutes';
import esgRoutes from './routes/esgRoutes';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/esg', esgRoutes);

app.get('/health', (req, res) => res.json({ status: 'OK' }));

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});
</file>

<file path="src/interfaces/crudDelegate.ts">
export interface CrudDelegate<T> {
    findMany(args?: any): Promise<T[]>;

    findUnique(args: any): Promise<T | null>;

    create(args: { data: any }): Promise<T>;

    update(args: { where: any; data: any }): Promise<T>;

    delete(args: { where: any }): Promise<T>;

    count(args?: any): Promise<number>;
}
</file>

<file path="src/middleware/authMiddleware.ts">
import { NextFunction, Request, Response } from 'express';
import * as jwt from 'jsonwebtoken';
import { AppJwtPayload } from "../types/auth";

declare global {
    namespace Express {
        interface Request {
            user?: AppJwtPayload; // Make optional, populated only after auth
        }
    }
}

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers.authorization;

    if (!authHeader?.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'No token provided or invalid format' });
    }

    const token = authHeader.split(' ')[1];

    if (!token) return res.status(401).json({ error: 'No token provided' });

    try {
        req.user = jwt.verify(token, process.env.JWT_SECRET!) as AppJwtPayload;
        next();
    } catch (err) {
        res.status(401).json({ error: 'Invalid token' });
    }
};
</file>

<file path="src/repositories/configRepository.ts">
import prisma from './prisma';
import { Prisma } from "../../generated/prisma";

export const findTypologies = async (filters: { unitId?: number; sourceType?: string }) => {
    const where: Prisma.AssetTypologyWhereInput = {};
    if (filters.unitId) where.unitId = filters.unitId;
    if (filters.sourceType) where.sourceType = filters.sourceType;

    return prisma.assetTypology.findMany({
        where,
        orderBy: { description: 'asc' }
    });
};

export const createTypology = async (data: Prisma.AssetTypologyCreateInput) => {
    return prisma.assetTypology.create({ data });
};

export const deleteTypology = async (id: number) => {
    return prisma.assetTypology.delete({
        where: { id }
    });
};

export const findOptions = async (fieldKey: string) => {
    return prisma.managedOption.findMany({
        where: { fieldKey },
        orderBy: { value: 'asc' }
    });
};

export const createOption = async (data: Prisma.ManagedOptionCreateInput) => {
    return prisma.managedOption.create({ data });
};
</file>

<file path="src/repositories/prisma.ts">
import { PrismaClient } from "../../generated/prisma";
import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";

const adapter = new PrismaBetterSqlite3({
    url: "file:./dev.db"
})

const prisma = new PrismaClient({ adapter });

export default prisma;
</file>

<file path="src/repositories/userRepository.ts">
import prisma from "./prisma";
import { CreateUserDTO } from "../schemas/userSchema";

export const create = async (userData: CreateUserDTO) => {
    return prisma.user.create({
        data: {
            email: userData.email,
            password: userData.password,
            name: userData.name,
            role: userData.role,
            companyId: userData.companyId,
            unitId: userData.unitId,
            parentId: userData.parentId,
        }
    })
}

export const findByEmail = async (email: string) => {
    return prisma.user.findUnique({
        where: { email },
        include: { company: true }
    })
}
</file>

<file path="src/routes/authRoutes.ts">
import { Router } from "express";
import * as authController from "../controllers/authController";

const router = Router()

router.post("/login", authController.handleLogin)

export default router
</file>

<file path="src/routes/esgRoutes.ts">
import { Router } from 'express';
import { authenticate } from '../middleware/authMiddleware';
import * as esgController from '../controllers/esgDataController';
import * as configController from '../controllers/configController';

const router = Router();

// --- Configuration Routes ---
router.get('/config/typologies', authenticate, configController.getTypologies);
router.post('/config/typologies', authenticate, configController.createTypology);
router.delete('/config/typologies/:id', authenticate, configController.deleteTypology);

router.get('/config/options', authenticate, configController.getOptions);
router.post('/config/options', authenticate, configController.createOption);

// --- Generic ESG Data Routes ---
// :sourceType matches the keys in esgRegistry (e.g., "mobile_combustion")
router.get('/data/:sourceType', authenticate, esgController.getByUnit);
router.post('/data/:sourceType', authenticate, esgController.createEntry);
router.put('/data/:sourceType/:id', authenticate, esgController.updateEntry);
router.delete('/data/:sourceType/:id', authenticate, esgController.deleteEntry);

export default router;
</file>

<file path="src/routes/userRoutes.ts">
import { Router } from "express";
import * as userController from '../controllers/userController';
import { authenticate } from "../middleware/authMiddleware";

const router = Router()

router.post("/create-user", authenticate, userController.createUser)

export default router
</file>

<file path="src/schemas/esgSchemas.ts">
import { z } from 'zod';

// --- 1. SHARED PATTERNS (DRY Principle) ---

// Base schema for almost all ESG data tables
const baseEsgSchema = z.object({
    year: z.number().int().min(2000).max(2100),
    period: z.string().min(1, "Period is required"), // e.g., "Janeiro" or "Annual"
    unitId: z.number().int().positive("Unit ID is required"),
    comments: z.string().optional(),
});

// Helper for nullable floats (common in ESG data)
const nullableFloat = z.number().optional().nullable();
const nullableString = z.string().optional().nullable();
const nullableInt = z.number().int().optional().nullable();

// --- 2. CONFIGURATION SCHEMAS ---

export const managedOptionSchema = z.object({
    fieldKey: z.string().min(1),
    value: z.string().min(1),
});

export const assetTypologySchema = z.object({
    unitId: z.number().int().positive(),
    sourceType: z.string().min(1),
    description: z.string().min(1),
    // DX Improvement: Accept object, transform to string for DB
    assetFields: z.record(z.string(), z.any()).transform((val) => JSON.stringify(val)),
    isActive: z.boolean().default(true),
    responsibleContactId: z.number().int().optional().nullable(),
    reportingFrequency: z.enum(['mensal', 'anual']).default('anual'),
});

// --- 3. DATA TABLES (Combustion & Energy) ---

export const mobileCombustionSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    isCompanyControlled: z.boolean(),
    inputType: z.enum(['consumo', 'distancia']).optional().nullable(),
    fuelType: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    vehicleType: nullableString,
});

export const stationaryCombustionSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    fuelType: nullableString,
    consumption: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const electricityPurchaseSchema = baseEsgSchema.extend({
    energySource: nullableString,
    specifySource: nullableString,
    consumption: nullableFloat,
    measureUnit: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
    traceability: nullableString,
});

export const energyGenerationSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    generationSource: nullableString,
    totalGeneration: nullableFloat,
    measureUnit: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 4. DATA TABLES (Logistics & Transport) ---

// Base for transport since they share many fields
const baseTransportSchema = baseEsgSchema.extend({
    transportedItem: nullableString,
    reportType: nullableString,
    fuel: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    vehicleClass: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    transportedLoad: nullableFloat,
    tripCount: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const upstreamTransportSchema = baseTransportSchema.extend({
    transportMode: nullableString,
    origin: nullableString,
    destination: nullableString,
});

export const downstreamTransportSchema = baseTransportSchema.extend({
    transportMode: nullableString,
    origin: nullableString,
    destination: nullableString,
});

export const wasteTransportSchema = baseTransportSchema; // Matches base exactly

export const businessTravelLandSchema = baseEsgSchema.extend({
    tripDescription: nullableString,
    travelMode: nullableString,
    reportType: nullableString,
    fuel: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    kmReimbursed: nullableString, // Boolean-ish string in legacy, keep flexible or strict?
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const airTravelSchema = baseEsgSchema.extend({
    tripDescription: nullableString,
    airportCodeOrigin: nullableString.refine(v => !v || v.length === 3, "Airport code must be 3 letters"),
    airportCodeDest: nullableString.refine(v => !v || v.length === 3, "Airport code must be 3 letters"),
    tripCount: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const employeeCommutingSchema = baseEsgSchema.extend({
    identifier: nullableString,
    methodUsed: nullableString,
    reportType: nullableString,
    fuelType: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distanceKm: nullableFloat,
    employeeAddress: nullableString,
    workAddress: nullableString,
    daysCommuted: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 5. DATA TABLES (Production & Materials) ---

export const productionSalesSchema = baseEsgSchema.extend({
    product: z.string().min(1),
    quantitySold: z.number().int(),
    measureUnit: z.string().min(1),
});

export const purchasedGoodsServicesSchema = baseEsgSchema.extend({
    itemDescription: nullableString,
    itemType: nullableString,
    quantity: nullableFloat,
    unitMeasure: nullableString,
    acquisitionValue: nullableFloat,
    thirdPartyGoods: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const capitalGoodsSchema = baseEsgSchema.extend({
    capitalGood: nullableString,
    quantity: nullableInt,
    unitMeasure: nullableString,
    acquisitionValue: nullableFloat,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 6. DATA TABLES (Emissions & Waste) ---

export const lubricantsIppuSchema = baseEsgSchema.extend({
    emissionSource: nullableString,
    lubricantType: nullableString,
    consumption: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const fugitiveEmissionsSchema = baseEsgSchema.extend({
    emissionSource: nullableString,
    gasType: nullableString,
    quantityReplaced: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const fertilizersSchema = baseEsgSchema.extend({
    fertilizerType: nullableString,
    quantityKg: nullableFloat,
    unitMeasure: nullableString,
    percentNitrogen: nullableFloat.refine(val => !val || (val >= 0 && val <= 100), "Percentage must be 0-100"),
    percentCarbonate: nullableFloat.refine(val => !val || (val >= 0 && val <= 100), "Percentage must be 0-100"),
    isCompanyControlled: z.boolean(),
});

export const solidWasteSchema = baseEsgSchema.extend({
    finalDestination: nullableString,
    wasteType: nullableString,
    quantityGenerated: nullableFloat,
    unitMeasure: nullableString,
    cityStateDest: nullableString,
    locationControlled: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
    internalTracking: nullableString,
});

export const effluentsControlledSchema = baseEsgSchema.extend({
    treatmentOrDest: z.string().min(1),
    treatmentType: nullableString,
    finalDestType: nullableString,
    qtyEffluentM3: z.number(),
    unitEffluent: z.string(),
    qtyOrganic: z.number(),
    unitOrganic: z.string(),
    qtyNitrogen: z.number(),
    unitNitrogen: z.string(),
    organicRemovedSludge: nullableFloat,
    unitSludge: nullableString,
});

export const domesticEffluentsSchema = baseEsgSchema.extend({
    workerType: z.string().min(1),
    numWorkers: z.number().int(),
    avgWorkHours: z.number(),
    septicTankOwner: z.string(), // "Sim", "No" or specific owner
});

// --- 7. DATA TABLES (Land Use & Forestry) ---

export const landUseChangeSchema = baseEsgSchema.extend({
    prevLandUse: z.string().min(1),
    biome: nullableString,
    phytophysiognomy: nullableString,
    areaType: nullableString,
    areaHectares: z.number(),
});

export const plantedForestSchema = baseEsgSchema.extend({
    areaId: nullableString,
    speciesName: nullableString,
    areaPrePreLast: nullableFloat,
    agePrePreLast: nullableInt,
    agePreLast: nullableInt,
    areaHarvestedPreLast: nullableFloat,
    currentArea: nullableFloat,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const conservationAreaSchema = baseEsgSchema.extend({
    description: nullableString,
    biome: nullableString,
    phytophysiognomy: nullableString,
    plantedArea: nullableString,
    plantingStatus: nullableString,
    areaStartYear: nullableFloat,
    areaEndYear: nullableFloat,
    changeReason: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const homeOfficeSchema = baseEsgSchema.extend({
    workRegime: nullableString,
    numEmployees: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- TYPES EXPORT ---
// Example usage: type MobileCombustionInput = z.infer<typeof mobileCombustionSchema>;
</file>

<file path="src/schemas/userSchema.ts">
import { z } from 'zod';

// Define the schema strictly
export const createUserSchema = z.object({
    email: z.string().email(),
    password: z.string().min(8, "Password must be at least 8 characters"),
    name: z.string().min(2),
    role: z.enum(['MASTER', 'ADMIN', 'USER']).default('USER'),
    companyId: z.string().uuid().nullable().optional(),
    unitId: z.number().int().nullable().optional(),
    parentId: z.string().nullable().optional(),
});

// Infer the DTO type from the schema (Single Source of Truth)
export type CreateUserDTO = z.infer<typeof createUserSchema>;
</file>

<file path="src/services/authService.ts">
import * as userRepository from '../repositories/userRepository';
import { comparePassword } from '../utils/passwordUtils';
import { generateToken } from '../utils/jwtUtils';

export const login = async (email: string, pass: string) => {
    const user = await userRepository.findByEmail(email);
    if (!user || !(await comparePassword(pass, user.password))) throw new Error('Invalid credentials');
    return generateToken({ id: user.id, role: user.role, companyId: user.companyId });
};
</file>

<file path="src/services/configService.ts">
import * as configRepo from '../repositories/configRepository';
import { assetTypologySchema, managedOptionSchema } from '../schemas/esgSchemas';

// --- ASSET TYPOLOGIES ---

export const getTypologies = async (unitId?: number, sourceType?: string) => {
    return configRepo.findTypologies({ unitId, sourceType });
};

export const createTypology = async (rawData: unknown) => {
    // Zod handles validation AND the transformation of assetFields object -> JSON string
    const cleanData = assetTypologySchema.parse(rawData);

    // Type casting needed here because Zod output structure matches DB expectation
    // but Typescript might need a nudge to match Prisma generated types exactly
    return configRepo.createTypology(cleanData as any);
};

export const deleteTypology = async (id: number) => {
    return configRepo.deleteTypology(id);
};

// --- MANAGED OPTIONS ---

export const getOptions = async (fieldKey: string) => {
    return configRepo.findOptions(fieldKey);
};

export const createOption = async (rawData: unknown) => {
    const cleanData = managedOptionSchema.parse(rawData);
    return configRepo.createOption(cleanData as any);
};
</file>

<file path="src/services/esgGenericService.ts">
import { CrudDelegate } from "../interfaces/curdDelegate";
import { ZodObject } from "zod";
import { AppJwtPayload } from "../types/auth";

export class EsgGenericService<T> {
    constructor(
        private delegate: CrudDelegate<T>,
        private schema: ZodObject<any, any>
    ) {}

    async getByUnitAndYear(unitId: number, year?: number) {
        const where: any = { unitId };
        if (year) where.year = year;
        return this.delegate.findMany({ where, orderBy: { createdAt: 'desc' } });
    }

    async create(data: any) {
        const cleanData = this.schema.parse(data);

        return this.delegate.create({
            data: cleanData
        });
    }

    async update(id: number, data: any) {
        const cleanData = this.schema.partial().parse(data); // Allow partial updates
        return this.delegate.update({
            where: { id },
            data: cleanData
        });
    }

    async delete(id: number) {
        return this.delegate.delete({
            where: { id }
        });
    }
}
</file>

<file path="src/services/userService.ts">
import { CreateUserDTO, UserPayload } from "../types/user";
import * as userRepository from "../repositories/userRepository";
import { hashPassword } from "../utils/passwordUtils";

export const registerUser = async (userData: CreateUserDTO, currentUser: UserPayload) => {
    const exists = await userRepository.findByEmail(userData.email);
    if (exists) throw new Error('User already exists');

    const companyId = currentUser.role === 'ADMIN' ? currentUser.companyId : userData.companyId;
    const hashedPassword = await hashPassword(userData.password);

    return userRepository.create({
        ...userData,
        password: hashedPassword,
        companyId,
        parentId: currentUser.id
    });
}
</file>

<file path="src/types/auth.ts">
import { JwtPayload } from "jsonwebtoken";

export interface AppJwtPayload extends JwtPayload {
    id: string;
    role: string;
    companyId: string | null;
}
</file>

<file path="src/utils/jwtUtils.ts">
import * as jwt from 'jsonwebtoken';
import * as dotenv from 'dotenv';

dotenv.config();

const JWT_SECRET = process.env.JWT_SECRET || 'super-secret';

export const generateToken = (payload: object) => jwt.sign(payload, JWT_SECRET, { expiresIn: '8h' });
</file>

<file path="src/utils/modelRegistry.ts">
import prisma from "../repositories/prisma";
import * as schemas from "../schemas/esgSchemas";
import { EsgGenericService } from "../services/esgGenericService";

// Helper type to define the map structure
type RegistryEntry = {
    service: EsgGenericService<any>;
    name: string; // Display name
};

// Singleton map
export const esgRegistry: Record<string, RegistryEntry> = {
    // --- Combustion & Energy ---
    'mobile_combustion': {
        service: new EsgGenericService(prisma.mobileCombustionData, schemas.mobileCombustionSchema),
        name: 'Mobile Combustion'
    },
    'stationary_combustion': {
        service: new EsgGenericService(prisma.stationaryCombustionData, schemas.stationaryCombustionSchema),
        name: 'Stationary Combustion'
    },
    'electricity_purchase': {
        service: new EsgGenericService(prisma.electricityPurchaseData, schemas.electricityPurchaseSchema),
        name: 'Electricity Purchase'
    },
    'energy_generation': {
        service: new EsgGenericService(prisma.energyGenerationData, schemas.energyGenerationSchema),
        name: 'Energy Generation'
    },

    // --- Transport ---
    'upstream_transport': {
        service: new EsgGenericService(prisma.upstreamTransportData, schemas.upstreamTransportSchema),
        name: 'Upstream Transport'
    },
    'downstream_transport': {
        service: new EsgGenericService(prisma.downstreamTransportData, schemas.downstreamTransportSchema),
        name: 'Downstream Transport'
    },
    'waste_transport': {
        service: new EsgGenericService(prisma.wasteTransportData, schemas.wasteTransportSchema),
        name: 'Waste Transport'
    },
    'business_travel_land': {
        service: new EsgGenericService(prisma.businessTravelLandData, schemas.businessTravelLandSchema),
        name: 'Business Travel (Land)'
    },
    'air_travel': {
        service: new EsgGenericService(prisma.airTravelData, schemas.airTravelSchema),
        name: 'Air Travel'
    },
    'employee_commuting': {
        service: new EsgGenericService(prisma.employeeCommutingData, schemas.employeeCommutingSchema),
        name: 'Employee Commuting'
    },

    // --- Production & Materials ---
    'production_sales': {
        service: new EsgGenericService(prisma.productionSalesData, schemas.productionSalesSchema),
        name: 'Production & Sales'
    },
    'purchased_goods': {
        service: new EsgGenericService(prisma.purchasedGoodsServicesData, schemas.purchasedGoodsServicesSchema),
        name: 'Purchased Goods'
    },
    'capital_goods': {
        service: new EsgGenericService(prisma.capitalGoodsData, schemas.capitalGoodsSchema),
        name: 'Capital Goods'
    },

    // --- Emissions & Waste ---
    'lubricants_ippu': {
        service: new EsgGenericService(prisma.lubricantsIppuData, schemas.lubricantsIppuSchema),
        name: 'Lubricants & IPPU'
    },
    'fugitive_emissions': {
        service: new EsgGenericService(prisma.fugitiveEmissionsData, schemas.fugitiveEmissionsSchema),
        name: 'Fugitive Emissions'
    },
    'fertilizers': {
        service: new EsgGenericService(prisma.fertilizersData, schemas.fertilizersSchema),
        name: 'Fertilizers'
    },
    'solid_waste': {
        service: new EsgGenericService(prisma.solidWasteData, schemas.solidWasteSchema),
        name: 'Solid Waste'
    },
    'effluents_controlled': {
        service: new EsgGenericService(prisma.effluentsControlledData, schemas.effluentsControlledSchema),
        name: 'Controlled Effluents'
    },
    'domestic_effluents': {
        service: new EsgGenericService(prisma.domesticEffluentsData, schemas.domesticEffluentsSchema),
        name: 'Domestic Effluents'
    },

    // --- Land & Forest ---
    'land_use_change': {
        service: new EsgGenericService(prisma.landUseChangeData, schemas.landUseChangeSchema),
        name: 'Land Use Change'
    },
    'planted_forest': {
        service: new EsgGenericService(prisma.plantedForestData, schemas.plantedForestSchema),
        name: 'Planted Forest'
    },
    'conservation_area': {
        service: new EsgGenericService(prisma.conservationAreaData, schemas.conservationAreaSchema),
        name: 'Conservation Area'
    },
    'home_office': {
        service: new EsgGenericService(prisma.homeOfficeData, schemas.homeOfficeSchema),
        name: 'Home Office'
    }
};

export const getServiceOrThrow = (sourceType: string) => {
    const entry = esgRegistry[sourceType];
    if (!entry) throw new Error(`Invalid source type: ${sourceType}`);
    return entry.service;
};
</file>

<file path="src/utils/passwordUtils.ts">
import * as bcrypt from 'bcrypt';

const SALT_ROUNDS = 10; // Standard balance between security and performance

export const hashPassword = async (password: string): Promise<string> => {
    return bcrypt.hash(password, SALT_ROUNDS);
};

export const comparePassword = async (password: string, hash: string): Promise<boolean> => {
    return bcrypt.compare(password, hash);
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "strict": true,
    "typeRoots": ["./node_modules/@types", "./src/types"]
  },
  "include": ["src/**/*"]
}
</file>

</files>
</file>

<file path="backend-new/src/controllers/authController.ts">
import { Request, Response } from 'express';
import * as authService from '../services/authService';

export const handleLogin = async (req: Request, res: Response) => {
    try {
        const token = await authService.login(req.body.email, req.body.password);
        res.json({ token });
    } catch (error: any) {
        res.status(401).json({ message: error.message });
    }
};
</file>

<file path="backend-new/src/controllers/configController.ts">
import { Request, Response } from 'express';
import * as configService from '../services/configService';

// --- ASSET TYPOLOGIES ---

export const getTypologies = async (req: Request, res: Response) => {
    try {
        const { unitId, sourceType } = req.query;

        const data = await configService.getTypologies(
            unitId ? Number(unitId) : undefined,
            sourceType ? String(sourceType) : undefined
        );

        res.json(data);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
};

export const createTypology = async (req: Request, res: Response) => {
    try {
        const result = await configService.createTypology(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        // Distinguish Zod validation errors from Server errors
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};

export const deleteTypology = async (req: Request, res: Response) => {
    try {
        const id = Number(req.params.id);
        if (isNaN(id)) return res.status(400).json({ error: "Invalid ID" });

        await configService.deleteTypology(id);
        res.status(204).send();
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

// --- MANAGED OPTIONS ---

export const getOptions = async (req: Request, res: Response) => {
    try {
        const { fieldKey } = req.query;
        if (!fieldKey) return res.status(400).json({ error: "fieldKey required" });

        const options = await configService.getOptions(String(fieldKey));
        res.json(options);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
};

export const createOption = async (req: Request, res: Response) => {
    try {
        const result = await configService.createOption(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};
</file>

<file path="backend-new/src/controllers/esgDataController.ts">
import { Request, Response } from 'express';
import { getServiceOrThrow } from '../utils/modelRegistry';

export const getByUnit = async (req: Request, res: Response) => {
    try {
        const { sourceType } = req.params;
        const { unitId, year } = req.query;

        if (!unitId) return res.status(400).json({ error: "unitId is required" });

        const service = getServiceOrThrow(sourceType);
        const data = await service.getByUnitAndYear(Number(unitId), year ? Number(year) : undefined);

        res.json(data);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

export const createEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType } = req.params;
        const service = getServiceOrThrow(sourceType);

        const result = await service.create(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        // Zod validation error handling
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};

export const updateEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType, id } = req.params;
        const service = getServiceOrThrow(sourceType);

        const result = await service.update(Number(id), req.body);
        res.json(result);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

export const deleteEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType, id } = req.params;
        const service = getServiceOrThrow(sourceType);

        await service.delete(Number(id));
        res.status(204).send();
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};
</file>

<file path="backend-new/src/controllers/userController.ts">
import { Request, Response } from 'express';
import * as userService from '../services/userService';
import { createUserSchema } from "../schemas/userSchema";

export const createUser = async (req: Request, res: Response) => {
    try {
        const validatedData = createUserSchema.parse(req.body);

        const newUser = await userService.registerUser(validatedData, req.user);

        const { password, ...safeUser } = newUser;
        res.status(201).json(safeUser);
    } catch (error: any) {
        if (error.name === 'ZodError') {
            return res.status(400).json({ errors: error.errors });
        }

        res.status(400).json({ error: error.message });
    }
};
</file>

<file path="backend-new/src/index.ts">
import express from 'express';
import cors from 'cors';
import * as dotenv from 'dotenv';

import authRoutes from './routes/authRoutes';
import userRoutes from './routes/userRoutes';
import esgRoutes from './routes/esgRoutes';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/esg', esgRoutes);

app.get('/health', (req, res) => res.json({ status: 'OK' }));

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});
</file>

<file path="backend-new/src/interfaces/crudDelegate.ts">
export interface CrudDelegate<T> {
    findMany(args?: any): Promise<T[]>;

    findUnique(args: any): Promise<T | null>;

    create(args: { data: any }): Promise<T>;

    update(args: { where: any; data: any }): Promise<T>;

    delete(args: { where: any }): Promise<T>;

    count(args?: any): Promise<number>;
}
</file>

<file path="backend-new/src/middleware/authMiddleware.ts">
import { NextFunction, Request, Response } from 'express';
import * as jwt from 'jsonwebtoken';
import { AppJwtPayload } from "../types/auth";

declare global {
    namespace Express {
        interface Request {
            user?: AppJwtPayload; // Make optional, populated only after auth
        }
    }
}

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers.authorization;

    if (!authHeader?.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'No token provided or invalid format' });
    }

    const token = authHeader.split(' ')[1];

    if (!token) return res.status(401).json({ error: 'No token provided' });

    try {
        req.user = jwt.verify(token, process.env.JWT_SECRET!) as AppJwtPayload;
        next();
    } catch (err) {
        res.status(401).json({ error: 'Invalid token' });
    }
};
</file>

<file path="backend-new/src/repositories/configRepository.ts">
import prisma from './prisma';
import { Prisma } from "../../generated/prisma";

export const findTypologies = async (filters: { unitId?: number; sourceType?: string }) => {
    const where: Prisma.AssetTypologyWhereInput = {};
    if (filters.unitId) where.unitId = filters.unitId;
    if (filters.sourceType) where.sourceType = filters.sourceType;

    return prisma.assetTypology.findMany({
        where,
        orderBy: { description: 'asc' }
    });
};

export const createTypology = async (data: Prisma.AssetTypologyCreateInput) => {
    return prisma.assetTypology.create({ data });
};

export const deleteTypology = async (id: number) => {
    return prisma.assetTypology.delete({
        where: { id }
    });
};

export const findOptions = async (fieldKey: string) => {
    return prisma.managedOption.findMany({
        where: { fieldKey },
        orderBy: { value: 'asc' }
    });
};

export const createOption = async (data: Prisma.ManagedOptionCreateInput) => {
    return prisma.managedOption.create({ data });
};
</file>

<file path="backend-new/src/repositories/prisma.ts">
import { PrismaClient } from "../../generated/prisma";
import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";

const adapter = new PrismaBetterSqlite3({
    url: "file:./dev.db"
})

const prisma = new PrismaClient({ adapter });

export default prisma;
</file>

<file path="backend-new/src/repositories/userRepository.ts">
import prisma from "./prisma";
import { CreateUserDTO } from "../schemas/userSchema";

export const create = async (userData: CreateUserDTO) => {
    return prisma.user.create({
        data: {
            email: userData.email,
            password: userData.password,
            name: userData.name,
            role: userData.role,
            companyId: userData.companyId,
            unitId: userData.unitId,
            parentId: userData.parentId,
        }
    })
}

export const findByEmail = async (email: string) => {
    return prisma.user.findUnique({
        where: { email },
        include: { company: true }
    })
}
</file>

<file path="backend-new/src/routes/authRoutes.ts">
import { Router } from "express";
import * as authController from "../controllers/authController";

const router = Router()

router.post("/login", authController.handleLogin)

export default router
</file>

<file path="backend-new/src/routes/esgRoutes.ts">
import { Router } from 'express';
import { authenticate } from '../middleware/authMiddleware';
import * as esgController from '../controllers/esgDataController';
import * as configController from '../controllers/configController';

const router = Router();

// --- Configuration Routes ---
router.get('/config/typologies', authenticate, configController.getTypologies);
router.post('/config/typologies', authenticate, configController.createTypology);
router.delete('/config/typologies/:id', authenticate, configController.deleteTypology);

router.get('/config/options', authenticate, configController.getOptions);
router.post('/config/options', authenticate, configController.createOption);

// --- Generic ESG Data Routes ---
// :sourceType matches the keys in esgRegistry (e.g., "mobile_combustion")
router.get('/data/:sourceType', authenticate, esgController.getByUnit);
router.post('/data/:sourceType', authenticate, esgController.createEntry);
router.put('/data/:sourceType/:id', authenticate, esgController.updateEntry);
router.delete('/data/:sourceType/:id', authenticate, esgController.deleteEntry);

export default router;
</file>

<file path="backend-new/src/routes/userRoutes.ts">
import { Router } from "express";
import * as userController from '../controllers/userController';
import { authenticate } from "../middleware/authMiddleware";

const router = Router()

router.post("/create-user", authenticate, userController.createUser)

export default router
</file>

<file path="backend-new/src/schemas/esgSchemas.ts">
import { z } from 'zod';

// --- 1. SHARED PATTERNS (DRY Principle) ---

// Base schema for almost all ESG data tables
const baseEsgSchema = z.object({
    year: z.number().int().min(2000).max(2100),
    period: z.string().min(1, "Period is required"), // e.g., "Janeiro" or "Annual"
    unitId: z.number().int().positive("Unit ID is required"),
    comments: z.string().optional(),
});

// Helper for nullable floats (common in ESG data)
const nullableFloat = z.number().optional().nullable();
const nullableString = z.string().optional().nullable();
const nullableInt = z.number().int().optional().nullable();

// --- 2. CONFIGURATION SCHEMAS ---

export const managedOptionSchema = z.object({
    fieldKey: z.string().min(1),
    value: z.string().min(1),
});

export const assetTypologySchema = z.object({
    unitId: z.number().int().positive(),
    sourceType: z.string().min(1),
    description: z.string().min(1),
    // DX Improvement: Accept object, transform to string for DB
    assetFields: z.record(z.string(), z.any()).transform((val) => JSON.stringify(val)),
    isActive: z.boolean().default(true),
    responsibleContactId: z.number().int().optional().nullable(),
    reportingFrequency: z.enum(['mensal', 'anual']).default('anual'),
});

// --- 3. DATA TABLES (Combustion & Energy) ---

export const mobileCombustionSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    isCompanyControlled: z.boolean(),
    inputType: z.enum(['consumo', 'distancia']).optional().nullable(),
    fuelType: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    vehicleType: nullableString,
});

export const stationaryCombustionSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    fuelType: nullableString,
    consumption: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const electricityPurchaseSchema = baseEsgSchema.extend({
    energySource: nullableString,
    specifySource: nullableString,
    consumption: nullableFloat,
    measureUnit: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
    traceability: nullableString,
});

export const energyGenerationSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    generationSource: nullableString,
    totalGeneration: nullableFloat,
    measureUnit: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 4. DATA TABLES (Logistics & Transport) ---

// Base for transport since they share many fields
const baseTransportSchema = baseEsgSchema.extend({
    transportedItem: nullableString,
    reportType: nullableString,
    fuel: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    vehicleClass: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    transportedLoad: nullableFloat,
    tripCount: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const upstreamTransportSchema = baseTransportSchema.extend({
    transportMode: nullableString,
    origin: nullableString,
    destination: nullableString,
});

export const downstreamTransportSchema = baseTransportSchema.extend({
    transportMode: nullableString,
    origin: nullableString,
    destination: nullableString,
});

export const wasteTransportSchema = baseTransportSchema; // Matches base exactly

export const businessTravelLandSchema = baseEsgSchema.extend({
    tripDescription: nullableString,
    travelMode: nullableString,
    reportType: nullableString,
    fuel: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    kmReimbursed: nullableString, // Boolean-ish string in legacy, keep flexible or strict?
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const airTravelSchema = baseEsgSchema.extend({
    tripDescription: nullableString,
    airportCodeOrigin: nullableString.refine(v => !v || v.length === 3, "Airport code must be 3 letters"),
    airportCodeDest: nullableString.refine(v => !v || v.length === 3, "Airport code must be 3 letters"),
    tripCount: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const employeeCommutingSchema = baseEsgSchema.extend({
    identifier: nullableString,
    methodUsed: nullableString,
    reportType: nullableString,
    fuelType: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distanceKm: nullableFloat,
    employeeAddress: nullableString,
    workAddress: nullableString,
    daysCommuted: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 5. DATA TABLES (Production & Materials) ---

export const productionSalesSchema = baseEsgSchema.extend({
    product: z.string().min(1),
    quantitySold: z.number().int(),
    measureUnit: z.string().min(1),
});

export const purchasedGoodsServicesSchema = baseEsgSchema.extend({
    itemDescription: nullableString,
    itemType: nullableString,
    quantity: nullableFloat,
    unitMeasure: nullableString,
    acquisitionValue: nullableFloat,
    thirdPartyGoods: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const capitalGoodsSchema = baseEsgSchema.extend({
    capitalGood: nullableString,
    quantity: nullableInt,
    unitMeasure: nullableString,
    acquisitionValue: nullableFloat,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 6. DATA TABLES (Emissions & Waste) ---

export const lubricantsIppuSchema = baseEsgSchema.extend({
    emissionSource: nullableString,
    lubricantType: nullableString,
    consumption: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const fugitiveEmissionsSchema = baseEsgSchema.extend({
    emissionSource: nullableString,
    gasType: nullableString,
    quantityReplaced: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const fertilizersSchema = baseEsgSchema.extend({
    fertilizerType: nullableString,
    quantityKg: nullableFloat,
    unitMeasure: nullableString,
    percentNitrogen: nullableFloat.refine(val => !val || (val >= 0 && val <= 100), "Percentage must be 0-100"),
    percentCarbonate: nullableFloat.refine(val => !val || (val >= 0 && val <= 100), "Percentage must be 0-100"),
    isCompanyControlled: z.boolean(),
});

export const solidWasteSchema = baseEsgSchema.extend({
    finalDestination: nullableString,
    wasteType: nullableString,
    quantityGenerated: nullableFloat,
    unitMeasure: nullableString,
    cityStateDest: nullableString,
    locationControlled: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
    internalTracking: nullableString,
});

export const effluentsControlledSchema = baseEsgSchema.extend({
    treatmentOrDest: z.string().min(1),
    treatmentType: nullableString,
    finalDestType: nullableString,
    qtyEffluentM3: z.number(),
    unitEffluent: z.string(),
    qtyOrganic: z.number(),
    unitOrganic: z.string(),
    qtyNitrogen: z.number(),
    unitNitrogen: z.string(),
    organicRemovedSludge: nullableFloat,
    unitSludge: nullableString,
});

export const domesticEffluentsSchema = baseEsgSchema.extend({
    workerType: z.string().min(1),
    numWorkers: z.number().int(),
    avgWorkHours: z.number(),
    septicTankOwner: z.string(), // "Sim", "No" or specific owner
});

// --- 7. DATA TABLES (Land Use & Forestry) ---

export const landUseChangeSchema = baseEsgSchema.extend({
    prevLandUse: z.string().min(1),
    biome: nullableString,
    phytophysiognomy: nullableString,
    areaType: nullableString,
    areaHectares: z.number(),
});

export const plantedForestSchema = baseEsgSchema.extend({
    areaId: nullableString,
    speciesName: nullableString,
    areaPrePreLast: nullableFloat,
    agePrePreLast: nullableInt,
    agePreLast: nullableInt,
    areaHarvestedPreLast: nullableFloat,
    currentArea: nullableFloat,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const conservationAreaSchema = baseEsgSchema.extend({
    description: nullableString,
    biome: nullableString,
    phytophysiognomy: nullableString,
    plantedArea: nullableString,
    plantingStatus: nullableString,
    areaStartYear: nullableFloat,
    areaEndYear: nullableFloat,
    changeReason: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const homeOfficeSchema = baseEsgSchema.extend({
    workRegime: nullableString,
    numEmployees: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- TYPES EXPORT ---
// Example usage: type MobileCombustionInput = z.infer<typeof mobileCombustionSchema>;
</file>

<file path="backend-new/src/schemas/userSchema.ts">
import { z } from 'zod';

// Define the schema strictly
export const createUserSchema = z.object({
    email: z.string().email(),
    password: z.string().min(8, "Password must be at least 8 characters"),
    name: z.string().min(2),
    role: z.enum(['MASTER', 'ADMIN', 'USER']).default('USER'),
    companyId: z.string().uuid().nullable().optional(),
    unitId: z.number().int().nullable().optional(),
    parentId: z.string().nullable().optional(),
});

// Infer the DTO type from the schema (Single Source of Truth)
export type CreateUserDTO = z.infer<typeof createUserSchema>;
</file>

<file path="backend-new/src/services/authService.ts">
import * as userRepository from '../repositories/userRepository';
import { comparePassword } from '../utils/passwordUtils';
import { generateToken } from '../utils/jwtUtils';

export const login = async (email: string, pass: string) => {
    const user = await userRepository.findByEmail(email);
    if (!user || !(await comparePassword(pass, user.password))) throw new Error('Invalid credentials');
    return generateToken({ id: user.id, role: user.role, companyId: user.companyId });
};
</file>

<file path="backend-new/src/services/configService.ts">
import * as configRepo from '../repositories/configRepository';
import { assetTypologySchema, managedOptionSchema } from '../schemas/esgSchemas';

// --- ASSET TYPOLOGIES ---

export const getTypologies = async (unitId?: number, sourceType?: string) => {
    return configRepo.findTypologies({ unitId, sourceType });
};

export const createTypology = async (rawData: unknown) => {
    // Zod handles validation AND the transformation of assetFields object -> JSON string
    const cleanData = assetTypologySchema.parse(rawData);

    // Type casting needed here because Zod output structure matches DB expectation
    // but Typescript might need a nudge to match Prisma generated types exactly
    return configRepo.createTypology(cleanData as any);
};

export const deleteTypology = async (id: number) => {
    return configRepo.deleteTypology(id);
};

// --- MANAGED OPTIONS ---

export const getOptions = async (fieldKey: string) => {
    return configRepo.findOptions(fieldKey);
};

export const createOption = async (rawData: unknown) => {
    const cleanData = managedOptionSchema.parse(rawData);
    return configRepo.createOption(cleanData as any);
};
</file>

<file path="backend-new/src/services/esgGenericService.ts">
import { CrudDelegate } from "../interfaces/crudDelegate";
import { ZodObject } from "zod";
import { AppJwtPayload } from "../types/auth";

export class EsgGenericService<T> {
    constructor(
        private delegate: CrudDelegate<T>,
        private schema: ZodObject<any, any>
    ) {}

    async getByUnitAndYear(unitId: number, year?: number) {
        const where: any = { unitId };
        if (year) where.year = year;
        return this.delegate.findMany({ where, orderBy: { createdAt: 'desc' } });
    }

    async create(data: any) {
        const cleanData = this.schema.parse(data);

        return this.delegate.create({
            data: cleanData
        });
    }

    async update(id: number, data: any) {
        const cleanData = this.schema.partial().parse(data); // Allow partial updates
        return this.delegate.update({
            where: { id },
            data: cleanData
        });
    }

    async delete(id: number) {
        return this.delegate.delete({
            where: { id }
        });
    }
}
</file>

<file path="backend-new/src/services/userService.ts">
import { CreateUserDTO, UserPayload } from "../types/user";
import * as userRepository from "../repositories/userRepository";
import { hashPassword } from "../utils/passwordUtils";

export const registerUser = async (userData: CreateUserDTO, currentUser: UserPayload) => {
    const exists = await userRepository.findByEmail(userData.email);
    if (exists) throw new Error('User already exists');

    const companyId = currentUser.role === 'ADMIN' ? currentUser.companyId : userData.companyId;
    const hashedPassword = await hashPassword(userData.password);

    return userRepository.create({
        ...userData,
        password: hashedPassword,
        companyId,
        parentId: currentUser.id
    });
}
</file>

<file path="backend-new/src/types/auth.ts">
import { JwtPayload } from "jsonwebtoken";

export interface AppJwtPayload extends JwtPayload {
    id: string;
    role: string;
    companyId: string | null;
}
</file>

<file path="backend-new/src/utils/jwtUtils.ts">
import * as jwt from 'jsonwebtoken';
import * as dotenv from 'dotenv';

dotenv.config();

const JWT_SECRET = process.env.JWT_SECRET || 'super-secret';

export const generateToken = (payload: object) => jwt.sign(payload, JWT_SECRET, { expiresIn: '8h' });
</file>

<file path="backend-new/src/utils/modelRegistry.ts">
import prisma from "../repositories/prisma";
import * as schemas from "../schemas/esgSchemas";
import { EsgGenericService } from "../services/esgGenericService";

// Helper type to define the map structure
type RegistryEntry = {
    service: EsgGenericService<any>;
    name: string; // Display name
};

// Singleton map
export const esgRegistry: Record<string, RegistryEntry> = {
    // --- Combustion & Energy ---
    'mobile_combustion': {
        service: new EsgGenericService(prisma.mobileCombustionData, schemas.mobileCombustionSchema),
        name: 'Mobile Combustion'
    },
    'stationary_combustion': {
        service: new EsgGenericService(prisma.stationaryCombustionData, schemas.stationaryCombustionSchema),
        name: 'Stationary Combustion'
    },
    'electricity_purchase': {
        service: new EsgGenericService(prisma.electricityPurchaseData, schemas.electricityPurchaseSchema),
        name: 'Electricity Purchase'
    },
    'energy_generation': {
        service: new EsgGenericService(prisma.energyGenerationData, schemas.energyGenerationSchema),
        name: 'Energy Generation'
    },

    // --- Transport ---
    'upstream_transport': {
        service: new EsgGenericService(prisma.upstreamTransportData, schemas.upstreamTransportSchema),
        name: 'Upstream Transport'
    },
    'downstream_transport': {
        service: new EsgGenericService(prisma.downstreamTransportData, schemas.downstreamTransportSchema),
        name: 'Downstream Transport'
    },
    'waste_transport': {
        service: new EsgGenericService(prisma.wasteTransportData, schemas.wasteTransportSchema),
        name: 'Waste Transport'
    },
    'business_travel_land': {
        service: new EsgGenericService(prisma.businessTravelLandData, schemas.businessTravelLandSchema),
        name: 'Business Travel (Land)'
    },
    'air_travel': {
        service: new EsgGenericService(prisma.airTravelData, schemas.airTravelSchema),
        name: 'Air Travel'
    },
    'employee_commuting': {
        service: new EsgGenericService(prisma.employeeCommutingData, schemas.employeeCommutingSchema),
        name: 'Employee Commuting'
    },

    // --- Production & Materials ---
    'production_sales': {
        service: new EsgGenericService(prisma.productionSalesData, schemas.productionSalesSchema),
        name: 'Production & Sales'
    },
    'purchased_goods': {
        service: new EsgGenericService(prisma.purchasedGoodsServicesData, schemas.purchasedGoodsServicesSchema),
        name: 'Purchased Goods'
    },
    'capital_goods': {
        service: new EsgGenericService(prisma.capitalGoodsData, schemas.capitalGoodsSchema),
        name: 'Capital Goods'
    },

    // --- Emissions & Waste ---
    'lubricants_ippu': {
        service: new EsgGenericService(prisma.lubricantsIppuData, schemas.lubricantsIppuSchema),
        name: 'Lubricants & IPPU'
    },
    'fugitive_emissions': {
        service: new EsgGenericService(prisma.fugitiveEmissionsData, schemas.fugitiveEmissionsSchema),
        name: 'Fugitive Emissions'
    },
    'fertilizers': {
        service: new EsgGenericService(prisma.fertilizersData, schemas.fertilizersSchema),
        name: 'Fertilizers'
    },
    'solid_waste': {
        service: new EsgGenericService(prisma.solidWasteData, schemas.solidWasteSchema),
        name: 'Solid Waste'
    },
    'effluents_controlled': {
        service: new EsgGenericService(prisma.effluentsControlledData, schemas.effluentsControlledSchema),
        name: 'Controlled Effluents'
    },
    'domestic_effluents': {
        service: new EsgGenericService(prisma.domesticEffluentsData, schemas.domesticEffluentsSchema),
        name: 'Domestic Effluents'
    },

    // --- Land & Forest ---
    'land_use_change': {
        service: new EsgGenericService(prisma.landUseChangeData, schemas.landUseChangeSchema),
        name: 'Land Use Change'
    },
    'planted_forest': {
        service: new EsgGenericService(prisma.plantedForestData, schemas.plantedForestSchema),
        name: 'Planted Forest'
    },
    'conservation_area': {
        service: new EsgGenericService(prisma.conservationAreaData, schemas.conservationAreaSchema),
        name: 'Conservation Area'
    },
    'home_office': {
        service: new EsgGenericService(prisma.homeOfficeData, schemas.homeOfficeSchema),
        name: 'Home Office'
    }
};

export const getServiceOrThrow = (sourceType: string) => {
    const entry = esgRegistry[sourceType];
    if (!entry) throw new Error(`Invalid source type: ${sourceType}`);
    return entry.service;
};
</file>

<file path="backend-new/src/utils/passwordUtils.ts">
import * as bcrypt from 'bcrypt';

const SALT_ROUNDS = 10; // Standard balance between security and performance

export const hashPassword = async (password: string): Promise<string> => {
    return bcrypt.hash(password, SALT_ROUNDS);
};

export const comparePassword = async (password: string, hash: string): Promise<boolean> => {
    return bcrypt.compare(password, hash);
};
</file>

<file path="backend-new/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "strict": true,
    "typeRoots": ["./node_modules/@types", "./src/types"]
  },
  "include": ["src/**/*"]
}
</file>

<file path="backend/legacy-code.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
database.js
package.json
server.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="database.js">
// arquivo: backend/database.js

const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const { validationSchemas } = require('../shared/validators.js');

const dbPath = path.resolve(__dirname, 'ecofinance.db');

const db = new sqlite3.Database(dbPath, (err) => {
  if (err) {
    console.error('Erro ao abrir o banco de dados', err.message);
  } else {
    console.log('Conectado ao banco de dados SQLite em:', dbPath);
    
    db.serialize(() => {
        db.run(`CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, email TEXT UNIQUE, password TEXT)`, (err) => { if (err) console.error('Erro tabela users:', err); else console.log('Tabela "users" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS contacts (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, unit_id INTEGER, email TEXT, phone TEXT, FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE SET NULL)`, (err) => { if (err) console.error('Erro tabela contacts:', err); else console.log('Tabela "contacts" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS units (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, cidade TEXT, estado TEXT, pais TEXT, numero_colaboradores INTEGER)`, (err) => { if (err) console.error('Erro tabela units:', err); else console.log('Tabela "units" pronta.'); });
        db.run(`CREATE TABLE IF NOT EXISTS mobile_combustion_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, descricao_fonte TEXT, controlado_empresa BOOLEAN, tipo_entrada TEXT, combustivel TEXT, consumo REAL, unidade_consumo TEXT, distancia_percorrida REAL, unidade_distancia TEXT, tipo_veiculo TEXT)`, (err) => { if (err) console.error('Erro tabela mobile_combustion_data:', err); else console.log('Tabela "mobile_combustion_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS stationary_combustion_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, descricao_da_fonte TEXT, combustivel_estacionario TEXT, consumo REAL, unidade TEXT, controlado_empresa BOOLEAN)`, (err) => { if (err) console.error('Erro tabela stationary_combustion_data:', err); else console.log('Tabela "stationary_combustion_data" pronta.'); });

        db.run(`CREATE TABLE IF NOT EXISTS production_sales_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER NOT NULL, periodo TEXT, unidade_empresarial TEXT NOT NULL, produto TEXT NOT NULL, quantidade_vendida INTEGER CHECK(quantidade_vendida > 0), unidade_medida TEXT NOT NULL, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela production_sales_data:', err); else console.log('Tabela "production_sales_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS lubricants_ippu_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, fonte_emissao TEXT, tipo_lubrificante TEXT, consumo REAL, unidade TEXT, controlado_empresa BOOLEAN)`, (err) => { if (err) console.error('Erro tabela lubricants_ippu_data:', err); else console.log('Tabela "lubricants_ippu_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS fugitive_emissions_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, fonte_emissao TEXT, tipo_gas TEXT, quantidade_reposta REAL, unidade TEXT, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela fugitive_emissions_data:', err); else console.log('Tabela "fugitive_emissions_data" pronta.'); });

        db.run(`CREATE TABLE IF NOT EXISTS fertilizers_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, tipo_fertilizante TEXT, quantidade_kg REAL, unidade TEXT, percentual_nitrogenio REAL, percentual_carbonato REAL, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela fertilizers_data:', err); else console.log('Tabela "fertilizers_data" pronta.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS effluents_controlled_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                tratamento_ou_destino TEXT NOT NULL,
                tipo_tratamento TEXT,
                tipo_destino_final TEXT,
                qtd_efluente_liquido_m3 REAL NOT NULL,
                unidade_efluente_liquido TEXT NOT NULL,
                qtd_componente_organico REAL NOT NULL,
                unidade_componente_organico TEXT NOT NULL,
                qtd_nitrogenio_mg_l REAL NOT NULL,
                unidade_nitrogenio TEXT NOT NULL,
                componente_organico_removido_lodo REAL,
                unidade_comp_organico_removido_lodo TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela effluents_controlled_data:', err); else console.log('Tabela "effluents_controlled_data" pronta.'); });
        
        db.run(`DROP TABLE IF EXISTS domestic_effluents_data`);
        
        db.run(`
            CREATE TABLE IF NOT EXISTS domestic_effluents_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                tipo_trabalhador TEXT NOT NULL,
                num_trabalhadores INTEGER NOT NULL,
                carga_horaria_media REAL NOT NULL,
                fossa_septica_propriedade TEXT NOT NULL,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela domestic_effluents_data:', err); else console.log('Tabela "domestic_effluents_data" recriada com a nova estrutura.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS land_use_change_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                uso_solo_anterior TEXT NOT NULL,
                bioma TEXT,
                fitofisionomia TEXT,
                tipo_area TEXT,
                area_hectare REAL NOT NULL,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela land_use_change_data:', err); else console.log('Tabela "land_use_change_data" pronta.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS solid_waste_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                destinacao_final TEXT,
                tipo_residuo TEXT,
                quantidade_gerado REAL,
                unidade TEXT,
                informar_cidade_uf TEXT,
                local_controlado_empresa TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                rastreabilidade_interna TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela solid_waste_data:', err); else console.log('Tabela "solid_waste_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS electricity_purchase_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                fonte_energia TEXT,
                especificar_fonte TEXT,
                consumo REAL,
                unidade_medida TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                rastreabilidade TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela electricity_purchase_data:', err); else console.log('Tabela "electricity_purchase_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS purchased_goods_services_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_item TEXT,
                tipo_item TEXT,
                quantidade REAL,
                unidade TEXT,
                valor_aquisicao REAL,
                bens_terceiros TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela purchased_goods_services_data:', err); else console.log('Tabela "purchased_goods_services_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS capital_goods_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                bem_capital TEXT,
                quantidade INTEGER,
                unidade TEXT,
                valor_aquisicao REAL,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela capital_goods_data:', err); else console.log('Tabela "capital_goods_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS upstream_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                modal_transporte TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                local_embarque TEXT,
                local_destino TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela upstream_transport_data:', err); else console.log('Tabela "upstream_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS business_travel_land_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_viagem TEXT,
                modal_viagem TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                distancia_percorrida REAL,
                unidade_distancia TEXT,
                km_reembolsado TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela business_travel_land_data:', err); else console.log('Tabela "business_travel_land_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS downstream_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                modal_transporte TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                local_embarque TEXT,
                local_destino TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela downstream_transport_data:', err); else console.log('Tabela "downstream_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS waste_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela waste_transport_data:', err); else console.log('Tabela "waste_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS home_office_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                regime_trabalho TEXT,
                num_funcionarios INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela home_office_data:', err); else console.log('Tabela "home_office_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS air_travel_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_viagem TEXT,
                codigo_aeroporto_partida TEXT,
                codigo_aeroporto_chegada TEXT,
                numero_viagens INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela air_travel_data:', err); else console.log('Tabela "air_travel_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS employee_commuting_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_identificadora TEXT,
                meio_utilizado TEXT,
                tipo_reporte TEXT,
                tipo_combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                distancia_km REAL,
                endereco_funcionario TEXT,
                endereco_trabalho TEXT,
                dias_deslocados INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela employee_commuting_data:', err); else console.log('Tabela "employee_commuting_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS energy_generation_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_fonte TEXT,
                fonte_geracao TEXT,
                total_geracao REAL,
                unidade_medida TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela energy_generation_data:', err); else console.log('Tabela "energy_generation_data" pronta.'); });

        // --- SPRINT 19: TABELA - Floresta Plantada ---
        db.run(`
            CREATE TABLE IF NOT EXISTS planted_forest_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                identificacao_area TEXT,
                nome_especie TEXT,
                area_antepenultimo REAL,
                idade_antepenultimo INTEGER,
                idade_penultimo INTEGER,
                area_colhida_penultimo REAL,
                area_atual REAL,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela planted_forest_data:', err); else console.log('Tabela "planted_forest_data" pronta.'); });

        // --- SPRINT 21: TABELA - rea de Conservao (ATUALIZADA) ---
        db.run(`DROP TABLE IF EXISTS conservation_area_data`, (err) => {
             // Drop para garantir a recriao correta com os novos campos
             if(!err) {
                db.run(`
                    CREATE TABLE IF NOT EXISTS conservation_area_data (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        ano INTEGER,
                        periodo TEXT,
                        unidade_empresarial TEXT,
                        descricao TEXT,
                        bioma TEXT,
                        fitofisionomia TEXT,
                        area_plantada TEXT,
                        plantio TEXT,
                        area_inicio_ano REAL,
                        area_fim_ano REAL,
                        motivo_alteracao TEXT,
                        responsavel TEXT,
                        area_responsavel TEXT,
                        email TEXT,
                        telefone TEXT,
                        comentarios TEXT
                    )
                `, (err) => { if (err) console.error('Erro tabela conservation_area_data:', err); else console.log('Tabela "conservation_area_data" atualizada e pronta.'); });
             }
        });


        db.run(`CREATE TABLE IF NOT EXISTS asset_typologies (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, unit_id INTEGER NOT NULL, source_type TEXT NOT NULL, description TEXT NOT NULL, asset_fields TEXT, is_active BOOLEAN DEFAULT TRUE)`, (err) => { if (err) console.error('Erro tabela asset_typologies:', err); else console.log('Tabela "asset_typologies" pronta.'); });
        
        db.all("PRAGMA table_info(asset_typologies)", (err, columns) => {
            if (err) {
                console.error("Erro ao ler colunas de asset_typologies:", err);
                return;
            }

            const hasResponsibleId = columns.some(col => col.name === 'responsible_contact_id');
            if (!hasResponsibleId) {
                db.run("ALTER TABLE asset_typologies ADD COLUMN responsible_contact_id INTEGER REFERENCES contacts(id) ON DELETE SET NULL", (err) => {
                    if (err) console.error("Erro ao adicionar coluna 'responsible_contact_id':", err);
                    else console.log("Coluna 'responsible_contact_id' adicionada a 'asset_typologies'.");
                });
            }

            const hasFrequency = columns.some(col => col.name === 'reporting_frequency');
            if (!hasFrequency) {
                db.run("ALTER TABLE asset_typologies ADD COLUMN reporting_frequency TEXT DEFAULT 'anual' NOT NULL", (err) => {
                    if (err) console.error("Erro ao adicionar coluna 'reporting_frequency':", err);
                    else console.log("Coluna 'reporting_frequency' adicionada a 'asset_typologies'.");
                });
            }
        });

        db.run(`DROP TABLE IF EXISTS source_configurations`, (err) => { 
            if (err) console.error('Erro ao remover tabela obsoleta source_configurations:', err); 
            else console.log('Tabela obsoleta "source_configurations" verificada/removida.'); 
        });

        db.run(`CREATE TABLE IF NOT EXISTS managed_options (id INTEGER PRIMARY KEY AUTOINCREMENT, field_key TEXT NOT NULL, value TEXT NOT NULL, UNIQUE(field_key, value))`, (err) => { if (err) console.error('Erro tabela managed_options:', err); else console.log('Tabela "managed_options" pronta.'); });
        db.run(`DROP TABLE IF EXISTS custom_options`, (err) => { if (err) console.error('Erro ao remover tabela antiga custom_options:', err); });
        
        db.run(`CREATE TABLE IF NOT EXISTS contact_source_associations (contact_id INTEGER NOT NULL, source_type TEXT NOT NULL, PRIMARY KEY (contact_id, source_type), FOREIGN KEY (contact_id) REFERENCES contacts (id) ON DELETE CASCADE)`, (err) => { if (err) console.error('Erro tabela contact_source_associations:', err); else console.log('Tabela "contact_source_associations" pronta.'); });

        
        console.log('Iniciando o seeding de opes padro...');
        const sql = `INSERT OR IGNORE INTO managed_options (field_key, value) VALUES (?, ?)`;
        let totalOptions = 0;
        
        
        for (const schemaKey in validationSchemas) {
            const schema = validationSchemas[schemaKey];
            const options = schema.validOptions || {};
            
            for (const fieldKey in options) {
                const optionValues = Array.isArray(options[fieldKey]) ? options[fieldKey] : [];
                optionValues.forEach(value => {
                    db.run(sql, [fieldKey, value]);
                    totalOptions++;
                });
            }
        }
        console.log(`Seeding de opes padro concludo. ${totalOptions} opes verificadas.`);
        
    });
  }
});

module.exports = db;
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "csv-parser": "^3.0.0",
    "express": "^4.19.2",
    "multer": "^1.4.5-lts.1",
    "sqlite3": "^5.1.7",
    "xlsx": "^0.18.5"
  }
}
</file>

<file path="server.js">
// arquivo: backend/server.js

// --- 1. IMPORTAES ---
const express = require('express');
const cors = require('cors');
const path = require('path');
const multer = require('multer');
const csv = require('csv-parser');
const xlsx = require('xlsx');
const fs = require('fs');
const bcrypt = require('bcrypt');
const db = require('./database.js'); 
const { validationSchemas } = require('../shared/validators.js');

// --- 2. CONFIGURAES ---
const app = express();
const PORT = process.env.PORT || 8080;
const saltRounds = 10;
const upload = multer({ dest: path.join(__dirname, 'uploads/') });

// --- 3. MIDDLEWARES ---
app.use(cors());
app.use(express.json());
const frontendPath = path.join(__dirname, '..', 'frontend');
app.use(express.static(frontendPath));
const sharedPath = path.join(__dirname, '..', 'shared');
app.use('/shared', express.static(sharedPath));

app.use((req, res, next) => {
    if (req.path.endsWith('.js')) res.contentType('text/javascript');
    next();
});

// --- 4. ROTA PRINCIPAL ---
app.get('/', (req, res) => {
    res.sendFile(path.join(frontendPath, 'login.html'));
});

// --- 5. ROTAS DA API ---

// Rotas de Autenticao
app.post('/api/register', async (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({ message: "Email e senha so obrigatrios." });
    }
    try {
        const hashedPassword = await bcrypt.hash(password, saltRounds);
        const sql = "INSERT INTO users (email, password) VALUES (?, ?)";
        db.run(sql, [email, hashedPassword], function(err) {
            if (err) {
                if (err.message.includes('UNIQUE constraint failed')) {
                    return res.status(409).json({ message: "E-mail j cadastrado." });
                }
                return res.status(500).json({ message: "Erro ao registrar usurio.", error: err.message });
            }
            res.status(201).json({ message: "Usurio registrado com sucesso!", userId: this.lastID });
        });
    } catch (error) {
        res.status(500).json({ message: "Erro interno no servidor.", error: error.message });
    }
});

app.post('/api/login', (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({ message: "Email e senha so obrigatrios." });
    }
    const sql = "SELECT * FROM users WHERE email = ?";
    db.get(sql, [email], (err, user) => {
        if (err) {
            return res.status(500).json({ message: "Erro no servidor.", error: err.message });
        }
        if (!user) {
            return res.status(404).json({ message: "Usurio no encontrado." });
        }
        bcrypt.compare(password, user.password, (err, result) => {
            if (err) {
                return res.status(500).json({ message: "Erro ao verificar senha.", error: err.message });
            }
            if (result) {
                res.status(200).json({ message: "Login bem-sucedido!" });
            } else {
                res.status(401).json({ message: "Senha incorreta." });
            }
        });
    });
});

// Rotas de Contatos (Responsveis)
app.get('/api/contacts', (req, res) => {
    const sqlContacts = `
        SELECT 
            c.id, c.name, c.unit_id, c.email, c.phone,
            u.name as unit_name 
        FROM contacts c
        LEFT JOIN units u ON c.unit_id = u.id
        ORDER BY c.name
    `;
    db.all(sqlContacts, [], (err, contacts) => {
        if (err) return res.status(500).json({ "error": err.message });

        const sqlAssociations = "SELECT * FROM contact_source_associations";
        db.all(sqlAssociations, [], (err, associations) => {
            if (err) return res.status(500).json({ "error": err.message });
            
            const contactsWithSources = contacts.map(contact => {
                const associatedSources = associations
                    .filter(assoc => assoc.contact_id === contact.id)
                    .map(assoc => assoc.source_type);
                return { ...contact, sources: associatedSources };
            });

            res.json(contactsWithSources);
        });
    });
});
app.post('/api/contacts', (req, res) => {
    const { name, unit_id, email, phone, sources = [] } = req.body;
    if (!name) return res.status(400).json({ "error": "O nome  obrigatrio." });

    db.run("INSERT INTO contacts (name, unit_id, email, phone) VALUES (?, ?, ?, ?)", [name, unit_id, email, phone], function(err) {
        if (err) return res.status(500).json({ "error": err.message });
        
        const contactId = this.lastID;
        if (sources.length === 0) {
            return res.status(201).json({ "id": contactId });
        }

        const placeholders = sources.map(() => '(?, ?)').join(',');
        const sql = `INSERT INTO contact_source_associations (contact_id, source_type) VALUES ${placeholders}`;
        
        const params = [];
        sources.forEach(sourceType => {
            params.push(contactId, sourceType);
        });

        db.run(sql, params, function(err) {
            if (err) return res.status(500).json({ "error": `Erro ao salvar associaes: ${err.message}` });
            res.status(201).json({ "id": contactId });
        });
    });
});
app.put('/api/contacts/:id', (req, res) => {
    const contactId = req.params.id;
    const { name, unit_id, email, phone, sources = [] } = req.body;

    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        db.run("UPDATE contacts SET name = ?, unit_id = ?, email = ?, phone = ? WHERE id = ?", [name, unit_id, email, phone, contactId]);
        db.run("DELETE FROM contact_source_associations WHERE contact_id = ?", [contactId]);

        if (sources.length > 0) {
            const placeholders = sources.map(() => '(?, ?)').join(',');
            const sql = `INSERT INTO contact_source_associations (contact_id, source_type) VALUES ${placeholders}`;
            const params = [];
            sources.forEach(sourceType => params.push(contactId, sourceType));
            db.run(sql, params);
        }

        db.run("COMMIT", (err) => {
            if (err) {
                db.run("ROLLBACK");
                return res.status(500).json({ "error": `Erro na transao: ${err.message}` });
            }
            res.status(200).json({ changes: 1 });
        });
    });
});
app.delete('/api/contacts/:id', (req, res) => {
    db.run("DELETE FROM contacts WHERE id = ?", [req.params.id], function(err) {
        if (err) return res.status(500).json({ "error": err.message });
        res.status(200).json({ deleted: this.changes });
    });
});

// --- ROTAS DE UNIDADES ---
app.get('/api/units', (req, res) => {
    db.all("SELECT * FROM units ORDER BY name", [], (err, rows) => {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.json(rows);
    });
});
app.post('/api/units', (req, res) => {
    const { name, cidade, estado, pais, numero_colaboradores } = req.body;
    if (!name || !cidade || !estado || !pais || !numero_colaboradores) { 
        return res.status(400).json({ "error": "Todos os campos so obrigatrios." }); 
    }
    const sql = "INSERT INTO units (name, cidade, estado, pais, numero_colaboradores) VALUES (?, ?, ?, ?, ?)";
    const params = [name, cidade, estado, pais, numero_colaboradores];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(201).json({ "id": this.lastID });
    });
});
app.put('/api/units/:id', (req, res) => {
    const { name, cidade, estado, pais, numero_colaboradores } = req.body;
    if (!name || !cidade || !estado || !pais || !numero_colaboradores) { 
        return res.status(400).json({ "error": "Todos os campos so obrigatrios." }); 
    }
    const sql = "UPDATE units SET name = ?, cidade = ?, estado = ?, pais = ?, numero_colaboradores = ? WHERE id = ?";
    const params = [name, cidade, estado, pais, numero_colaboradores, req.params.id];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ changes: this.changes });
    });
});
app.delete('/api/units/:id', (req, res) => {
    db.run("DELETE FROM units WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

// Rotas de Upload e Template
app.post('/api/upload', upload.single('file'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).send('Nenhum arquivo enviado.');
        }
        const filePath = req.file.path;
        const { source_type } = req.body; 

        const normalizeHeader = (header) => {
            return header.toString()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                .trim()
                .replace(/[\(\)]/g, '')
                .replace(/[^\w\s-]/g, '')
                .replace(/[\s-]+/g, '_');
        };
        
        const processAndSendData = (data) => {
            const processedData = data.map(row => {
                const newRow = {};
                for (const key in row) {
                    let value = row[key];

                    if (source_type === 'combustao_movel' && key === 'tipo_entrada' && typeof value === 'string') {
                         const normalizedInput = value
                            .toLowerCase()
                            .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                            .trim();
                        
                        if (normalizedInput === 'por consumo') {
                            value = 'consumo';
                        } else if (normalizedInput === 'por distancia') {
                            value = 'distancia';
                        }
                    }

                    if (typeof value === 'string') {
                        value = value.trim();
                    }
                    newRow[key] = value;
                }
                return newRow;
            });
            fs.unlinkSync(filePath);
            res.status(200).json(processedData);
        };
        
        const schema = validationSchemas[source_type];
        if (!schema) {
            fs.unlinkSync(filePath);
            return res.status(400).json({ message: 'Tipo de fonte invlido fornecido.' });
        }
        const headerMap = {};
        for(const key in schema.headerDisplayNames) {
            headerMap[normalizeHeader(schema.headerDisplayNames[key])] = key;
        }

        // Adiciona mapeamento para a chave oculta se ela existir no arquivo
        headerMap['id_fonte'] = 'id_fonte';

        if (req.file.originalname.endsWith('.xlsx') || req.file.originalname.endsWith('.xls')) {
            const workbook = xlsx.readFile(filePath);
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            
            const jsonData = xlsx.utils.sheet_to_json(worksheet, { defval: "", raw: true });

            const results = jsonData.map(row => {
                const newRow = {};
                for (const excelHeader in row) {
                    const normalized = normalizeHeader(excelHeader);
                    const schemaKey = headerMap[normalized];
                    if (schemaKey) {
                        newRow[schemaKey] = row[excelHeader] !== null && row[excelHeader] !== undefined ? String(row[excelHeader]) : "";
                    }
                }
                return newRow;
            });
            
            processAndSendData(results);
        } else {
            let results = [];
            fs.createReadStream(filePath)
                .pipe(csv({
                    mapHeaders: ({ header }) => headerMap[normalizeHeader(header)] || normalizeHeader(header)
                }))
                .on('data', (data) => results.push(data))
                .on('end', () => {
                    processAndSendData(results);
                });
        }
    } catch (error) {
        console.error("Erro no upload:", error);
        if (req.file && fs.existsSync(req.file.path)) {
            fs.unlinkSync(req.file.path);
        }
        res.status(500).json({ message: 'Erro interno ao processar o arquivo.' });
    }
});
app.get('/api/template/:tableName', (req, res) => {
    const { tableName } = req.params;
    const { format = 'csv' } = req.query;
    const schema = validationSchemas[tableName];
    if (!schema) { return res.status(404).send('Tipo de tabela no encontrado.'); }
    const headers = Object.values(schema.headerDisplayNames);
    if (format === 'xlsx') {
        const workbook = xlsx.utils.book_new();
        const worksheet = xlsx.utils.aoa_to_sheet([headers]);
        xlsx.utils.book_append_sheet(workbook, worksheet, 'Dados');
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=${tableName}_template.xlsx`);
        res.status(200).send(buffer);
    } else {
        const csvContent = headers.join(',');
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=${tableName}_template.csv`);
        res.status(200).send(csvContent);
    }
});
app.post('/api/export', (req, res) => {
    const { data, tableName } = req.body;
    if (!Array.isArray(data) || data.length === 0) { return res.status(400).send('Nenhum dado fornecido para exportao.'); }
    try {
        const worksheet = xlsx.utils.json_to_sheet(data);
        if (data.length > 0) {
            const headers = Object.keys(data[0]);
            worksheet['!cols'] = headers.map(header => {
                const maxLength = Math.max(...data.map(row => (row[header] || "").toString().length), header.length);
                return { wch: maxLength + 2 };
            });
        }
        const workbook = xlsx.utils.book_new();
        const sheetName = (tableName ? tableName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Dados Exportados').substring(0, 31);
        xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        const fileName = tableName ? `${tableName}_export.xlsx` : 'export.xlsx';
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=${fileName}_export.xlsx`);
        res.status(200).send(buffer);
    } catch (error) {
        console.error("Erro ao exportar para Excel:", error);
        res.status(500).json({ message: "Erro interno ao gerar o arquivo Excel." });
    }
});
app.post('/api/save-data/:tableName', (req, res) => {
    const { tableName } = req.params;
    const dataRows = req.body;
    
    // --- SPRINT 21: Mapeamento de tabelas ---
    const allowedTables = { 
        combustao_movel: 'mobile_combustion_data', 
        combustao_estacionaria: 'stationary_combustion_data', 
        dados_producao_venda: 'production_sales_data', 
        ippu_lubrificantes: 'lubricants_ippu_data', 
        emissoes_fugitivas: 'fugitive_emissions_data', 
        fertilizantes: 'fertilizers_data',
        efluentes_controlados: 'effluents_controlled_data',
        efluentes_domesticos: 'domestic_effluents_data',
        mudanca_uso_solo: 'land_use_change_data',
        solid_waste: 'solid_waste_data',
        electricity_purchase: 'electricity_purchase_data',
        purchased_goods_services: 'purchased_goods_services_data',
        capital_goods: 'capital_goods_data',
        upstream_transport: 'upstream_transport_data',
        business_travel_land: 'business_travel_land_data',
        downstream_transport: 'downstream_transport_data',
        waste_transport: 'waste_transport_data',
        home_office: 'home_office_data',
        air_travel: 'air_travel_data',
        employee_commuting: 'employee_commuting_data',
        energy_generation: 'energy_generation_data',
        planted_forest: 'planted_forest_data',
        conservation_area: 'conservation_area_data'
    };

    if (!allowedTables[tableName]) { return res.status(400).json({ message: "Tipo de tabela invlido." }); }
    if (!dataRows || dataRows.length === 0) { return res.status(400).json({ message: "Nenhum dado para salvar." }); }
    
    const dbTableName = allowedTables[tableName];
    
    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        let errorOccurred = false;
        
        dataRows.forEach(row => {
            if (errorOccurred) return;

            const booleanFields = {
                'controlado_empresa': 'controlado_empresa',
                'fossa_septica_propriedade': 'fossa_septica_propriedade',
                'local_controlado_empresa': 'local_controlado_empresa',
                'informar_cidade_uf': 'informar_cidade_uf',
                'bens_terceiros': 'bens_terceiros',
                'km_reembolsado': 'km_reembolsado',
                'area_plantada': 'area_plantada'
            };
            
            for (const frontEndKey in booleanFields) {
                if (row.hasOwnProperty(frontEndKey)) {
                    let val = row[frontEndKey];
                    if (val && typeof val === 'string') {
                         val = val.trim();
                         if(['sim', 's', 'Sim'].includes(val)) val = 'Sim';
                         else if(['nao', 'n', 'no', 'No'].includes(val)) val = 'No';
                    }
                    row[booleanFields[frontEndKey]] = val;
                }
            }

            const sanitizedRow = {};
            
            // --- SPRINT 21: Auto-preencher Descrio para Conservation Area ---
            if (tableName === 'conservation_area') {
                // Combina Bioma e Fitofisionomia para ter uma descrio til no banco
                row.descricao = `${row.bioma || ''} - ${row.fitofisionomia || ''}`;
            }
            
            // Remove a chave oculta antes de salvar
            delete row.id_fonte;

            for (const key in row) {
                if (row[key] !== '' && row[key] !== null && row[key] !== undefined) {
                    sanitizedRow[key] = row[key];
                }
            }
            
            if (Object.keys(sanitizedRow).length === 0) return;
            
            const columns = Object.keys(sanitizedRow);
            const placeholders = columns.map(() => '?').join(', ');
            const sql = `INSERT INTO ${dbTableName} (${columns.join(', ')}) VALUES (${placeholders})`;
            const values = Object.values(sanitizedRow);

            db.run(sql, values, (err) => {
                if (err) { console.error("Erro ao inserir linha:", err, "SQL:", sql, "Valores:", values); errorOccurred = true; }
            });
        });

        const operation = errorOccurred ? "ROLLBACK" : "COMMIT";
        db.run(operation, (err) => {
            if (err) { return res.status(500).json({ message: `Erro crtico durante a transao (${operation}).` }); }
            if (errorOccurred) { return res.status(500).json({ message: "Erro ao salvar os dados. A transao foi revertida." }); }
            res.status(201).json({ message: `Dados de "${tableName}" salvos com sucesso!` });
        });
    });
});

// --- ROTAS DE CADASTRO DE FONTES ---
app.get('/api/asset-typologies', (req, res) => {
    const { source_type } = req.query;
    let sql = `
        SELECT 
            T.*, 
            U.name as unit_name,
            C.name as responsible_contact_name 
        FROM asset_typologies T 
        JOIN units U ON T.unit_id = U.id
        LEFT JOIN contacts C ON T.responsible_contact_id = C.id
    `;
    const params = [];
    if (source_type) {
        sql += " WHERE T.source_type = ?";
        params.push(source_type);
    }
    sql += " ORDER BY U.name, T.description";
    
    db.all(sql, params, (err, rows) => {
        if (err) {
            res.status(500).json({ "error": err.message });
            return;
        }
        
        const results = rows.map(row => {
            const fields = JSON.parse(row.asset_fields || '{}');
            return { ...row, asset_fields: fields };
        });
        
        res.json(results);
    });
});
app.post('/api/asset-typologies', (req, res) => {
    const { unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency } = req.body;
    if (!unit_id || !source_type || !description || !asset_fields || !reporting_frequency) { return res.status(400).json({ "error": "Campos obrigatrios faltando." }); }
    const assetFieldsStr = JSON.stringify(asset_fields);
    const contactId = responsible_contact_id || null;

    if (unit_id === 'all') {
        db.all("SELECT id FROM units", [], (err, units) => {
            if (err) return res.status(500).json({ "error": `Erro ao buscar unidades: ${err.message}` });
            if (!units || units.length === 0) return res.status(404).json({ "error": "Nenhuma unidade cadastrada para aplicar a regra." });

            const sql = `INSERT INTO asset_typologies (unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency) VALUES (?, ?, ?, ?, ?, ?)`;
            db.serialize(() => {
                db.run("BEGIN TRANSACTION");
                let errorOccurred = false;
                units.forEach(unit => {
                    if (errorOccurred) return;
                    db.run(sql, [unit.id, source_type, description, assetFieldsStr, contactId, reporting_frequency], function(err) {
                        if (err) { console.error("Erro ao inserir tipologia para unidade " + unit.id, err); errorOccurred = true; }
                    });
                });
                const operation = errorOccurred ? "ROLLBACK" : "COMMIT";
                db.run(operation, (err) => {
                    if (err) return res.status(500).json({ message: `Erro crtico durante a transao (${operation}).` });
                    if (errorOccurred) return res.status(500).json({ message: "Erro ao salvar as fontes. A operao foi revertida." });
                    res.status(201).json({ "message": `Fonte '${description}' criada para ${units.length} unidades com sucesso.` });
                });
            });
        });
    } else {
        const sql = `INSERT INTO asset_typologies (unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency) VALUES (?, ?, ?, ?, ?, ?)`;
        db.run(sql, [unit_id, source_type, description, assetFieldsStr, contactId, reporting_frequency], function(err) {
            if (err) { return res.status(500).json({ "error": err.message }); }
            res.status(201).json({ "id": this.lastID });
        });
    }
});
app.put('/api/asset-typologies/:id', (req, res) => {
    const { unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency } = req.body;
    if (!unit_id || !source_type || !description || !asset_fields || !reporting_frequency) { return res.status(400).json({ "error": "Campos obrigatrios faltando." }); }
    const sql = `UPDATE asset_typologies SET unit_id = ?, source_type = ?, description = ?, asset_fields = ?, responsible_contact_id = ?, reporting_frequency = ? WHERE id = ?`;
    const params = [unit_id, source_type, description, JSON.stringify(asset_fields), responsible_contact_id || null, reporting_frequency, req.params.id];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ changes: this.changes });
    });
});

app.delete('/api/asset-typologies/:id', (req, res) => {
    db.run("DELETE FROM asset_typologies WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

app.get('/api/options', (req, res) => {
    const { field_key } = req.query;
    if (!field_key) { return res.status(400).json({ "error": "O parmetro 'field_key'  obrigatrio." }); }
    
    db.all("SELECT * FROM managed_options WHERE field_key = ? ORDER BY value", [field_key], (err, rows) => {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.json(rows);
    });
});
app.post('/api/options', (req, res) => {
    const { field_key, value } = req.body;
    if (!field_key || !value) { return res.status(400).json({ "error": "Campos 'field_key' e 'value' so obrigatrios." }); }
    
    db.run("INSERT INTO managed_options (field_key, value) VALUES (?, ?)", [field_key, value], function(err) {
        if (err) { 
            console.error("Erro ao inserir em managed_options:", err.message);
            res.status(500).json({ "error": err.message }); 
            return;
        }
        res.status(201).json({ "id": this.lastID });
    });
});
app.delete('/api/options/:id', (req, res) => {
    db.run("DELETE FROM managed_options WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

app.get('/api/intelligent-template/:sourceType', (req, res) => {
    const { sourceType } = req.params;
    const { unitId, year, format } = req.query;
    const schema = validationSchemas[sourceType];
    if (!schema) { return res.status(404).send('Tipo de fonte no encontrado.'); }

    // --- ATUALIZADO: Mapeamento de descries ---
    const descriptionKeyMap = { 
        combustao_estacionaria: 'descricao_da_fonte', 
        combustao_movel: 'descricao_fonte', 
        dados_producao_venda: 'produto', 
        ippu_lubrificantes: 'fonte_emissao', 
        emissoes_fugitivas: 'fonte_emissao', 
        fertilizantes: 'tipo_fertilizante',
        efluentes_controlados: 'tratamento_ou_destino',
        mudanca_uso_solo: 'uso_solo_anterior',
        solid_waste: 'destinacao_final',
        electricity_purchase: 'fonte_energia',
        purchased_goods_services: 'descricao_item',
        capital_goods: 'bem_capital',
        upstream_transport: 'insumo_transportado',
        business_travel_land: 'descricao_viagem',
        downstream_transport: 'insumo_transportado',
        waste_transport: 'insumo_transportado',
        home_office: 'regime_trabalho',
        air_travel: 'descricao_viagem',
        employee_commuting: 'descricao_identificadora',
        energy_generation: 'fonte_geracao',
        planted_forest: 'identificacao_area',
        conservation_area: 'bioma',
        // Adicionado Efluentes Domsticos
        efluentes_domesticos: 'tipo_trabalhador'
    };
    
    const getTypologies = new Promise((resolve, reject) => {
        let sql = `
            SELECT 
                T.*, 
                U.name as unit_name
            FROM asset_typologies T 
            JOIN units U ON T.unit_id = U.id
            WHERE T.source_type = ?
        `;
        const params = [sourceType];
        if (unitId && unitId !== 'all') { sql += " AND T.unit_id = ?"; params.push(unitId); }
        db.all(sql, params, (err, rows) => { if (err) return reject(err); resolve(rows); });
    });

    getTypologies.then((typologies) => {
        const dataForExcel = [];
        const headers = schema.headerDisplayNames;
        const headerKeys = Object.keys(headers);
        const reportYear = year || new Date().getFullYear();
        const mainDescriptionKey = descriptionKeyMap[sourceType];

        typologies.forEach(typo => {
            const frequency = typo.reporting_frequency || 'anual';
            const periods = frequency === 'mensal' ? ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"] : ["Anual"];
            const assetFields = JSON.parse(typo.asset_fields || '{}');
            
            periods.forEach(period => {
                const row = {};
                headerKeys.forEach(key => { row[key] = ''; });

                row['ano'] = reportYear;
                row['periodo'] = period;
                row['unidade_empresarial'] = typo.unit_name;
                row['id_fonte'] = typo.id; // --- Chave Primria Oculta ---
                
                if (mainDescriptionKey) {
                    if (['solid_waste', 'electricity_purchase'].includes(sourceType)) {
                        row[mainDescriptionKey] = assetFields[mainDescriptionKey] || '';
                    } else if (sourceType === 'energy_generation') {
                        row[mainDescriptionKey] = assetFields.fonte_geracao || typo.description;
                    } else if (sourceType === 'conservation_area') {
                        row[mainDescriptionKey] = assetFields.bioma || '';
                    } else if (sourceType === 'efluentes_domesticos') {
                        // Garante que o tipo de trabalhador seja o preenchido no cadastro
                        row[mainDescriptionKey] = assetFields.tipo_trabalhador || '';
                    } else {
                        row[mainDescriptionKey] = typo.description;
                    }
                }
                
                // --- INSERO DE DADOS DO CADASTRO NO JSON (Para Front-end) ---
                for (const assetKey in assetFields) { 
                    if (row.hasOwnProperty(assetKey)) { 
                        row[assetKey] = assetFields[assetKey]; 
                    } 
                }
                
                // --- Preenchimentos Especficos ---
                if (sourceType === 'solid_waste' && assetFields.destinacao_final === 'Aterro') {
                    row['informar_cidade_uf'] = assetFields.cidade_uf_destino || '';
                }
                if (sourceType === 'efluentes_controlados') {
                    row['unidade_efluente_liquido'] = frequency === 'mensal' ? 'm3/ms' : 'm3/ano';
                    row['unidade_nitrogenio'] = 'kgN/m3';
                } else if (sourceType === 'emissoes_fugitivas' || sourceType === 'fertilizantes') {
                    row['unidade'] = 'kg';
                } else if (sourceType === 'capital_goods') {
                    row['unidade'] = 'Unidades';
                }
                
                // --- AutoFill (Unidades baseadas em Combustvel) ---
                if (schema.autoFillMap) {
                    for (const triggerKey in schema.autoFillMap) {
                        const rule = schema.autoFillMap[triggerKey];
                        const triggerValue = row[triggerKey];
                        if (triggerValue) {
                            const targetValue = rule.map[triggerValue];
                            if (targetValue !== undefined) {
                                row[rule.targetColumn] = targetValue;
                            }
                        }
                    }
                }
                
                dataForExcel.push(row);
            });
        });

        if (format === 'json') {
            return res.json(dataForExcel);
        }
        
        try {
            // --- LGICA DE EXCLUSO DE COLUNAS DO EXCEL ---
            const excludeColumns = [];
            
            // Regra para Controlado pela Empresa (Agora inclui combustao_movel)
            if (['combustao_estacionaria', 'combustao_movel', 'ippu_lubrificantes', 'emissoes_fugitivas', 'fertilizantes'].includes(sourceType)) {
                excludeColumns.push('controlado_empresa');
            }
            
            // Regra para Unidade
            if (['combustao_estacionaria', 'ippu_lubrificantes'].includes(sourceType)) {
                 excludeColumns.push('unidade'); 
            }
            
            // Regra para Unidade de Consumo (Especfica para Combusto Mvel)
            if (sourceType === 'combustao_movel') {
                excludeColumns.push('unidade_consumo');
            }

            // --- NOVA REGRA: Efluentes Domsticos ---
            if (sourceType === 'efluentes_domesticos') {
                // Remove do Excel para evitar erros de digitao (Case Sensitive)
                excludeColumns.push('fossa_septica_propriedade');
            }

            const dataWithHeaderNames = dataForExcel.map(row => {
                const newRow = {};
                for (const key in row) {
                    if (key === 'id_fonte') continue; // Remove ID oculto do Excel visual
                    if (excludeColumns.includes(key)) continue; // Remove colunas proibidas

                    if (headers[key]) {
                        newRow[headers[key]] = row[key];
                    }
                }
                return newRow;
            });

            // Filtra os cabealhos tambm
            const finalHeaders = Object.keys(headers)
                .filter(key => !excludeColumns.includes(key))
                .map(key => headers[key]);

            const worksheet = xlsx.utils.json_to_sheet(dataWithHeaderNames, { header: finalHeaders });
            worksheet['!cols'] = finalHeaders.map(header => ({ wch: Math.max(header.length, 15) + 2 }));
            const workbook = xlsx.utils.book_new();
            const sheetName = schema.displayName.substring(0, 31);
            xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
            const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
            const fileName = `${sourceType}_template_preenchido_${year}.xlsx`;
            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', `attachment; filename=${fileName}_template.xlsx`);
            res.status(200).send(buffer);
        } catch (error) {
            console.error("Erro ao gerar o template inteligente:", error);
            res.status(500).json({ message: "Erro interno ao gerar o arquivo Excel." });
        }
    }).catch(err => {
        console.error("Erro ao processar dados para o template:", err);
        res.status(500).json({ message: "Erro interno ao processar a gerao do template." });
    });
});

app.listen(PORT, () => {
    console.log(`Servidor iniciado com sucesso na porta ${PORT}`);
});
</file>

</files>
</file>

<file path="frontend/auth.css">
body {
  font-family: sans-serif;
  background-color: #f4f7f6;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
.auth-container {
  background-color: white;
  padding: 40px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  width: 350px;
}
.form-group {
  margin-bottom: 20px;
}
label {
  display: block;
  margin-bottom: 5px;
}
input {
  width: 100%;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
button {
  width: 100%;
  padding: 12px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}
#message {
  margin-top: 20px;
  text-align: center;
}
</file>

<file path="frontend/login.html">
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Login - Ecofinance</title>
  <link rel="stylesheet" href="auth.css">
</head>
<body>
  <div class="auth-container">
    <h2>Login</h2>
    <form id="login-form">
      <div class="form-group">
        <label for="email">Email</label>
        <input type="email" id="email" required>
      </div>
      <div class="form-group">
        <label for="password">Senha</label>
        <input type="password" id="password" required>
      </div>
      <button type="submit">Entrar</button>
    </form>
    <p id="message"></p>
    <p>No tem uma conta? <a href="register.html">Cadastre-se</a></p>
  </div>
  <script src="login.js"></script>
</body>
</html>
</file>

<file path="frontend/register.html">
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Cadastro - Ecofinance</title>
  <link rel="stylesheet" href="auth.css">
</head>
<body>
  <div class="auth-container">
    <h2>Cadastro</h2>
    <form id="register-form">
      <div class="form-group">
        <label for="email">Email</label>
        <input type="email" id="email" required>
      </div>
      <div class="form-group">
        <label for="password">Senha</label>
        <input type="password" id="password" required>
      </div>
      <button type="submit">Cadastrar</button>
    </form>
    <p id="message"></p>
    <p>J tem uma conta? <a href="login.html">Faa Login</a></p>
  </div>
  <script src="register.js"></script>
</body>
</html>
</file>

<file path=".gitignore">
# Dependencies
node_modules/
/backend/node_modules/
/backend-new/node_modules/

# Database file
/backend/ecofinance.db
/backend-new/dev.db

# Misc
.DS_Store
npm-debug.log*
</file>

<file path="backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "csv-parser": "^3.0.0",
    "express": "^4.19.2",
    "multer": "^1.4.5-lts.1",
    "sqlite3": "^5.1.7",
    "xlsx": "^0.18.5"
  }
}
</file>

<file path="frontend/login.js">
// arquivo: frontend/login.js

document.addEventListener('DOMContentLoaded', () => {
  const form = document.getElementById('login-form');
  const messageP = document.getElementById('message');
  
  if (!form) {
    console.error('ERRO CRTICO: No foi possvel encontrar o elemento com id="login-form".');
    return;
  }

  form.addEventListener('submit', async (event) => {
    event.preventDefault();

    const email = document.getElementById('email').value;
    const password = document.getElementById('password').value;

    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });

      const data = await response.json();

      if (response.ok) {
        messageP.textContent = data.message;
        messageP.style.color = 'green';
        setTimeout(() => {
          window.location.href = 'units.html'; 
        }, 1000);
      } else {
        messageP.textContent = data.message;
        messageP.style.color = 'red';
      }
    } catch (error) {
      console.error('Erro no fetch:', error);
      messageP.textContent = 'Erro de conexo com o servidor.';
      messageP.style.color = 'red';
    }
  });
});
</file>

<file path="frontend/main.css">
/* arquivo: frontend/main.css */


body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: #f4f7f6;
    margin: 0;
    padding-top: 70px; 
}


.navbar {
    background-color: #ffffff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 0 2rem;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: fixed; 
    top: 0;
    left: 0;
    width: 100%;
    z-index: 1000;
    box-sizing: border-box;
}

.nav-brand {
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    text-decoration: none;
}

.nav-links {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    gap: 1.5rem;
}

.nav-links a {
    color: #555;
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s ease;
}

.nav-links a:hover {
    color: #007bff;
}

.nav-logout {
    color: #dc3545;
    text-decoration: none;
    font-weight: 500;
}
</file>

<file path="frontend/main.js">
// arquivo: frontend/main.js

document.addEventListener('DOMContentLoaded', () => {
    
    const navPlaceholder = document.getElementById('nav-placeholder');
    
    if (navPlaceholder) {
        
        fetch('nav.html')
            .then(response => response.text())
            .then(data => {
                
                navPlaceholder.innerHTML = data;
            })
            .catch(error => {
                console.error('Erro ao carregar a barra de navegao:', error);
                navPlaceholder.innerHTML = '<p>Erro ao carregar menu.</p>';
            });
    }
});
</file>

<file path="frontend/register.js">
// arquivo: frontend/register.js

const form = document.getElementById('register-form');
const messageP = document.getElementById('message');

form.addEventListener('submit', async (event) => {
  event.preventDefault();

  const email = document.getElementById('email').value;
  const password = document.getElementById('password').value;

  try {
    
    const response = await fetch('/api/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    

    const data = await response.json();

    if (response.ok) {
      messageP.textContent = data.message + " Voc j pode fazer o login.";
      messageP.style.color = 'green';
      form.reset(); 
    } else {
      messageP.textContent = data.message;
      messageP.style.color = 'red';
    }
  } catch (error) {
    messageP.textContent = 'Erro de conexo com o servidor.';
    messageP.style.color = 'red';
  }
});
</file>

<file path="frontend/admin.html">
<!-- arquivo: frontend/admin.html -->
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Administrao - Ecofinance</title>
    
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="dashboard.css">
    
    <style>
        .custom-options-list { list-style: none; padding: 0; }
        .custom-options-list li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; }
        .custom-options-list button { background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
    </style>
</head>
<body>
    
    <div id="nav-placeholder"></div>

    <div class="container">
        <h1>Painel de Administrao</h1>

        
        <div id="admin-content-area">
            <div class="form-container">
                <h2 style="font-size: 1.2rem; margin-bottom: 1rem;">Gerenciar Opes Customizveis</h2>
                <p>Adicione ou remova opes para os campos de seleo que aparecero nos formulrios de cadastro de fontes e importao de dados.</p>
                <div class="form-row">
                    <div class="form-group">
                        <label for="custom-option-field-selector">Selecione o Campo para Customizar</label>
                        <select id="custom-option-field-selector">
                            <option value="">-- Selecione --</option>
                        </select>
                    </div>
                </div>
                
                <div id="custom-option-manager" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="new-custom-option-value">Nova Opo</label>
                            <input type="text" id="new-custom-option-value" placeholder="">
                        </div>
                        <div class="form-group" style="justify-content: flex-end;">
                             <button type="button" id="add-custom-option-btn" class="action-btn edit-btn" style="width: auto; padding: 0.75rem 1.5rem;">Adicionar</button>
                        </div>
                    </div>
                    <div id="custom-option-feedback" class="feedback-area" style="text-align: left; margin-top: 0;"></div>
                    
                    <h3>Opes Atuais:</h3>
                    <ul id="custom-options-list-container" class="custom-options-list"></ul>
                </div>
            </div>
        </div>
        
    </div>

    
    <script type="module" src="admin.js"></script>
</body>
</html>
</file>

<file path="frontend/dashboard.css">
/* arquivo: frontend/dashboard.css */

.container {
    max-width: 900px;
    margin: 2rem auto;
    padding: 2rem;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

h1, h2 {
    color: #333;
    text-align: center;
    margin-bottom: 1.5rem;
}


.form-container {
    background-color: #f9f9f9;
    padding: 2rem;
    border-radius: 8px;
    margin-bottom: 2rem;
    border: 1px solid #eee;
}

.form-row {
    display: flex;
    gap: 1.5rem;
    margin-bottom: 1rem;
}

.form-group {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.form-group label {
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: #555;
}

.form-group input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1rem;
    box-sizing: border-box;
}

.form-actions {
    display: flex;
    justify-content: flex-end;
    gap: 1rem;
    margin-top: 1.5rem;
}

button {
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: bold;
    transition: background-color 0.3s ease;
}

button[type="submit"] {
    background-color: #28a745;
    color: white;
}

button[type="submit"]:hover {
    background-color: #218838;
}

.cancel-btn {
    background-color: #6c757d;
    color: white;
}

.cancel-btn:hover {
    background-color: #5a6268;
}



.table-container {
    overflow-x: auto;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1rem;
}

th, td {
    padding: 1rem;
    border: 1px solid #ddd;
    text-align: left;
}

th {
    background-color: #f8f9fa;
}

tr:nth-child(even) {
    background-color: #f2f2f2;
}

.action-btn {
    padding: 0.5rem 1rem;
    margin-right: 0.5rem;
    font-size: 0.9rem;
    margin-bottom: 0.4rem;
}

.edit-btn {
    background-color: #007bff;
    color: white;
}
.edit-btn:hover {
    background-color: #0069d9;
}

.delete-btn {
    background-color: #dc3545;
    color: white;
}
.delete-btn:hover {
    background-color: #c82333;
}
</file>

<file path="frontend/admin.js">
// arquivo: frontend/admin.js

document.addEventListener('DOMContentLoaded', () => {
    
    
    
    const managedFieldsConfig = {
        // --- Globais ---
        periodo: { displayName: "Perodo de Reporte (Global)", fieldKey: "periodo" },

        // --- Combustveis ---
        combustivel: { displayName: "Combustveis (Mvel & Estacionria)", fieldKey: "combustivel" },

        // --- Combusto Mvel ---
        tipo_veiculo: { displayName: "Tipo de Veculo (Mvel)", fieldKey: "tipo_veiculo" },
        unidade_consumo: { displayName: "Unidade de Consumo (Mvel)", fieldKey: "unidade_consumo" },
        unidade_distancia: { displayName: "Unidade de Distncia (Mvel)", fieldKey: "unidade_distancia" },
        
        // --- IPPU & Outros ---
        tipo_lubrificante: { displayName: "Tipo de Lubrificante (IPPU)", fieldKey: "tipo_lubrificante" },
        
        // --- Emisses Fugitivas ---
        tipo_gas: { displayName: "Tipo de Gs (Fugitivas)", fieldKey: "tipo_gas" },
        
        // --- Unidades Genricas ---
        
        unidade: { displayName: "Unidades de Medida (Padro)", fieldKey: "unidade" }
    };

    
    const navPlaceholder = document.getElementById('nav-placeholder');
    const customOptionFieldSelector = document.getElementById('custom-option-field-selector');
    const customOptionManager = document.getElementById('custom-option-manager');
    const newCustomOptionValueInput = document.getElementById('new-custom-option-value');
    const addCustomOptionBtn = document.getElementById('add-custom-option-btn');
    const customOptionsListContainer = document.getElementById('custom-options-list-container');
    const customOptionFeedback = document.getElementById('custom-option-feedback');
    
    let currentFieldKey = null;

    
    async function handleCustomFieldSelection() { const selectedManagerKey = customOptionFieldSelector.value; if (!selectedManagerKey) { customOptionManager.style.display = 'none'; currentFieldKey = null; return; } currentFieldKey = managedFieldsConfig[selectedManagerKey].fieldKey; await loadCustomOptions(currentFieldKey); customOptionManager.style.display = 'block'; }
    async function loadCustomOptions(fieldKey) { customOptionsListContainer.innerHTML = '<li>Carregando...</li>'; try { const response = await fetch(`/api/options?field_key=${fieldKey}`); if (!response.ok) throw new Error('Falha ao buscar opes.'); const options = await response.json(); customOptionsListContainer.innerHTML = ''; if (options.length === 0) { customOptionsListContainer.innerHTML = '<li>Nenhuma opo cadastrada para este campo.</li>'; } else { options.forEach(opt => { const li = document.createElement('li'); li.textContent = opt.value; const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'X'; deleteBtn.title = 'Deletar esta opo'; deleteBtn.dataset.id = opt.id; deleteBtn.onclick = () => handleDeleteCustomOption(opt.id); li.appendChild(deleteBtn); customOptionsListContainer.appendChild(li); }); } } catch (error) { console.error('Erro ao carregar opes:', error); customOptionsListContainer.innerHTML = '<li>Erro ao carregar opes. Verifique o console.</li>'; } }
    async function handleAddCustomOption() { const value = newCustomOptionValueInput.value.trim(); if (!currentFieldKey || !value) { customOptionFeedback.textContent = 'Por favor, selecione um campo e digite um valor para a nova opo.'; customOptionFeedback.style.color = 'red'; return; } try { const response = await fetch('/api/options', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ field_key: currentFieldKey, value: value }) }); if (!response.ok) { const errorData = await response.json(); if (response.status === 500 && errorData.error.includes('UNIQUE constraint failed')) { throw new Error(`A opo "${value}" j existe para este campo.`); } throw new Error(errorData.message || 'Erro desconhecido do servidor.'); } newCustomOptionValueInput.value = ''; customOptionFeedback.textContent = ''; await loadCustomOptions(currentFieldKey); } catch (error) { console.error('Erro ao adicionar opo:', error); customOptionFeedback.textContent = `Erro: ${error.message}`; customOptionFeedback.style.color = 'red'; } }
    async function handleDeleteCustomOption(optionId) { if (!confirm('Tem certeza que deseja deletar esta opo? Ela ser removida de todos os lugares onde aparece.')) return; try { const response = await fetch(`/api/options/${optionId}`, { method: 'DELETE' }); if (!response.ok) throw new Error('Falha ao deletar opo.'); await loadCustomOptions(currentFieldKey); } catch (error) { console.error('Erro ao deletar opo:', error); alert('Ocorreu um erro ao deletar a opo. Verifique o console.'); } }

    
    function initializePage() {
        if (navPlaceholder) {
            fetch('nav.html')
                .then(response => response.ok ? response.text() : Promise.reject('nav.html no encontrado.'))
                .then(data => { navPlaceholder.innerHTML = data; })
                .catch(error => console.error('Erro ao carregar a barra de navegao:', error));
        }

        
        const selector = customOptionFieldSelector;
        selector.innerHTML = '<option value="">-- Selecione um Campo --</option>';
        
        
        const sortedKeys = Object.keys(managedFieldsConfig).sort((a, b) => 
            managedFieldsConfig[a].displayName.localeCompare(managedFieldsConfig[b].displayName)
        );

        sortedKeys.forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = managedFieldsConfig[key].displayName;
            selector.appendChild(option);
        });

        customOptionFieldSelector.addEventListener('change', handleCustomFieldSelection);
        addCustomOptionBtn.addEventListener('click', handleAddCustomOption);
    }

    
    initializePage();

});
</file>

<file path="frontend/import.css">
/* arquivo: frontend/import.css */

body { 
    font-family: sans-serif; 
    background-color: #f4f7f6; 
    margin: 20px;
    padding-bottom: 20px;
}

.container { 
    max-width: 100%; 
    width: 1200px;   
    margin: auto; 
    background: white; 
    padding: 20px; 
    border-radius: 8px; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
    display: flex;
    flex-direction: column;
}

h1 { 
    text-align: center; 
    color: #333; 
}

.form-group { 
    margin-bottom: 20px; 
}

form { 
    margin-bottom: 20px; 
    padding: 20px; 
    border: 1px solid #ddd; 
    border-radius: 5px; 
    display: flex; 
    align-items: center; 
    gap: 20px; 
    flex-wrap: wrap; 
}

input[type="file"] { 
    border: 1px solid #ccc; 
    padding: 10px; 
    border-radius: 4px; 
}

select { 
    padding: 10px; 
    border: 1px solid #ccc; 
    border-radius: 4px; 
    font-size: 16px; 
}

button { 
    padding: 12px 20px; 
    color: white; 
    border: none; 
    border-radius: 4px; 
    cursor: pointer; 
    font-size: 16px; 
}

#upload-form button { 
    background-color: #007bff; 
}

#save-data-btn { 
    background-color: #007bff; 
}

.add-btn { 
    background-color: #28a745; 
}
.add-btn:hover { 
    background-color: #218838; 
}

.export-btn { 
    background-color: #ff8c00; 
    color: white; 
}
.export-btn:hover { 
    background-color: #cc7000; 
}

.feedback-area { 
    margin: 20px 0; 
    font-weight: bold; 
}

/* --- REA DA TABELA --- */

.table-container { 
    width: 100%;
    
    /* Define altura fixa para garantir que a barra de rolagem horizontal aparea na tela */
    height: calc(100vh - 280px); 
    min-height: 400px; 
    
    overflow: auto; 
    
    border: 1px solid #ddd;
    background-color: #fff;
    position: relative;
    display: block;
}

.table-container::-webkit-scrollbar {
    width: 12px;  
    height: 12px; 
}
.table-container::-webkit-scrollbar-track {
    background: #f1f1f1; 
}
.table-container::-webkit-scrollbar-thumb {
    background: #c1c1c1; 
    border-radius: 6px;
    border: 3px solid #f1f1f1; 
}
.table-container::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8; 
}

table { 
    width: max-content; 
    min-width: 100%; 
    border-collapse: separate; 
    border-spacing: 0;
    table-layout: fixed; 
}

th, td { 
    padding: 10px; 
    border-bottom: 1px solid #ddd; 
    border-right: 1px solid #ddd;
    text-align: left; 
    vertical-align: top;
    
    white-space: normal; 
    word-wrap: break-word;
    
    width: 150px; 
    min-width: 80px; 
    box-sizing: border-box;
    position: relative; 
}

/* CABEALHO FIXO */
thead th { 
    position: sticky; 
    top: 0; 
    background-color: #f8f9fa; 
    z-index: 100; /* Aumentado para garantir visibilidade */
    border-top: 1px solid #ddd;
    border-bottom: 2px solid #ddd;
    color: #333;
    /* Height removido para evitar corte de texto */
}

tr:nth-child(even) { 
    background-color: #f2f2f2; 
}

.invalid-cell { 
    background-color: #f8d7da !important; 
    color: #721c24; 
    outline: 1px solid #f5c6cb; 
}

td select { 
    width: 100%; 
    padding: 8px; 
    border: 1px solid #ccc; 
    border-radius: 4px; 
    background-color: white; 
    font-family: inherit; 
    font-size: inherit; 
}

.invalid-cell select { 
    border-color: #f5c6cb; 
    background-color: #f8d7da; 
}

.delete-row-btn {
    background-color: #dc3545;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
    font-weight: bold;
    line-height: 1;
}

.delete-row-btn:hover { 
    background-color: #c82333; 
}
.delete-row-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.saved-row {
    background-color: #e2e6ea !important;
    color: #6c757d;
}

/* REDIMENSIONAMENTO */
.resizer {
    position: absolute;
    top: 0;
    right: 0;
    width: 5px;
    cursor: col-resize;
    user-select: none;
    height: 100%;
    z-index: 101; 
}

.resizer:hover, .resizing {
    border-right: 2px solid #007bff; 
}
</file>

<file path="frontend/units.js">
// arquivo: frontend/units.js

document.addEventListener('DOMContentLoaded', () => {
    
    const navPlaceholder = document.getElementById('nav-placeholder');
    if (navPlaceholder) {
        fetch('nav.html').then(response => response.text()).then(data => {
            navPlaceholder.innerHTML = data;
        }).catch(error => console.error('Erro ao carregar navbar:', error));
    }

    const form = document.getElementById('unit-form');
    const unitIdInput = document.getElementById('unit-id');
    const unitsTbody = document.getElementById('units-tbody');
    const cancelBtn = document.getElementById('cancel-btn');
    const stateSelect = document.getElementById('estado');

    const API_URL = '/api/units';

    // --- ATENO: Lista de UFs do Brasil ---
    const ufs = [
        "AC", "AL", "AP", "AM", "BA", "CE", "DF", "ES", "GO", "MA", "MT", "MS", 
        "MG", "PA", "PB", "PR", "PE", "PI", "RJ", "RN", "RS", "RO", "RR", "SC", 
        "SP", "SE", "TO"
    ];

    // --- ATENO: Nova funo para popular o dropdown de estados ---
    const populateStatesDropdown = () => {
        ufs.forEach(uf => {
            const option = document.createElement('option');
            option.value = uf;
            option.textContent = uf;
            stateSelect.appendChild(option);
        });
    };

    const fetchUnits = async () => {
        try {
            const response = await fetch(API_URL);
            if (!response.ok) {
                throw new Error(`Erro do servidor: ${response.status}`);
            }
            const units = await response.json();
            
            unitsTbody.innerHTML = '';
            
            if (Array.isArray(units)) {
                units.forEach(unit => {
                    const tr = document.createElement('tr');
                    
                    // Escapa as aspas nos nomes para evitar quebrar o HTML no onclick
                    const escapedName = unit.name ? unit.name.replace(/'/g, "\\'") : '';
                    const escapedCidade = unit.cidade ? unit.cidade.replace(/'/g, "\\'") : '';
                    const escapedPais = unit.pais ? unit.pais.replace(/'/g, "\\'") : '';
                    
                    tr.innerHTML = `
                        <td>${unit.name ?? ''}</td>
                        <td>${unit.cidade ?? ''}</td>
                        <td>${unit.estado ?? ''}</td>
                        <td>${unit.pais ?? ''}</td>
                        <td>${unit.numero_colaboradores ?? ''}</td>
                        <td>
                            <button class="action-btn edit-btn" onclick="editUnit(${unit.id}, '${escapedName}', '${escapedCidade}', '${unit.estado ?? ''}', '${escapedPais}', '${unit.numero_colaboradores ?? ''}')">Editar</button>
                            <button class="action-btn delete-btn" onclick="deleteUnit(${unit.id})">Deletar</button>
                        </td>
                    `;
                    
                    unitsTbody.appendChild(tr);
                });
            } else {
                 console.error("A resposta da API no  um array:", units);
            }
        } catch (err) {
            console.error("Falha ao buscar unidades", err);
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const id = unitIdInput.value;
        
        const unitData = {
            name: document.getElementById('name').value,
            cidade: document.getElementById('cidade').value,
            estado: document.getElementById('estado').value,
            pais: document.getElementById('pais').value,
            numero_colaboradores: document.getElementById('numero-colaboradores').value,
        };
        
        const method = id ? 'PUT' : 'POST';
        const url = id ? `${API_URL}/${id}` : API_URL;

        await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(unitData),
        });

        resetForm();
        fetchUnits();
    });
    
    cancelBtn.addEventListener('click', () => resetForm());
    
    
    window.editUnit = (id, name, cidade, estado, pais, numero_colaboradores) => {
        unitIdInput.value = id;
        document.getElementById('name').value = name;
        document.getElementById('cidade').value = cidade;
        document.getElementById('estado').value = estado;
        document.getElementById('pais').value = pais;
        document.getElementById('numero-colaboradores').value = numero_colaboradores;
        cancelBtn.style.display = 'inline-block';

        // --- ATENO: Rolagem automtica para o topo ---
        window.scrollTo(0, 0);
    };
    

    window.deleteUnit = async (id) => {
        if (confirm('Tem certeza que deseja deletar esta unidade?')) {
            await fetch(`${API_URL}/${id}`, { method: 'DELETE' });
            fetchUnits();
        }
    };

    window.resetForm = () => {
        form.reset();
        unitIdInput.value = '';
        cancelBtn.style.display = 'none';
    };

    populateStatesDropdown();
    fetchUnits();
    
});
</file>

<file path="frontend/dashboard.js">
// arquivo: frontend/dashboard.js


import { validationSchemas } from '../shared/validators.js';

document.addEventListener('DOMContentLoaded', () => {
    
    const navPlaceholder = document.getElementById('nav-placeholder');
    const form = document.getElementById('contact-form');
    const contactIdInput = document.getElementById('contact-id');
    const contactsTbody = document.getElementById('contacts-tbody');
    const cancelBtn = document.getElementById('cancel-btn');
    const sourcesCheckboxContainer = document.getElementById('sources-checkbox-container');
    const phoneInput = document.getElementById('phone');
    const unitSelect = document.getElementById('unit');
    
    const selectAllSourcesCheckbox = document.getElementById('select-all-sources');
    const sourcesFeedback = document.getElementById('sources-feedback');
    
    
    const phoneMask = IMask(phoneInput, {
        mask: [
            { mask: '(00) 0000-0000' },
            { mask: '(00) 00000-0000' }
        ]
    });
    
    

    const fetchAndPopulateUnits = async () => {
        try {
            const response = await fetch('/api/units');
            if (!response.ok) throw new Error('Falha ao buscar unidades');
            const units = await response.json();
            
            unitSelect.innerHTML = '<option value="">-- Selecione uma unidade --</option>'; // Mensagem padro
            units.forEach(unit => {
                const option = document.createElement('option');
                option.value = unit.id;
                option.textContent = unit.name;
                unitSelect.appendChild(option);
            });
        } catch (error) {
            console.error('Erro ao carregar unidades:', error);
            unitSelect.innerHTML = '<option value="">-- Erro ao carregar unidades --</option>';
        }
    };

    const initializePage = () => {
        if (navPlaceholder) {
            fetch('nav.html').then(response => response.text()).then(data => {
                navPlaceholder.innerHTML = data;
            }).catch(error => console.error('Erro ao carregar navbar:', error));
        }

        
        sourcesCheckboxContainer.innerHTML = '';
        const sourceKeys = Object.keys(validationSchemas);
        sourceKeys.forEach(key => {
            const schema = validationSchemas[key];
            const itemDiv = document.createElement('div');
            itemDiv.className = 'checkbox-item';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `source-${key}`;
            checkbox.value = key;
            checkbox.classList.add('source-checkbox'); 
            const label = document.createElement('label');
            label.htmlFor = `source-${key}`;
            label.textContent = schema.displayName;
            itemDiv.appendChild(checkbox);
            itemDiv.appendChild(label);
            sourcesCheckboxContainer.appendChild(itemDiv);
        });
        
        fetchAndPopulateUnits();
        fetchContacts();
    };

    const fetchContacts = async () => {
        try {
            const response = await fetch('/api/contacts');
            const contacts = await response.json();
            contactsTbody.innerHTML = '';
            contacts.forEach(contact => {
                const tr = document.createElement('tr');
                
                const sourceNames = (contact.sources || [])
                    .map(key => validationSchemas[key]?.displayName || key)
                    .join(', ');

                const formattedPhone = contact.phone ? IMask.pipe(contact.phone, phoneMask) : '';

                
                tr.innerHTML = `
                    <td>${contact.name || ''}</td>
                    <td>${contact.unit_name || 'N/A'}</td>
                    <td>${contact.email || ''}</td>
                    <td>${sourceNames}</td>
                    <td>${formattedPhone}</td>
                    <td>
                        <button class="action-btn edit-btn">Editar</button>
                        <button class="action-btn delete-btn">Deletar</button>
                    </td>
                `;

                tr.querySelector('.edit-btn').addEventListener('click', () => editContact(contact));
                tr.querySelector('.delete-btn').addEventListener('click', () => deleteContact(contact.id));
                
                contactsTbody.appendChild(tr);
            });
        } catch(err) {
            console.error("Falha ao buscar contatos", err);
        }
    };

    
    form.addEventListener('submit', async (e) => {
        e.preventDefault();

        
        const emailInput = document.getElementById('email');
        if (!emailInput.value.includes('@')) {
            alert('Por favor, insira um endereo de e-mail vlido.');
            emailInput.focus();
            return;
        }

        const selectedSources = Array.from(sourcesCheckboxContainer.querySelectorAll('input.source-checkbox:checked'))
                                     .map(checkbox => checkbox.value);
        
        
        if (selectedSources.length === 0) {
            sourcesFeedback.style.display = 'block';
            return;
        } else {
            sourcesFeedback.style.display = 'none';
        }
        
        const id = contactIdInput.value;
        const contactData = {
            name: document.getElementById('name').value,
            unit_id: unitSelect.value,
            email: emailInput.value,
            phone: phoneMask.unmaskedValue,
            sources: selectedSources
            
        };

        const method = id ? 'PUT' : 'POST';
        const url = id ? `/api/contacts/${id}` : '/api/contacts';

        try {
            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(contactData),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Falha ao salvar o responsvel.');
            }
            
            
            alert(`Responsvel ${id ? 'atualizado' : 'salvo'} com sucesso!`);

            resetForm();
            fetchContacts();

        } catch (error) {
            console.error('Erro ao salvar:', error);
            alert(`Ocorreu um erro: ${error.message}`);
        }
    });
    
    cancelBtn.addEventListener('click', () => resetForm());

    
    function updateSelectAllCheckbox() {
        const allSourceCheckboxes = document.querySelectorAll('.source-checkbox');
        const checkedSourceCheckboxes = document.querySelectorAll('.source-checkbox:checked');
        selectAllSourcesCheckbox.checked = allSourceCheckboxes.length > 0 && allSourceCheckboxes.length === checkedSourceCheckboxes.length;
    }

    selectAllSourcesCheckbox.addEventListener('change', () => {
        const allSourceCheckboxes = document.querySelectorAll('.source-checkbox');
        allSourceCheckboxes.forEach(checkbox => {
            checkbox.checked = selectAllSourcesCheckbox.checked;
        });
    });

    sourcesCheckboxContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('source-checkbox')) {
            updateSelectAllCheckbox();
        }
    });
    

    

    window.editContact = (contact) => {
        contactIdInput.value = contact.id;
        document.getElementById('name').value = contact.name;
        unitSelect.value = contact.unit_id || '';
        document.getElementById('email').value = contact.email;
        phoneMask.value = contact.phone || '';
        
        
        sourcesCheckboxContainer.querySelectorAll('.source-checkbox').forEach(checkbox => {
            checkbox.checked = contact.sources && contact.sources.includes(checkbox.value);
        });

        updateSelectAllCheckbox(); 
        cancelBtn.style.display = 'inline-block';
        window.scrollTo(0, 0);
    };

    window.deleteContact = async (id) => {
        if (confirm('Tem certeza que deseja deletar este contato?')) {
            await fetch(`/api/contacts/${id}`, {
                method: 'DELETE',
            });
            fetchContacts();
        }
    };

    window.resetForm = () => {
        form.reset();
        contactIdInput.value = '';
        unitSelect.value = '';
        phoneMask.value = '';
        sourcesCheckboxContainer.querySelectorAll('.source-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
        selectAllSourcesCheckbox.checked = false; 
        sourcesFeedback.style.display = 'none'; 
        cancelBtn.style.display = 'none';
    };

    
    initializePage();
});
</file>

<file path="frontend/importer.html">
<!--Arquivo: importer.html-->

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Importar Dados - Ecofinance</title>
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="import.css">
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        <h1>Importar Base de Dados</h1>
        
        <div class="form-group">
            <label for="table-selector">Selecione o tipo de dados para importar:</label>
            <select id="table-selector"></select>
        </div>
        
        <div id="upload-section" style="display: none;">
            
            <div class="template-download-section">
                
                <div class="template-download-group">
                     <button type="button" id="download-intelligent-btn" class="intelligent-btn" style="display: none; background-color: #007BFF; color: white">Baixar Template</button>
                </div>
            </div>
            
            <p id="upload-instructions"></p>
            <form id="upload-form">
                <input type="file" id="file-input" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                <button type="submit">Enviar e Validar</button>
            </form>

        </div>
        
        <div id="table-actions" style="display: none; margin-top: 20px; margin-bottom: 20px; display: flex; gap: 10px;">
            <button type="button" id="export-btn" class="export-btn" style="display: none;">Baixar Dados da Tabela</button>
            <button type="button" id="save-data-btn" style="display: none;">Salvar Dados no Banco</button>
        </div>
        
        <div id="feedback" class="feedback-area"></div>
        <div id="table-container" class="table-container"></div>
    </div>

    <script src="https://unpkg.com/imask"></script>
    <script type="module" src="importer.js"></script>
</body>
</html>
</file>

<file path="frontend/units.html">
<!-- arquivo: frontend/units.html -->

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Cadastro de Unidades - Ecofinance</title>
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="dashboard.css"> 
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        
        <h1>Gesto de Unidades Empresariais</h1>

        <div class="form-container">
            <h2>Adicionar / Editar Unidade</h2>
            <form id="unit-form">
                <input type="hidden" id="unit-id">
                <div class="form-group">
                    <label for="name">Nome da Unidade</label>
                    <input type="text" id="name" placeholder="Ex: Sede SP, Fbrica MG" required>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="cidade">Cidade</label>
                        <input type="text" id="cidade" placeholder="Cidade" required>
                    </div>
                    <div class="form-group">
                        <label for="estado">Estado</label>
                        <!-- --- ATENO: Input trocado por Select --- -->
                        <select id="estado" required>
                            <option value="">-- Selecione o UF --</option>
                        </select>
                    </div>
                </div>
                 <div class="form-row">
                    <div class="form-group">
                        <label for="pais">Pas</label>
                        <input type="text" id="pais" placeholder="Pas" required>
                    </div>
                    <div class="form-group">
                        <label for="numero-colaboradores">N de Colaboradores</label>
                        <input type="number" id="numero-colaboradores" placeholder="Ex: 150" min="0" required>
                    </div>
                </div>
                <button type="submit">Salvar Unidade</button>
                <button type="button" id="cancel-btn" style="display: none;">Cancelar Edio</button>
            </form>
        </div>

        <div class="table-container">
            <h2>Lista de Unidades</h2>
            <table>
                <thead>
                    <tr>
                        <th>Nome da Unidade</th>
                        <th>Cidade</th>
                        <th>Estado</th>
                        <th>Pas</th>
                        <th>N de Colaboradores</th>
                        <th>Aes</th>
                    </tr>
                </thead>
                <tbody id="units-tbody">
                </tbody>
            </table>
        </div>
    </div>
    <script src="units.js"></script> 
</body>
</html>
</file>

<file path="frontend/dashboard.html">
<!-- arquivo: frontend/dashboard.html -->
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Gesto de Responsveis - Ecofinance</title>
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="dashboard.css">
    <style>
        
        .sources-container {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #eee;
        }
        .sources-container h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1rem;
            color: #555;
            font-weight: 500;
        }
        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.75rem;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
        }
        .checkbox-item input {
            margin-right: 0.5rem;
            width: auto; 
        }
        .checkbox-item label {
            margin-bottom: 0; 
            font-weight: normal;
        }
        
        .select-all-container {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #eee;
        }
        
    </style>
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        <h1>Gesto de Responsveis</h1>

        <div class="form-container">
            <h2>Adicionar / Editar Responsvel</h2>
            <form id="contact-form">
                <input type="hidden" id="contact-id">
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="name">Nome</label>
                        <input type="text" id="name" placeholder="Nome do responsvel" required>
                    </div>
                    <div class="form-group">
                        <label for="unit">Unidade Empresarial</label>
                        <select id="unit" required>
                            <option value="">-- Carregando unidades... --</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="email">E-mail</label>
                        <input type="email" id="email" placeholder="E-mail do responsvel" required>
                    </div>
                     <div class="form-group">
                        <label for="phone">Telefone</label>
                        <input type="text" id="phone" placeholder="(00) 00000-0000">
                    </div>
                </div>
                
                <div class="sources-container">
                    
                    <h3>Fontes de Emisso sob sua Responsabilidade</h3>
                    
                    
                    <div class="select-all-container checkbox-item">
                        <input type="checkbox" id="select-all-sources">
                        <label for="select-all-sources">Selecionar Todas as Fontes</label>
                    </div>

                    <div id="sources-checkbox-container" class="checkbox-grid">
                        
                    </div>
                    <small id="sources-feedback" style="color: red; display: none; margin-top: 5px;"> obrigatrio selecionar ao menos uma fonte de emisso.</small>
                </div>
                
                <div class="form-actions">
                    <button type="submit">Salvar Responsvel</button>
                    <button type="button" id="cancel-btn" class="cancel-btn" style="display: none;">Cancelar Edio</button>
                </div>
            </form>
        </div>

        <div class="table-container">
            <h2>Lista de Responsveis</h2>
            <table>
                <thead>
                    <tr>
                        
                        <th>Nome</th>
                        <th>Unidade</th>
                        <th>E-mail</th>
                        <th>Fontes Associadas</th>
                        <th>Telefone</th>
                        <th>Aes</th>
                    </tr>
                </thead>
                <tbody id="contacts-tbody">
                    
                </tbody>
            </table>
        </div>
    </div>

    
    <script src="https://unpkg.com/imask"></script>
    
    <script type="module" src="dashboard.js"></script>
</body>
</html>
</file>

<file path="frontend/nav.html">
<!-- arquivo: frontend/nav.html -->
<nav class="navbar">
    <a href="dashboard.html" class="nav-brand">Ecofinance</a>
    <ul class="nav-links">
        
        <li><a href="units.html">Unidades Empresariais</a></li>
        <li><a href="dashboard.html">Responsveis</a></li>
        <li><a href="assets.html">Cadastro de Fontes</a></li>
        <li><a href="importer.html">Reportar Dados</a></li>
        
    </ul>
    <a href="login.html" class="nav-logout">Sair</a>
</nav>
</file>

<file path="frontend/assets.html">
<!-- arquivo: frontend/assets.html -->
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Cadastro de Fontes - Ecofinance</title>
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="dashboard.css">
    
    <style>
        .custom-options-list { list-style: none; padding: 0; }
        .custom-options-list li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; }
        .custom-options-list button { background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        <h1>Cadastro de Fontes de Emisso</h1> 

        <div class="form-group">
            <label for="source-selector">Selecione uma Fonte de Emisso para gerenciar:</label>
            <select id="source-selector">
                <option value="">-- Selecione --</option>
            </select>
        </div>

        <div id="asset-management-section" style="display: none;">
            
            

            <div class="form-container">
                <h2 id="form-title">Adicionar Nova Fonte</h2>
                <form id="asset-form">
                    <input type="hidden" id="asset-id">
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="asset-description">Descrio da Fonte</label>
                            <input type="text" id="asset-description" placeholder="" required>
                        </div>
                         <div class="form-group">
                            <label for="asset-unit">Unidade Empresarial</label>
                            <select id="asset-unit" required></select>
                        </div>
                    </div>
                    
                    <div id="specific-fields-container">
                        
                    </div>

                    <div class="form-actions">
                        <button type="submit">Salvar Fonte</button>
                        <button type="button" id="cancel-btn" class="cancel-btn" style="display: none;">Cancelar Edio</button>
                    </div>
                </form>
            </div>

            <div class="table-container">
                <h2 id="table-title">Fontes Cadastradas</h2>
                <table>
                    <thead id="assets-thead"></thead>
                    <tbody id="assets-tbody"></tbody>
                </table>
            </div>

        </div>

    </div>

    <script type="module" src="assets.js"></script>
</body>
</html>
</file>

<file path="backend/database.js">
// arquivo: backend/database.js

const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const { validationSchemas } = require('../shared/validators.js');

const dbPath = path.resolve(__dirname, 'ecofinance.db');

const db = new sqlite3.Database(dbPath, (err) => {
  if (err) {
    console.error('Erro ao abrir o banco de dados', err.message);
  } else {
    console.log('Conectado ao banco de dados SQLite em:', dbPath);
    
    db.serialize(() => {
        db.run(`CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, email TEXT UNIQUE, password TEXT)`, (err) => { if (err) console.error('Erro tabela users:', err); else console.log('Tabela "users" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS contacts (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, unit_id INTEGER, email TEXT, phone TEXT, FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE SET NULL)`, (err) => { if (err) console.error('Erro tabela contacts:', err); else console.log('Tabela "contacts" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS units (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, cidade TEXT, estado TEXT, pais TEXT, numero_colaboradores INTEGER)`, (err) => { if (err) console.error('Erro tabela units:', err); else console.log('Tabela "units" pronta.'); });
        db.run(`CREATE TABLE IF NOT EXISTS mobile_combustion_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, descricao_fonte TEXT, controlado_empresa BOOLEAN, tipo_entrada TEXT, combustivel TEXT, consumo REAL, unidade_consumo TEXT, distancia_percorrida REAL, unidade_distancia TEXT, tipo_veiculo TEXT, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela mobile_combustion_data:', err); else console.log('Tabela "mobile_combustion_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS stationary_combustion_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, descricao_da_fonte TEXT, combustivel_estacionario TEXT, consumo REAL, unidade TEXT, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela stationary_combustion_data:', err); else console.log('Tabela "stationary_combustion_data" pronta.'); });

        db.run(`CREATE TABLE IF NOT EXISTS production_sales_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER NOT NULL, periodo TEXT, unidade_empresarial TEXT NOT NULL, produto TEXT NOT NULL, quantidade_vendida INTEGER CHECK(quantidade_vendida > 0), unidade_medida TEXT NOT NULL, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela production_sales_data:', err); else console.log('Tabela "production_sales_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS lubricants_ippu_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, fonte_emissao TEXT, tipo_lubrificante TEXT, consumo REAL, unidade TEXT, controlado_empresa BOOLEAN)`, (err) => { if (err) console.error('Erro tabela lubricants_ippu_data:', err); else console.log('Tabela "lubricants_ippu_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS fugitive_emissions_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, fonte_emissao TEXT, tipo_gas TEXT, quantidade_reposta REAL, unidade TEXT, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela fugitive_emissions_data:', err); else console.log('Tabela "fugitive_emissions_data" pronta.'); });

        db.run(`CREATE TABLE IF NOT EXISTS fertilizers_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, tipo_fertilizante TEXT, quantidade_kg REAL, unidade TEXT, percentual_nitrogenio REAL, percentual_carbonato REAL, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela fertilizers_data:', err); else console.log('Tabela "fertilizers_data" pronta.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS effluents_controlled_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                tratamento_ou_destino TEXT NOT NULL,
                tipo_tratamento TEXT,
                tipo_destino_final TEXT,
                qtd_efluente_liquido_m3 REAL NOT NULL,
                unidade_efluente_liquido TEXT NOT NULL,
                qtd_componente_organico REAL NOT NULL,
                unidade_componente_organico TEXT NOT NULL,
                qtd_nitrogenio_mg_l REAL NOT NULL,
                unidade_nitrogenio TEXT NOT NULL,
                componente_organico_removido_lodo REAL,
                unidade_comp_organico_removido_lodo TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela effluents_controlled_data:', err); else console.log('Tabela "effluents_controlled_data" pronta.'); });
        
        db.run(`DROP TABLE IF EXISTS domestic_effluents_data`);
        
        db.run(`
            CREATE TABLE IF NOT EXISTS domestic_effluents_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                tipo_trabalhador TEXT NOT NULL,
                num_trabalhadores INTEGER NOT NULL,
                carga_horaria_media REAL NOT NULL,
                fossa_septica_propriedade TEXT NOT NULL,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela domestic_effluents_data:', err); else console.log('Tabela "domestic_effluents_data" recriada com a nova estrutura.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS land_use_change_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                uso_solo_anterior TEXT NOT NULL,
                bioma TEXT,
                fitofisionomia TEXT,
                tipo_area TEXT,
                area_hectare REAL NOT NULL,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela land_use_change_data:', err); else console.log('Tabela "land_use_change_data" pronta.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS solid_waste_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                destinacao_final TEXT,
                tipo_residuo TEXT,
                quantidade_gerado REAL,
                unidade TEXT,
                informar_cidade_uf TEXT,
                local_controlado_empresa TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                rastreabilidade_interna TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela solid_waste_data:', err); else console.log('Tabela "solid_waste_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS electricity_purchase_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                fonte_energia TEXT,
                especificar_fonte TEXT,
                consumo REAL,
                unidade_medida TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                rastreabilidade TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela electricity_purchase_data:', err); else console.log('Tabela "electricity_purchase_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS purchased_goods_services_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_item TEXT,
                tipo_item TEXT,
                quantidade REAL,
                unidade TEXT,
                valor_aquisicao REAL,
                bens_terceiros TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela purchased_goods_services_data:', err); else console.log('Tabela "purchased_goods_services_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS capital_goods_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                bem_capital TEXT,
                quantidade INTEGER,
                unidade TEXT,
                valor_aquisicao REAL,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela capital_goods_data:', err); else console.log('Tabela "capital_goods_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS upstream_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                modal_transporte TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                local_embarque TEXT,
                local_destino TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela upstream_transport_data:', err); else console.log('Tabela "upstream_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS business_travel_land_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_viagem TEXT,
                modal_viagem TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                distancia_percorrida REAL,
                unidade_distancia TEXT,
                km_reembolsado TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela business_travel_land_data:', err); else console.log('Tabela "business_travel_land_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS downstream_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                modal_transporte TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                local_embarque TEXT,
                local_destino TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela downstream_transport_data:', err); else console.log('Tabela "downstream_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS waste_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela waste_transport_data:', err); else console.log('Tabela "waste_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS home_office_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                regime_trabalho TEXT,
                num_funcionarios INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela home_office_data:', err); else console.log('Tabela "home_office_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS air_travel_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_viagem TEXT,
                codigo_aeroporto_partida TEXT,
                codigo_aeroporto_chegada TEXT,
                numero_viagens INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela air_travel_data:', err); else console.log('Tabela "air_travel_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS employee_commuting_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_identificadora TEXT,
                meio_utilizado TEXT,
                tipo_reporte TEXT,
                tipo_combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                distancia_km REAL,
                endereco_funcionario TEXT,
                endereco_trabalho TEXT,
                dias_deslocados INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela employee_commuting_data:', err); else console.log('Tabela "employee_commuting_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS energy_generation_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_fonte TEXT,
                fonte_geracao TEXT,
                total_geracao REAL,
                unidade_medida TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela energy_generation_data:', err); else console.log('Tabela "energy_generation_data" pronta.'); });

        // --- SPRINT 19: TABELA - Floresta Plantada ---
        db.run(`
            CREATE TABLE IF NOT EXISTS planted_forest_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                identificacao_area TEXT,
                nome_especie TEXT,
                area_antepenultimo REAL,
                idade_antepenultimo INTEGER,
                idade_penultimo INTEGER,
                area_colhida_penultimo REAL,
                area_atual REAL,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela planted_forest_data:', err); else console.log('Tabela "planted_forest_data" pronta.'); });

        // --- SPRINT 21: TABELA - rea de Conservao (ATUALIZADA) ---
        db.run(`DROP TABLE IF EXISTS conservation_area_data`, (err) => {
             // Drop para garantir a recriao correta com os novos campos
             if(!err) {
                db.run(`
                    CREATE TABLE IF NOT EXISTS conservation_area_data (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        ano INTEGER,
                        periodo TEXT,
                        unidade_empresarial TEXT,
                        descricao TEXT,
                        bioma TEXT,
                        fitofisionomia TEXT,
                        area_plantada TEXT,
                        plantio TEXT,
                        area_inicio_ano REAL,
                        area_fim_ano REAL,
                        motivo_alteracao TEXT,
                        responsavel TEXT,
                        area_responsavel TEXT,
                        email TEXT,
                        telefone TEXT,
                        comentarios TEXT
                    )
                `, (err) => { if (err) console.error('Erro tabela conservation_area_data:', err); else console.log('Tabela "conservation_area_data" atualizada e pronta.'); });
             }
        });


        db.run(`CREATE TABLE IF NOT EXISTS asset_typologies (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, unit_id INTEGER NOT NULL, source_type TEXT NOT NULL, description TEXT NOT NULL, asset_fields TEXT, is_active BOOLEAN DEFAULT TRUE)`, (err) => { if (err) console.error('Erro tabela asset_typologies:', err); else console.log('Tabela "asset_typologies" pronta.'); });
        
        db.all("PRAGMA table_info(asset_typologies)", (err, columns) => {
            if (err) {
                console.error("Erro ao ler colunas de asset_typologies:", err);
                return;
            }

            const hasResponsibleId = columns.some(col => col.name === 'responsible_contact_id');
            if (!hasResponsibleId) {
                db.run("ALTER TABLE asset_typologies ADD COLUMN responsible_contact_id INTEGER REFERENCES contacts(id) ON DELETE SET NULL", (err) => {
                    if (err) console.error("Erro ao adicionar coluna 'responsible_contact_id':", err);
                    else console.log("Coluna 'responsible_contact_id' adicionada a 'asset_typologies'.");
                });
            }

            const hasFrequency = columns.some(col => col.name === 'reporting_frequency');
            if (!hasFrequency) {
                db.run("ALTER TABLE asset_typologies ADD COLUMN reporting_frequency TEXT DEFAULT 'anual' NOT NULL", (err) => {
                    if (err) console.error("Erro ao adicionar coluna 'reporting_frequency':", err);
                    else console.log("Coluna 'reporting_frequency' adicionada a 'asset_typologies'.");
                });
            }
        });

        db.run(`DROP TABLE IF EXISTS source_configurations`, (err) => { 
            if (err) console.error('Erro ao remover tabela obsoleta source_configurations:', err); 
            else console.log('Tabela obsoleta "source_configurations" verificada/removida.'); 
        });

        db.run(`CREATE TABLE IF NOT EXISTS managed_options (id INTEGER PRIMARY KEY AUTOINCREMENT, field_key TEXT NOT NULL, value TEXT NOT NULL, UNIQUE(field_key, value))`, (err) => { if (err) console.error('Erro tabela managed_options:', err); else console.log('Tabela "managed_options" pronta.'); });
        db.run(`DROP TABLE IF EXISTS custom_options`, (err) => { if (err) console.error('Erro ao remover tabela antiga custom_options:', err); });
        
        db.run(`CREATE TABLE IF NOT EXISTS contact_source_associations (contact_id INTEGER NOT NULL, source_type TEXT NOT NULL, PRIMARY KEY (contact_id, source_type), FOREIGN KEY (contact_id) REFERENCES contacts (id) ON DELETE CASCADE)`, (err) => { if (err) console.error('Erro tabela contact_source_associations:', err); else console.log('Tabela "contact_source_associations" pronta.'); });

        
        console.log('Iniciando o seeding de opes padro...');
        const sql = `INSERT OR IGNORE INTO managed_options (field_key, value) VALUES (?, ?)`;
        let totalOptions = 0;
        
        
        for (const schemaKey in validationSchemas) {
            const schema = validationSchemas[schemaKey];
            const options = schema.validOptions || {};
            
            for (const fieldKey in options) {
                const optionValues = Array.isArray(options[fieldKey]) ? options[fieldKey] : [];
                optionValues.forEach(value => {
                    db.run(sql, [fieldKey, value]);
                    totalOptions++;
                });
            }
        }
        console.log(`Seeding de opes padro concludo. ${totalOptions} opes verificadas.`);
        
    });
  }
});

module.exports = db;
</file>

<file path="frontend/importer.js">
// arquivo: frontend/importer.js

import { validationSchemas } from '../shared/validators.js';

document.addEventListener('DOMContentLoaded', () => {
    
    // --- ELEMENTOS DO DOM ---
    const tableSelector = document.getElementById('table-selector');
    const uploadSection = document.getElementById('upload-section');
    const uploadForm = document.getElementById('upload-form');
    const fileInput = document.getElementById('file-input');
    const feedbackDiv = document.getElementById('feedback');
    const tableContainer = document.getElementById('table-container');
    const tableActions = document.getElementById('table-actions');
    const saveButton = document.getElementById('save-data-btn');
    const exportButton = document.getElementById('export-btn');
    const downloadIntelligentBtn = document.getElementById('download-intelligent-btn');
    
    if(downloadIntelligentBtn) downloadIntelligentBtn.textContent = 'Baixar Template';

    const INTEGER_FIELDS = [ 'quantidade_vendida', 'num_trabalhadores', 'numero_viagens', 'num_funcionarios', 'dias_deslocados', 'idade_antepenultimo', 'idade_penultimo' ];
    const DECIMAL_FIELDS = [ 'consumo', 'distancia_percorrida', 'quantidade_reposta', 'quantidade_kg', 'percentual_nitrogenio', 'percentual_carbonato', 'area_hectare', 'qtd_efluente_liquido_m3', 'qtd_componente_organico', 'qtd_nitrogenio_mg_l', 'componente_organico_removido_lodo', 'carga_horaria_media', 'quantidade_gerado', 'quantidade', 'valor_aquisicao', 'distancia_trecho', 'carga_transportada', 'distancia_km', 'total_geracao', 'area_antepenultimo', 'area_colhida_penultimo', 'area_atual', 'area_inicio_ano', 'area_fim_ano' ];

    let currentSchema = null;
    let unitsList = [];
    let managedOptionsCache = {}; 
    let maskInstances = {};
    let maskIdCounter = 0;
    let currentReportYear = null;
    
    // --- VARIVEL: Armazena a "Verdade" do Banco de Dados para cruzamento ---
    let referenceData = []; 

    // --- UTILS ---
    function loadNavbar() {
        const navPlaceholder = document.getElementById('nav-placeholder');
        if (navPlaceholder) { 
            fetch('nav.html')
                .then(response => response.ok ? response.text() : Promise.reject('nav.html no encontrado.'))
                .then(data => { 
                    navPlaceholder.innerHTML = data; 
                    document.title = 'Reporte de Dados - Ecofinance';
                    const h1 = document.querySelector('.container h1');
                    if(h1) h1.textContent = 'Reporte de Dados';
                })
                .catch(error => console.error('Erro ao carregar a barra de navegao:', error));
        }
    }

    async function fetchUnits() {
        try {
            const response = await fetch('/api/units');
            if (!response.ok) throw new Error('Falha ao buscar unidades');
            unitsList = await response.json();
        } catch (error) { console.error('Erro ao buscar unidades:', error); unitsList = []; }
    }
    
    async function fetchManagedOptions(schema) {
        managedOptionsCache = {};
        const optionKeysToFetch = new Set(); 
        if (schema && schema.validOptions) {
            for (const key in schema.validOptions) {
                managedOptionsCache[key] = schema.validOptions[key];
                if (schema.validOptions[key].length > 2) {
                     optionKeysToFetch.add(key);
                }
            }
        }
        if (optionKeysToFetch.size === 0) return;
        try {
            const fetchPromises = Array.from(optionKeysToFetch).map(key =>
                fetch(`/api/options?field_key=${key}`)
                    .then(res => res.ok ? res.json() : Promise.reject(`Falha ao buscar opes para ${key}`))
                    .then(options => ({ key, options: options.map(opt => opt.value) }))
            );
            const results = await Promise.all(fetchPromises);
            results.forEach(({ key, options }) => {
                 if(options.length > 0) {
                    managedOptionsCache[key] = [...new Set([...(managedOptionsCache[key] || []), ...options])];
                 }
            });
        } catch (error) {
            console.error("Erro ao carregar opes gerenciadas:", error);
            feedbackDiv.textContent = 'Erro ao carregar opes de seleo. A pgina pode no funcionar corretamente.';
            feedbackDiv.style.color = 'red';
        }
    }

    function resolveDynamicHeader(displayName, reportYear) {
        if (!reportYear) return displayName;
        const yearInt = parseInt(reportYear);
        if (isNaN(yearInt)) return displayName;

        return displayName
            .replace('{ANO}', yearInt)
            .replace('{ANO-1}', yearInt - 1)
            .replace('{ANO-2}', yearInt - 2);
    }

    // --- LGICA DE RASCUNHO (LOCALSTORAGE) ---
    function getDraftKey() {
        if (!currentSchema || !currentReportYear) return null;
        return `ecofinance_draft_${tableSelector.value}_${currentReportYear}`;
    }

    function saveDraft() {
        const key = getDraftKey();
        if (!key) return;
        
        const headers = Object.keys(currentSchema.headerDisplayNames);
        const activeRowsData = [];
        
        document.querySelectorAll('#table-container tbody tr').forEach(row => {
            activeRowsData.push(getRowDataFromDOM(row, headers));
        });

        if (activeRowsData.length > 0) {
            localStorage.setItem(key, JSON.stringify(activeRowsData));
        } else {
            localStorage.removeItem(key); 
        }
    }

    function checkAndLoadDraft() {
        const key = getDraftKey();
        if (key) return; // (Nota: A lgica anterior tinha 'if (!key) return'. Corrigindo para consistncia, mas aqui o fluxo original estava ok)

        const savedDraft = localStorage.getItem(key);
        if (savedDraft) {
            const draftData = JSON.parse(savedDraft);
            if (draftData.length > 0) {
                if (confirm(`Encontramos um rascunho no salvo com ${draftData.length} linhas para o ano ${currentReportYear}. Deseja restaur-lo?`)) {
                    generateTable(draftData, false); 
                    feedbackDiv.textContent = 'Rascunho restaurado com sucesso. No se esquea de salvar!';
                    feedbackDiv.style.color = 'blue';
                } else {
                    localStorage.removeItem(key); 
                }
            }
        }
    }

    function clearDraft() {
        const key = getDraftKey();
        if (key) localStorage.removeItem(key);
    }

    function createResizableHeaders(table) {
        const cols = table.querySelectorAll('th');
        [].forEach.call(cols, function (col) {
            const resizer = document.createElement('div');
            resizer.classList.add('resizer');
            resizer.style.height = `${table.offsetHeight}px`; 
            col.appendChild(resizer);
            createResizableColumn(col, resizer);
        });
    }

    function createResizableColumn(col, resizer) {
        let x = 0;
        let w = 0;

        const mouseDownHandler = function (e) {
            x = e.clientX;
            const styles = window.getComputedStyle(col);
            w = parseInt(styles.width, 10);

            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
            resizer.classList.add('resizing');
        };

        const mouseMoveHandler = function (e) {
            const dx = e.clientX - x;
            col.style.width = `${w + dx}px`;
        };

        const mouseUpHandler = function () {
            document.removeEventListener('mousemove', mouseMoveHandler);
            document.removeEventListener('mouseup', mouseUpHandler);
            resizer.classList.remove('resizing');
        };

        resizer.addEventListener('mousedown', mouseDownHandler);
    }

    function sanitizeAndPreprocessRow(rowData) {
        const sourceType = tableSelector.value;
        const cleanedRow = { ...rowData }; 

        if (sourceType === 'emissoes_fugitivas') {
            const gasValue = cleanedRow['tipo_gas'];
            if (gasValue) {
                const validGasOptions = managedOptionsCache['tipo_gas'] || [];
                const gasMap = new Map(validGasOptions.map(gas => [gas.toLowerCase(), gas]));
                const normalizedGas = gasMap.get(String(gasValue).toLowerCase());
                if (normalizedGas) {
                    cleanedRow['tipo_gas'] = normalizedGas;
                }
            }
        }

        if (sourceType === 'electricity_purchase') {
            if (cleanedRow.fonte_energia === 'Sistema Interligado Nacional') {
                cleanedRow.especificar_fonte = ''; 
            }
        }

        if (sourceType === 'combustao_movel' && cleanedRow.tipo_entrada) {
            if (cleanedRow.tipo_entrada === 'consumo') {
                ['distancia_percorrida', 'unidade_distancia', 'tipo_veiculo'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_entrada === 'distancia') {
                ['combustivel', 'consumo', 'unidade_consumo'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'efluentes_controlados' && cleanedRow.tratamento_ou_destino) {
            if (cleanedRow.tratamento_ou_destino === 'Tratamento') {
                cleanedRow.tipo_destino_final = '';
            } else if (cleanedRow.tratamento_ou_destino === 'Destino Final') {
                cleanedRow.tipo_tratamento = '';
            }
        } else if (sourceType === 'mudanca_uso_solo' && cleanedRow.uso_solo_anterior) {
            if (cleanedRow.uso_solo_anterior !== 'Vegetao natural') {
                ['bioma', 'fitofisionomia', 'tipo_area'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'purchased_goods_services' && cleanedRow.tipo_item) {
            if (cleanedRow.tipo_item === 'Servio') {
                cleanedRow.quantidade = '';
                cleanedRow.unidade = '';
            }
        } else if (sourceType === 'upstream_transport' && cleanedRow.tipo_reporte) {
            if (cleanedRow.tipo_reporte === 'Consumo') {
                ['classificacao_veiculo', 'distancia_trecho', 'unidade_distancia', 'carga_transportada', 'numero_viagens'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Distncia') {
                ['combustivel', 'consumo', 'unidade_consumo'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'business_travel_land' && cleanedRow.tipo_reporte) {
            if (cleanedRow.tipo_reporte === 'Consumo') {
                ['distancia_percorrida', 'unidade_distancia'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Distncia') {
                ['combustivel', 'consumo', 'unidade_consumo'].forEach(k => cleanedRow[k] = '');
            }
        } else if ((sourceType === 'downstream_transport' || sourceType === 'waste_transport') && cleanedRow.tipo_reporte) {
            if (cleanedRow.tipo_reporte === 'Consumo') {
                ['classificacao_veiculo', 'distancia_trecho', 'unidade_distancia', 'carga_transportada', 'numero_viagens'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Distncia') {
                ['combustivel', 'consumo', 'unidade_consumo'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'employee_commuting' && cleanedRow.tipo_reporte) {
            if (cleanedRow.tipo_reporte === 'Consumo') {
                ['distancia_km', 'endereco_funcionario', 'endereco_trabalho'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Distncia') {
                ['tipo_combustivel', 'consumo', 'unidade_consumo', 'endereco_funcionario', 'endereco_trabalho'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Endereo') {
                ['tipo_combustivel', 'consumo', 'unidade_consumo', 'distancia_km'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'conservation_area') {
            if (cleanedRow.area_plantada === 'No') {
                cleanedRow.plantio = ''; 
            }
        }
        
        return cleanedRow;
    }

    // --- FUNO: Merge com Fonte da Verdade (Cadastro) ---
    function mergeUploadedDataWithReference(uploadedRows) {
        if (!referenceData || referenceData.length === 0) return uploadedRows;
        
        const descriptionKeyMap = { 
            combustao_estacionaria: 'descricao_da_fonte', 
            combustao_movel: 'descricao_fonte', 
            ippu_lubrificantes: 'fonte_emissao', 
            emissoes_fugitivas: 'fonte_emissao', 
            fertilizantes: 'tipo_fertilizante',
            // --- ATUALIZAO: Efluentes Domsticos ---
            efluentes_domesticos: 'tipo_trabalhador'
        };
        const descKey = descriptionKeyMap[tableSelector.value];

        return uploadedRows.map(row => {
            let match = null;
            
            if (row.id_fonte) {
                match = referenceData.find(ref => String(ref.id_fonte) === String(row.id_fonte));
            }

            if (!match && descKey && row.unidade_empresarial && row[descKey]) {
                match = referenceData.find(ref => 
                    ref.unidade_empresarial === row.unidade_empresarial &&
                    ref[descKey] === row[descKey] &&
                    ref.periodo === row.periodo 
                );
            }

            if (match) {
                if (!row.id_fonte) row.id_fonte = match.id_fonte;
                
                // Injees Gerais
                if (match.controlado_empresa) row.controlado_empresa = match.controlado_empresa;
                if (match.unidade) row.unidade = match.unidade;
                
                // Injees Especficas
                if (match.unidade_consumo) row.unidade_consumo = match.unidade_consumo;
                if (match.combustivel_estacionario) row.combustivel_estacionario = match.combustivel_estacionario;
                if (match.tipo_gas) row.tipo_gas = match.tipo_gas;
                if (match.tipo_lubrificante) row.tipo_lubrificante = match.tipo_lubrificante;
                
                // --- ATUALIZAO: Injeta Fossa Sptica ---
                if (match.fossa_septica_propriedade) row.fossa_septica_propriedade = match.fossa_septica_propriedade;
            }
            
            return row;
        });
    }

    function generateTable(data, fromUpload = false) {
        if (!currentSchema) return;
        
        let processedData = data;
        if (fromUpload) {
            processedData = mergeUploadedDataWithReference(data);
        }

        let tbody = tableContainer.querySelector('tbody');
        if (!tbody) {
             if (!fromUpload && processedData.length === 0) {
                tableContainer.innerHTML = `<p style="text-align: center; margin: 2rem 0;">Nenhuma fonte cadastrada para o ano de ${currentReportYear}. Cadastre na aba "Cadastro de Fontes".</p>`;
                return;
            }
            createEmptyTableAndHeaders();
            tbody = tableContainer.querySelector('tbody');
        }

        const headers = Object.keys(currentSchema.headerDisplayNames);

        processedData.forEach((originalRowData, index) => {
            const cleanedData = fromUpload ? sanitizeAndPreprocessRow(originalRowData) : originalRowData;
            const validationResult = currentSchema.validateRow(cleanedData, managedOptionsCache);
            const rowElement = buildTableRow(cleanedData, headers, index);
            tbody.appendChild(rowElement);

            for (const header in validationResult.errors) {
                const cell = rowElement.querySelector(`td[data-header="${header}"]`);
                if (cell) {
                    const el = cell.querySelector('input, select') || cell;
                    el.classList.add('invalid-cell');
                    el.setAttribute('title', validationResult.errors[header]);
                }
            }
            
            updateDisabledFields(rowElement, cleanedData);
        });
        
        const table = tableContainer.querySelector('table');
        if(table) createResizableHeaders(table);

        checkTableAndToggleSaveButton();
    }


    function createEmptyTableAndHeaders() {
        Object.values(maskInstances).forEach(mask => mask.destroy());
        maskInstances = {};
        maskIdCounter = 0;
        tableContainer.innerHTML = '';
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const tbody = document.createElement('tbody');
        const headerRow = document.createElement('tr');
        const headers = Object.keys(currentSchema.headerDisplayNames);
        
        headers.forEach(headerKey => {
            const th = document.createElement('th');
            const rawDisplayName = currentSchema.headerDisplayNames[headerKey] || headerKey;
            th.textContent = resolveDynamicHeader(rawDisplayName, currentReportYear);
            headerRow.appendChild(th);
        });
        
        const actionsTh = document.createElement('th');
        actionsTh.textContent = 'Aes';
        headerRow.appendChild(actionsTh);

        thead.appendChild(headerRow);
        table.appendChild(thead);
        table.appendChild(tbody);
        tableContainer.appendChild(table);
        
        tbody.addEventListener('click', handleTableClick);
        tbody.addEventListener('blur', (e) => handleTableChange(e, headers), true);
        tbody.addEventListener('change', (e) => handleTableChange(e, headers));
    }

    function buildTableRow(rowData, headers, rowIndex) {
        const row = document.createElement('tr');
        
        if (rowData.id_fonte) {
            row.dataset.idFonte = rowData.id_fonte;
        }

        headers.forEach(header => {
            const cell = document.createElement('td');
            cell.dataset.header = header;
            const currentValue = rowData[header] || "";
            const isAutoFilledUnit = currentSchema.autoFillMap && Object.values(currentSchema.autoFillMap).some(rule => rule.targetColumn === header);
            
            let forceDisabled = false;
            // --- LGICA DE BLOQUEIO VISUAL (Fonte da Verdade) ---
            if (header === 'controlado_empresa' && ['combustao_estacionaria', 'combustao_movel', 'ippu_lubrificantes', 'emissoes_fugitivas', 'fertilizantes'].includes(tableSelector.value)) {
                forceDisabled = true;
            }
            if (header === 'unidade' && ['combustao_estacionaria', 'ippu_lubrificantes'].includes(tableSelector.value)) {
                forceDisabled = true;
            }
            if (header === 'unidade_consumo' && tableSelector.value === 'combustao_movel') {
                forceDisabled = true;
            }
            // --- ATUALIZAO: Bloqueio para Efluentes Domsticos ---
            if (header === 'fossa_septica_propriedade' && tableSelector.value === 'efluentes_domesticos') {
                forceDisabled = true;
            }

            let options = managedOptionsCache[header];
            if (currentSchema.dependencyMap && currentSchema.dependencyMap.targetField === header) {
                const triggerHeader = currentSchema.dependencyMap.triggerField;
                const triggerValue = rowData[triggerHeader];
                if (triggerValue && currentSchema.dependencyMap.data[triggerValue]) {
                    options = currentSchema.dependencyMap.data[triggerValue];
                } else {
                    options = []; 
                }
            }

            if (header === 'informar_cidade_uf') {
                cell.textContent = currentValue;
                cell.setAttribute('contenteditable', 'false');
                cell.style.backgroundColor = '#e9ecef';
                cell.style.color = '#495057';
            }
            else if (isAutoFilledUnit || (options && options.length === 1)) {
                cell.textContent = (options && options.length === 1) ? options[0] : currentValue;
                cell.setAttribute('contenteditable', 'false');
                cell.style.backgroundColor = '#e9ecef';
                cell.style.color = '#495057';
            } else if (options) {
                const select = document.createElement('select');
                select.innerHTML = '<option value="">-- Selecione --</option>';
                const displayMap = currentSchema.displayValueMap?.[header];
                options.forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = (displayMap && displayMap[optionValue]) ? displayMap[optionValue] : optionValue;
                    select.appendChild(option);
                });
                cell.appendChild(select);
                select.value = currentValue;
                
                if (forceDisabled) {
                    select.disabled = true;
                    select.style.backgroundColor = '#f0f0f0'; 
                    select.title = "Este dado  definido no Cadastro da Fonte.";
                }

            } else if (DECIMAL_FIELDS.includes(header) || INTEGER_FIELDS.includes(header)) {
                const input = document.createElement('input');
                input.type = 'text';
                let safeValue = currentValue;
                if (typeof safeValue === 'string') {
                    const testValue = safeValue.replace(',', '.').trim();
                    if (testValue === '' || isNaN(parseFloat(testValue))) {
                        safeValue = '';
                    }
                }
                input.value = (safeValue !== '' && safeValue !== null && safeValue !== undefined) ? String(safeValue).replace('.', ',') : '';
                const maskId = `mask-${maskIdCounter++}`;
                input.id = maskId;
                cell.appendChild(input);
                let maskOptions;
                if (INTEGER_FIELDS.includes(header)) {
                    maskOptions = { mask: Number, scale: 0, thousandsSeparator: '.', lazy: false };
                } else { 
                    maskOptions = { mask: Number, scale: 10, thousandsSeparator: '.', radix: ',', mapToRadix: ['.', ','], lazy: false };
                }
                maskInstances[maskId] = IMask(input, maskOptions);
            } else if (header === 'unidade_empresarial' && currentSchema.hasUnits) {
                const select = document.createElement('select');
                select.innerHTML = '<option value="">-- Selecione --</option>';
                unitsList.forEach(unit => { const option = document.createElement('option'); option.value = unit.name; option.textContent = unit.name; select.appendChild(option); });
                cell.appendChild(select);
                select.value = currentValue;
            } else {
                if (forceDisabled) {
                    cell.setAttribute('contenteditable', 'false');
                    cell.textContent = currentValue;
                    cell.style.backgroundColor = '#f0f0f0';
                    cell.title = "Este dado  definido no Cadastro da Fonte.";
                } else {
                    cell.setAttribute('contenteditable', 'true');
                    cell.textContent = currentValue;
                }
            }
            row.appendChild(cell);
        });
        const actionsCell = document.createElement('td');
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'X';
        deleteBtn.className = 'delete-row-btn';
        deleteBtn.title = 'Deletar esta linha';
        actionsCell.appendChild(deleteBtn);
        row.appendChild(actionsCell);
        return row;
    }
    
    function getCellValue(cell) {
        const maskedInput = cell.querySelector('input[id^="mask-"]');
        if (maskedInput && maskInstances[maskedInput.id]) return maskInstances[maskedInput.id].unmaskedValue;
        const input = cell.querySelector('select, input');
        return input ? input.value : cell.textContent;
    }
    
    function getRowDataFromDOM(rowElement, headers) {
        const rowData = {};
        
        if (rowElement.dataset.idFonte) {
            rowData.id_fonte = rowElement.dataset.idFonte;
        }

        headers.forEach((header) => {
            const cell = rowElement.querySelector(`td[data-header="${header}"]`);
            if(cell) rowData[header] = getCellValue(cell);
        });
        return rowData;
    }
    
    function updateDisabledFields(rowElement, sanitizedData) {
        const sourceType = tableSelector.value;
        if (sourceType === 'combustao_movel') {
            const consumoFields = ['combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['distancia_percorrida', 'unidade_distancia', 'tipo_veiculo'];
            if (sanitizedData.tipo_entrada === 'consumo') {
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, consumoFields, false, false);
            } else if (sanitizedData.tipo_entrada === 'distancia') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, false, false);
            } else {
                setFieldsState(rowElement, distanciaFields, true, false);
                setFieldsState(rowElement, consumoFields, true, false);
            }
        } else if (sourceType === 'electricity_purchase') {
            const especificarFonteField = ['especificar_fonte'];
            const isSIN = sanitizedData.fonte_energia === 'Sistema Interligado Nacional';
            setFieldsState(rowElement, especificarFonteField, isSIN, isSIN);
        } else if (sourceType === 'efluentes_controlados') {
            const tratamentoField = ['tipo_tratamento'];
            const destinoFinalField = ['tipo_destino_final'];
            if (sanitizedData.tratamento_ou_destino === 'Tratamento') {
                setFieldsState(rowElement, destinoFinalField, true, true);
                setFieldsState(rowElement, tratamentoField, false, false);
            } else if (sanitizedData.tratamento_ou_destino === 'Destino Final') {
                setFieldsState(rowElement, tratamentoField, true, true);
                setFieldsState(rowElement, destinoFinalField, false, false);
            } else {
                setFieldsState(rowElement, destinoFinalField, true, false);
                setFieldsState(rowElement, tratamentoField, true, false);
            }
        } else if (sourceType === 'mudanca_uso_solo') {
             const vegNaturalFields = ['bioma', 'fitofisionomia', 'tipo_area'];
             if (sanitizedData.uso_solo_anterior !== 'Vegetao natural') {
                setFieldsState(rowElement, vegNaturalFields, true, true);
             } else {
                setFieldsState(rowElement, vegNaturalFields, false, false);
             }
        } else if (sourceType === 'purchased_goods_services') {
            const qtdUnidFields = ['quantidade', 'unidade'];
            if (sanitizedData.tipo_item === 'Servio') {
                setFieldsState(rowElement, qtdUnidFields, true, true);
            } else {
                setFieldsState(rowElement, qtdUnidFields, false, false);
            }
        } else if (sourceType === 'upstream_transport') {
            const consumoFields = ['combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['classificacao_veiculo', 'distancia_trecho', 'unidade_distancia', 'carga_transportada', 'numero_viagens'];
            
            if (sanitizedData.tipo_reporte === 'Consumo') {
                setFieldsState(rowElement, distanciaFields, true, true); 
                setFieldsState(rowElement, consumoFields, false, false); 
            } else if (sanitizedData.tipo_reporte === 'Distncia') {
                setFieldsState(rowElement, consumoFields, true, true); 
                setFieldsState(rowElement, distanciaFields, false, false); 
            } else {
                setFieldsState(rowElement, consumoFields, true, false);
                setFieldsState(rowElement, distanciaFields, true, false);
            }
        } else if (sourceType === 'business_travel_land') {
            const consumoFields = ['combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['distancia_percorrida', 'unidade_distancia'];
            if (sanitizedData.tipo_reporte === 'Consumo') {
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, consumoFields, false, false);
            } else if (sanitizedData.tipo_reporte === 'Distncia') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, false, false);
            } else {
                setFieldsState(rowElement, consumoFields, true, false);
                setFieldsState(rowElement, distanciaFields, true, false);
            }
        } else if (sourceType === 'downstream_transport' || sourceType === 'waste_transport') {
            const consumoFields = ['combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['classificacao_veiculo', 'distancia_trecho', 'unidade_distancia', 'carga_transportada', 'numero_viagens'];
            if (sanitizedData.tipo_reporte === 'Consumo') {
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, consumoFields, false, false);
            } else if (sanitizedData.tipo_reporte === 'Distncia') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, false, false);
            } else {
                setFieldsState(rowElement, consumoFields, true, false);
                setFieldsState(rowElement, distanciaFields, true, false);
            }
        } else if (sourceType === 'employee_commuting') {
            const consumoFields = ['tipo_combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['distancia_km'];
            const enderecoFields = ['endereco_funcionario', 'endereco_trabalho'];

            if (sanitizedData.tipo_reporte === 'Consumo') {
                setFieldsState(rowElement, consumoFields, false, false);
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, enderecoFields, true, true);
            } else if (sanitizedData.tipo_reporte === 'Distncia') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, false, false);
                setFieldsState(rowElement, enderecoFields, true, true);
            } else if (sanitizedData.tipo_reporte === 'Endereo') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, enderecoFields, false, false);
            } else {
                setFieldsState(rowElement, consumoFields, true, false);
                setFieldsState(rowElement, distanciaFields, true, false);
                setFieldsState(rowElement, enderecoFields, true, false);
            }
        } else if (sourceType === 'conservation_area') {
            const plantioField = ['plantio'];
            if (sanitizedData.area_plantada === 'Sim') {
                setFieldsState(rowElement, plantioField, false, false);
            } else {
                setFieldsState(rowElement, plantioField, true, true);
            }
        }
    }

    function updateValidationAppearance(rowElement) {
        const headers = Object.keys(currentSchema.headerDisplayNames);
        const rowData = getRowDataFromDOM(rowElement, headers);
        const validationResult = currentSchema.validateRow(rowData, managedOptionsCache);
        
        headers.forEach(header => {
            const cell = rowElement.querySelector(`td[data-header="${header}"]`);
            if (!cell) return;
            const el = cell.querySelector('input, select') || cell;
            el.classList.remove('invalid-cell');
            el.removeAttribute('title');
            if (validationResult.errors[header]) {
                el.classList.add('invalid-cell');
                el.setAttribute('title', validationResult.errors[header]);
            }
        });
    }

    function checkTableAndToggleSaveButton() {
        const hasAnyErrors = tableContainer.querySelector('.invalid-cell');
        const activeRows = Array.from(tableContainer.querySelectorAll('tbody tr')).filter(row => {
            const allInputs = Array.from(row.querySelectorAll('input, select'));
            const allDisabled = allInputs.length > 0 && allInputs.every(el => el.disabled);
            return !allDisabled && !row.classList.contains('saved-row');
        });
        
        const hasActiveRows = activeRows.length > 0;
        const areDataValid = !hasAnyErrors && hasActiveRows;

        saveButton.style.display = areDataValid ? 'inline-block' : 'none';
        
        const hasAnyRows = tableContainer.querySelector('tbody tr');
        exportButton.style.display = hasAnyRows ? 'inline-block' : 'none';

        if (hasAnyErrors && hasActiveRows) {
            feedbackDiv.textContent = "Dados invlidos. Corrija as clulas em vermelho.";
            feedbackDiv.style.color = 'red';
        } else if (areDataValid) {
            feedbackDiv.textContent = 'Todos os dados so vlidos! Voc pode salvar.';
            feedbackDiv.style.color = 'green';
        } else if (!hasActiveRows && hasAnyRows) {
            feedbackDiv.textContent = "Todos os dados exibidos j foram salvos ou esto travados.";
            feedbackDiv.style.color = 'green';
        } else {
            feedbackDiv.textContent = "";
        }
    }
    
    function handleTableClick(event) {
        if (event.target.classList.contains('delete-row-btn')) {
            const rowToDelete = event.target.closest('tr');
            if (confirm('Tem certeza que deseja remover esta linha da visualizao?')) {
                rowToDelete.querySelectorAll('input[id^="mask-"]').forEach(input => {
                    if (maskInstances[input.id]) {
                        maskInstances[input.id].destroy();
                        delete maskInstances[input.id];
                    }
                });
                rowToDelete.remove();
                checkTableAndToggleSaveButton();
                saveDraft(); 
            }
        }
    }

    const setFieldsState = (row, fields, disable, clear) => {
        fields.forEach(fieldName => {
            const cell = row.querySelector(`td[data-header="${fieldName}"]`);
            if (cell) {
                const input = cell.querySelector('select, input');
                if (disable) {
                    if (clear) {
                        if (input) {
                            if (input.id && maskInstances[input.id]) {
                                maskInstances[input.id].unmaskedValue = '';
                            } else {
                                input.value = '';
                            }
                        } else {
                            cell.textContent = '';
                        }
                    }
                    cell.style.backgroundColor = '#e9ecef';
                    if (input) input.disabled = true;
                } else {
                    const isAutoFilledUnit = currentSchema.autoFillMap && Object.values(currentSchema.autoFillMap).some(rule => rule.targetColumn === fieldName);
                    
                    const isSystemLocked = (fieldName === 'controlado_empresa' && ['combustao_estacionaria', 'combustao_movel', 'ippu_lubrificantes', 'emissoes_fugitivas', 'fertilizantes'].includes(tableSelector.value)) 
                                        || (fieldName === 'unidade' && ['combustao_estacionaria', 'ippu_lubrificantes'].includes(tableSelector.value))
                                        || (fieldName === 'unidade_consumo' && tableSelector.value === 'combustao_movel')
                                        || (fieldName === 'fossa_septica_propriedade' && tableSelector.value === 'efluentes_domesticos');

                    if(!isAutoFilledUnit && !isSystemLocked) {
                        cell.style.backgroundColor = '';
                        const rowIsLocked = row.querySelector('.delete-row-btn').disabled === true;
                        if (input && !rowIsLocked) input.disabled = false;
                    }
                }
            }
        });
    };

    function handleTableChange(event, headers) {
        const element = event.target;
        const cell = element.closest('td');
        if (!cell) return;
        
        const editedRow = cell.parentElement;
        let rowData = getRowDataFromDOM(editedRow, headers);

        const headerOfEditedCell = cell.dataset.header;
        
        // 1. AutoFill Logic
        if (currentSchema.autoFillMap && currentSchema.autoFillMap[headerOfEditedCell]) {
            const rule = currentSchema.autoFillMap[headerOfEditedCell];
            const triggerValue = getCellValue(cell);
            const targetHeader = rule.targetColumn;
            const targetCell = editedRow.querySelector(`td[data-header="${targetHeader}"]`);
            if (targetCell) {
                targetCell.textContent = triggerValue ? (rule.map[triggerValue] || '') : '';
            }
            rowData = getRowDataFromDOM(editedRow, headers);
        }

        // 2. Dependency Logic
        if (currentSchema.dependencyMap && currentSchema.dependencyMap.triggerField === headerOfEditedCell) {
            const triggerValue = getCellValue(cell);
            const targetHeader = currentSchema.dependencyMap.targetField;
            const targetCell = editedRow.querySelector(`td[data-header="${targetHeader}"]`);
            
            if (targetCell) {
                const targetSelect = targetCell.querySelector('select');
                if (targetSelect) {
                    targetSelect.innerHTML = '<option value="">-- Selecione --</option>';
                    
                    if (triggerValue && currentSchema.dependencyMap.data[triggerValue]) {
                        const newOptions = currentSchema.dependencyMap.data[triggerValue];
                        newOptions.forEach(opt => {
                            const option = document.createElement('option');
                            option.value = opt;
                            option.textContent = opt;
                            targetSelect.appendChild(option);
                        });
                    }
                    targetSelect.value = "";
                }
            }
            rowData = getRowDataFromDOM(editedRow, headers);
        }
        
        updateDisabledFields(editedRow, rowData);
        updateValidationAppearance(editedRow);
        checkTableAndToggleSaveButton();
        
        saveDraft();
    }

    tableSelector.addEventListener('change', async () => {
        const selectedKey = tableSelector.value;
        currentSchema = validationSchemas[selectedKey];
        
        uploadForm.reset(); 
        tableContainer.innerHTML = '';
        tableActions.style.display = 'none'; 
        feedbackDiv.textContent = '';
        saveButton.style.display = 'none';
        exportButton.style.display = 'none';
        currentReportYear = null;
        referenceData = []; 

        if (currentSchema) {
            const year = prompt("Por favor, digite o ano de reporte (ex: 2024):", new Date().getFullYear());
            if (!year || isNaN(parseInt(year)) || year.length !== 4) {
                alert("Ano invlido. Por favor, selecione a fonte novamente e digite um ano com 4 dgitos.");
                tableSelector.value = ""; 
                uploadSection.style.display = 'none';
                return;
            }
            currentReportYear = year; 

            uploadSection.style.display = 'block';
            tableActions.style.display = 'flex';
            downloadIntelligentBtn.style.display = 'inline-block';
            feedbackDiv.textContent = 'Carregando...';
            feedbackDiv.style.color = 'blue';

            try {
                await Promise.all([
                    currentSchema.hasUnits ? fetchUnits() : Promise.resolve(),
                    fetchManagedOptions(currentSchema) 
                ]);
                feedbackDiv.textContent = `Carregando fontes cadastradas para o ano de ${currentReportYear}...`;
                
                const response = await fetch(`/api/intelligent-template/${selectedKey}?format=json&year=${currentReportYear}`);
                if (!response.ok) throw new Error('Falha ao carregar template de dados.');
                
                const data = await response.json();
                referenceData = data; 

                feedbackDiv.textContent = '';
                generateTable(data, false);
                
                checkAndLoadDraft();
                
                setTimeout(() => {
                    uploadSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);

            } catch (error) {
                console.error("Erro ao carregar dados da fonte:", error);
                feedbackDiv.textContent = `Erro: ${error.message}`;
                feedbackDiv.style.color = 'red';
            }
        } else {
            uploadSection.style.display = 'none';
        }
    });
    
    uploadForm.addEventListener('submit', async (e) => { 
        e.preventDefault(); 
        feedbackDiv.textContent = 'Enviando e validando arquivo...'; 
        const file = fileInput.files[0]; 
        if (!file) { feedbackDiv.textContent = 'Por favor, selecione um arquivo.'; return; } 
        const formData = new FormData(); 
        formData.append('file', file); 
        formData.append('source_type', tableSelector.value); 
        try { 
            const response = await fetch('/api/upload', { method: 'POST', body: formData }); 
            if (!response.ok) throw new Error(`Erro: ${response.statusText}`); 
            const data = await response.json(); 
            generateTable(data, true); 
            saveDraft();
        } catch (error) { 
            feedbackDiv.textContent = `Falha no upload: ${error.message}`; 
            feedbackDiv.style.color = 'red'; 
        } 
    });
    
    exportButton.addEventListener('click', async () => {
        if (!currentSchema || !tableSelector.value) return;
        
        const headers = Object.keys(currentSchema.headerDisplayNames);
        const dataToExport = [];
        
        document.querySelectorAll('#table-container tbody tr').forEach(row => {
            dataToExport.push(getRowDataFromDOM(row, headers));
        });

        if (dataToExport.length === 0) {
            alert("No h dados na tabela para exportar.");
            return;
        }

        const friendlyData = dataToExport.map(row => {
            const newRow = {};
            delete row.id_fonte; 
            for (const key in row) {
                let displayName = currentSchema.headerDisplayNames[key] || key;
                displayName = resolveDynamicHeader(displayName, currentReportYear);
                newRow[displayName] = row[key];
            }
            return newRow;
        });

        try {
            const response = await fetch('/api/export', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: friendlyData, tableName: tableSelector.value })
            });
            
            if (!response.ok) throw new Error("Erro ao gerar arquivo de exportao.");
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `${tableSelector.value}_dados_${currentReportYear}.xlsx`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            feedbackDiv.textContent = 'Dados exportados com sucesso!';
            feedbackDiv.style.color = 'green';
        } catch (error) {
            console.error("Erro na exportao:", error);
            feedbackDiv.textContent = 'Erro ao exportar dados.';
            feedbackDiv.style.color = 'red';
        }
    });

    downloadIntelligentBtn.addEventListener('click', async () => { 
        const sourceType = tableSelector.value; 
        if (!sourceType || !currentReportYear) {
            alert("Por favor, selecione uma fonte e um ano primeiro.");
            return;
        }

        feedbackDiv.textContent = 'Gerando template...'; 
        feedbackDiv.style.color = 'blue'; 
        try { 
            const response = await fetch(`/api/intelligent-template/${sourceType}?year=${currentReportYear}`); 
            if (!response.ok) { 
                const error = await response.json(); 
                throw new Error(error.message || 'Falha ao gerar o arquivo no servidor.'); 
            } 
            const blob = await response.blob(); 
            const url = window.URL.createObjectURL(blob); 
            const a = document.createElement('a'); 
            a.style.display = 'none'; 
            a.href = url; 
            const disposition = response.headers.get('Content-Disposition'); 
            let filename = `${sourceType}_template.xlsx`; 
            if (disposition && disposition.indexOf('attachment') !== -1) { 
                const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                const matches = filenameRegex.exec(disposition); 
                if (matches != null && matches[1]) { 
                    filename = matches[1].replace(/['"]/g, ''); 
                } 
            } 
            a.download = filename; 
            document.body.appendChild(a); 
            a.click(); 
            window.URL.revokeObjectURL(url); 
            a.remove(); 
            feedbackDiv.textContent = 'Template gerado com sucesso!'; 
            feedbackDiv.style.color = 'green'; 
        } catch (error) { 
            feedbackDiv.textContent = `Erro ao gerar template: ${error.message}`; 
            feedbackDiv.style.color = 'red'; 
        } 
    });

    function lockSavedRows() {
        const tbody = tableContainer.querySelector('tbody');
        if (!tbody) return;
        
        tbody.querySelectorAll('tr').forEach(row => {
            if (!row.classList.contains('saved-row')) {
                row.classList.add('saved-row');
                row.style.backgroundColor = '#d4edda'; 
                
                row.querySelectorAll('input, select').forEach(el => {
                    el.disabled = true;
                });
                
                const deleteBtn = row.querySelector('.delete-row-btn');
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.style.opacity = '0.5';
                    deleteBtn.title = 'Item j salvo no banco de dados.';
                }
            }
        });
    }

    saveButton.addEventListener('click', async () => { 
        if (!currentSchema || !tableSelector.value) return; 
        
        const headers = Object.keys(currentSchema.headerDisplayNames); 
        const dataToSave = []; 
        
        document.querySelectorAll('#table-container tbody tr').forEach(row => { 
            if (!row.classList.contains('saved-row')) {
                dataToSave.push(getRowDataFromDOM(row, headers)); 
            }
        }); 
        
        if (dataToSave.length === 0) {
            feedbackDiv.textContent = "No h novos dados para salvar.";
            return;
        }

        try { 
            const response = await fetch(`/api/save-data/${tableSelector.value}`, { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify(dataToSave), 
            }); 
            const result = await response.json(); 
            if (!response.ok) throw new Error(result.message); 
            
            const friendlyTableName = currentSchema.displayName; 
            feedbackDiv.textContent = `Dados de "${friendlyTableName}" salvos com sucesso!`; 
            feedbackDiv.style.color = 'green'; 
            
            lockSavedRows();
            clearDraft();
            checkTableAndToggleSaveButton(); 
            
        } catch (error) { 
            feedbackDiv.textContent = `Erro ao salvar: ${error.message}`; 
            feedbackDiv.style.color = 'red'; 
        } 
    });
    
    function populateSelector() { tableSelector.innerHTML = '<option value="">-- Selecione uma tabela --</option>';
    const sortedKeys = Object.keys(validationSchemas).sort((a, b) => validationSchemas[a].displayName.localeCompare(validationSchemas[b].displayName)); sortedKeys.forEach(key => { tableSelector.innerHTML += `<option value="${key}">${validationSchemas[key].displayName}</option>`; }); }

    loadNavbar();
    populateSelector();
});
</file>

<file path="shared/validators.js">
// arquivo: shared/validators.js

const normalizeString = (value) => {
    if (typeof value !== 'string') return '';
    return value
        .toLowerCase()
        .normalize('NFD').replace(/[\u0000-\u036f]/g, '')
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') 
        .trim();
};

// --- Listas de Fitofisionomias por Bioma (Constantes Auxiliares) ---
const BIOME_DATA = {
    "Amaznia": [
        "Floresta Ombrfila Aberta Aluvial", "Floresta Ombrfila Aberta Terras Baixas", "Floresta Ombrfila Aberta Submontana",
        "Floresta Estacional Decidual Terras Baixas", "Floresta Estacional Decidual Submontana", "Floresta Ombrfila Densa Aluvial",
        "Floresta Ombrfila Densa de Terras Baixas", "Floresta Ombrfila Densa Montana", "Floresta Ombrfila Densa Submontana",
        "Floresta Estacional Semidecidual aluvial", "Floresta Estacional Semidecidual de terras baixas", "Floresta Estacional Semidecidual montana",
        "Floresta Estacional Semidecidual Submontana", "Campinarana Arborizada", "Campinarana Arbustiva", "Campinarana Florestada",
        "Campinarana gramneo lenhosa", "Vegetao com influncia fluvial e/ou lacustre", "Pioneiras com influncia fluviomarinha (mangue)",
        "Pioneiras com influncia Marinha (restinga)", "Refgio montano", "Savana Arborizada", "Savana Florestada", "Savana Gramneo- Lenhosa",
        "Savana Parque", "Savana Estpica Arborizada", "Savana Estpica Florestada", "Savana Estpica Gramneo Lenhosa", "Savana Estpica Parque",
        "Floresta Ombrfila Aberta Montana", "Floresta Estacional Decidual Aluvial", "Refgio Alto-Montano", "Refgio Submontano",
        "Contato Savana/Formaes Pioneiras - Especfico para Formao Pioneira com Influncia Marinha (Restinga)", "Contato Savana/Floresta Estacional SN",
        "Contato Savana/Floresta Ombrfila SO", "Contato Savana/Savana-Estpica ST", "Contato Savana- Estpica/Floresta Estacional TN",
        "Contato Campinarana/Floresta Ombrfila LO", "Contato Floresta Ombrfila/Floresta Estacional ON", "Savana-Estpica", "Savana",
        "reas das Formaes Pioneira", "Campinarana"
    ],
    "Cerrado": [
        "Floresta Ombrfila Aberta Aluvial", "Floresta Ombrfila Aberta das Terras Baixas", "Floresta Ombrfila Aberta Submontana",
        "Floresta Estacional Decidual Aluvial", "Floresta Estacional Decidual das Terras Baixas", "Floresta Estacional Decidual Montana/BA",
        "Floresta Estacional Decidual Montana/GO", "Floresta Estacional Decidual Montana/MG", "Floresta Estacional Decidual Montana/PI",
        "Floresta Estacional Decidual Montana/MS", "Floresta Estacional Decidual Montana/TO", "Floresta Estacional Decidual Submontana/BA",
        "Floresta Estacional Decidual Submontana/GO", "Floresta Estacional Decidual Submontana/MA", "Floresta Estacional Decidual Submontana/MG",
        "Floresta Estacional Decidual Submontana/PI", "Floresta Estacional Decidual Submontana/TO", "Floresta Estacional Decidual Submontana/MS",
        "Floresta Estacional Decidual Submontana/MT", "Floresta Estacional Decidual Submontana/SP", "Floresta Ombrfila Densa Aluvial",
        "Floresta Ombrfila Densa de Terras Baixas", "Floresta Ombrfila Densa Submontana", "Estepe Gramneo-Lenhosa",
        "Floresta Estacional Semidecidual Aluvial/MA", "Floresta Estacional Semidecidual Aluvial/PA", "Floresta Estacional Semidecidual Aluvial/TO",
        "Floresta Estacional Semidecidual Aluvial/BA", "Floresta Estacional Semidecidual Aluvial/GO", "Floresta Estacional Semidecidual Aluvial/MG",
        "Floresta Estacional Semidecidual Aluvial/PI", "Floresta Estacional Semidecidual Aluvial/PR", "Floresta Estacional Semidecidual Aluvial/SP",
        "Floresta Estacional Semidecidual Aluvial/MS", "Floresta Estacional Semidecidual Aluvial/MT", "Floresta Estacional Semidecidual das Terras Baixas/MA",
        "Floresta Estacional Semidecidual das Terras Baixas/MT", "Floresta Estacional Semidecidual das Terras Baixas/GO", "Floresta Estacional Semidecidual das Terras Baixas/PI",
        "Floresta Estacional Semidecidual Montana/BA", "Floresta Estacional Semidecidual Montana/PI", "Floresta Estacional Semidecidual Montana/GO",
        "Floresta Estacional Semidecidual Montana/MG", "Floresta Estacional Semidecidual Montana/MS", "Floresta Estacional Semidecidual Montana/PR",
        "Floresta Estacional Semidecidual Montana/SP", "Floresta Estacional Semidecidual Montana/TO", "Floresta Estacional Semidecidual Submontana/BA",
        "Floresta Estacional Semidecidual Submontana/MA", "Floresta Estacional Semidecidual Submontana/PI", "Floresta Estacional Semidecidual Submontana/GO/MG/MS/MT/SP/TO",
        "Floresta Estacional Semidecidual Submontana/MG", "Floresta Estacional Semidecidual Submontana/MS", "Floresta Estacional Semidecidual Submontana/MT",
        "Floresta Estacional Semidecidual Submontana/SP", "Floresta Estacional Semidecidual Submontana/TO", "Floresta Ombrfila Mista Aluvial",
        "Floresta Ombrfila Mista Alto-montana", "Floresta Ombrfila Mista Montana", "Contato Floresta Ombrfila/Floresta Estacional", "Formao Pioneira",
        "Formao Pioneira com influncia fluvial e/", "Formao Pioneira com influncia fluvio- marinha (mangue)", "Formao Pioneira com influncia marinha (restinga)",
        "Refgio Montano", "Savana", "Savana Arborizada", "Savana Florestada/PR", "Savana Florestada/SP", "Savana Florestada/BA", "Savana Florestada/DF",
        "Savana Florestada/GO", "Savana Florestada/MG", "Savana Florestada/MS", "Savana Florestada/MT", "Savana Florestada/MA", "Savana Florestada/PI",
        "Savana Florestada/TO", "Savana Gramneo-lenhosa", "Contato Savana/Floresta Ombrfila Mista", "Contato Savana/Floresta Estacional",
        "Contato Savana/Floresta Ombrfila", "Savana Parque", "Contato Savana/Savana- Estpica", "Contato Savana/Savana- Estpica/Floresta Estacional",
        "Savana-Estpica", "Savana Estpica Arborizada", "Savana Estpica Florestada", "Savana Estpica Gramneo-lenhosa",
        "Contato Savana- Estpica/Floresta Estacional", "Savana Estpica Parque"
    ],
    "Mata_Atlntica": [
        "Floresta Ombrfila Aberta Aluvial", "Floresta Ombrfila Aberta Terras baixas", "Floresta Ombrfila Aberta Montana",
        "Floresta Ombrfila Aberta Submontana", "Floresta Estacional Decidual Aluvial", "Floresta Estacional Decidual Terras baixas",
        "Floresta Estacional Decidual Montana", "Floresta Estacional Decidual Submontana", "Floresta Ombrfila Densa (Floresta Tropical Pluvial)",
        "Floresta Ombrfila Densa Aluvial", "Floresta Ombrfila Densa Terras baixas", "Floresta Ombrfila Densa Alto-Montana",
        "Floresta Ombrfila Densa Montana", "Floresta Ombrfila Densa Submontana", "Estepe", "Estepe Gramneo-Lenhosa",
        "Contato EstepeFloresta Ombrfila Mista", "Contato Estepe/Floresta Estacional", "Floresta Estacional Semidecidual",
        "Floresta Estacional Semidecidual Aluvial", "Floresta Estacional Semidecidual Terras baixas", "Floresta Estacional Semidecidual Montana",
        "Floresta Estacional Semidecidual Submontana", "Campinarana", "Campinarana arborizada", "Campinarana Gramneo-Lenhosa",
        "Floresta Ombrfila Mista", "Floresta Ombrfila Mista Aluvial", "Floresta Ombrfila Mista Alto-Montana", "Floresta Ombrfila Mista Montana",
        "Floresta Ombrfila Mista Submontana", "Contato Floresta Estacional/Floresta Ombrfila Mista", "Contato Floresta Estacional/Formaes Pioneiras Especfico para Formao Pioneira com Influncia Marinha (Restinga)",
        "Contato Floresta Ombrfila Densa/Floresta Ombrfila Mista", "Contato Floresta Ombrfila/Floresta Estacional",
        "Contato Floresta Ombrfila/Formaes Pioneiras Especfico para Formao Pioneira com Influncia Marinha (Restinga)", "reas das Formaes Pioneiras",
        "Vegetao com influncia fluvial e/ou lacustre", "Vegetao com influncia marinha (Restinga)", "Vegetao com influncia marinha (Restinga)",
        "Refgios Alto Montanos", "Refgios montanos", "Savana", "Savana arborizada", "Savana florestada", "Savana Gramneo-Lenhosa",
        "Contato Savana/Floresta Ombrfila Mista", "Contato Savana/Floresta Estacional", "Contato Savana/Floresta Ombrfila",
        "Contato Savana/Formaes Pioneiras", "Savana parque", "Contato Savana/Formaes pioneiras Especfico para Formao Pioneira com Influncia Marinha (Restinga)",
        "Contato Savana/Savana-Estpica", "Savana- Estpica arborizada", "Savana- Estpica florestada", "Savana- Estpica Gramneo-Lenhosa",
        "Contato Savana-Estpica/Floresta Estacional"
    ],
    "Caatinga": [
        "Floresta Ombrfila Aberta Aluvial", "Floresta Ombrfila Aberta Terras Baixas", "Floresta Ombrfila Aberta Montana",
        "Afloramento Rochoso", "Floresta Ombrfila Aberta Submontana", "Floresta Estacional Decidual Aluvial",
        "Floresta Estacional Decidual Terras Baixas", "Floresta Estacional Decidual Montana", "Floresta Estacional Decidual Submontana",
        "Floresta Ombrfila Densa Aluvial", "Floresta Ombrfila Densa Montana", "Dunas", "Floresta Ombrfila Densa Submontana",
        "Floresta Estacional Semidecidual aluvial", "Floresta Estacional Semidecidual de terras baixas", "Floresta Estacional Semidecidual Montana",
        "Floresta Estacional Semidecidual Submontana", "Vegetao com influncia fluvial e/ou lacustre", "Pioneiras com influncia fluviomarinha (mangue)",
        "Pioneiras com influncia Marinha (restinga)", "Refgio Montano", "Savana Arborizada", "Savana Florestada", "Savana Gramneo- Lenhosa",
        "Contato Savana/Floresta", "Savana Parque", "Contato Savana/Formaes pioneiras Especfico para Formao Pioneira com Influncia Marinha (Restinga)",
        "Savana Estpica Arborizada (caatinga aberta)", "Savana Estpica Florestada (caatinga densa)", "Savana Estpica Gramneo Lenhosa",
        "Contato Savana/Floresta Estacional", "Savana Estpica Parque"
    ],
    "Pampa": [
        "Floresta Estacional Decidual Aluvial", "Floresta Estacional Decidual Terras baixas", "Floresta Estacional Decidual Montana",
        "Floresta Estacional Decidual Submontana", "Floresta Ombrfla Densa Aluvial", "Floresta Ombrfla Densa Terras baixas",
        "Floresta Ombrfla Densa Montana", "Dunas", "Floresta Ombrfla Densa Submontana", "Estepe", "Estepe Arborizada",
        "Estepe Gramneo Lenhosa", "Estepe Parque", "Contato Estepe- Floresta Ombrfila Mista", "Contato Estepe- Floresta Estacional",
        "Contato Estepe- Formaes", "Floresta Estacional Semidecidual Aluvial", "Floresta Estacional Semidecidual Terras baixas",
        "Floresta Estacional Semidecidual Montana", "Floresta Estacional Semidecidual Submontana", "Floresta Ombrfla Mista Aluvial",
        "Floresta Ombrfla Mista Submontana", "Contato Floresta Estacional- Floresta Ombrfila Mista",
        "Contato Floresta Estacional- Formaes Pioneiras com Influncia Marinha (Restinga)", "Contato Floresta Ombrfila Densa-Floresta Ombrfila Mista",
        "Contato Floresta Ombrfila- Formaes Pioneiras com Influncia Marinha (Restinga)", "reas das Formaes Pioneiras",
        "Vegetao com influncia Fluvial e/ou lacustre", "Vegetao com influncia Fluviomarinha", "Vegetao com influncia Marinha (Restinga)",
        "Savana Estpica", "Savana Estpica Gramneo-Lenhosa", "Savana Estpica Parque"
    ],
    "Pantanal": [
        "Floresta Estacional Decidual Aluvial", "Floresta Estacional Decidual Terras baixas", "Floresta Estacional Decidual Submontana",
        "Floresta Estacional Semidecidual Aluvial", "Floresta Estacional Semidecidual Terras baixas", "Floresta Estacional Semidecidual Submontana",
        "Contato Savana/Floresta Estacional", "Contato Savana- Estpica/Floresta Estacional", "Savana", "Savana arborizada", "Savana florestada",
        "Contato Savana/Savana- Estpica", "Savana-Estpica", "Savana- Estpica arborizada", "Savana- Estpica florestada", "Savana",
        "Savana Estpica Gramneo- Lenhosa", "Savana parque", "Savana-Estpica parque"
    ]
};

const ALL_FITOFISIONOMIAS = [...new Set(Object.values(BIOME_DATA).flat())].sort();

export const validationSchemas = {
    conservation_area: {
        displayName: "rea de Conservao",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            bioma: "Bioma",
            fitofisionomia: "Fitofisionomia",
            area_plantada: "rea de conservao plantada?",
            plantio: "Plantio",
            area_inicio_ano: "rea (hectare) - 01/01/{ANO}",
            area_fim_ano: "rea (hectare) - 31/12/{ANO}",
            motivo_alteracao: "Motivo Aumento/Reduo",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            bioma: ["Amaznia", "Cerrado", "Mata_Atlntica", "Caatinga", "Pampa", "Pantanal"],
            fitofisionomia: ALL_FITOFISIONOMIAS,
            area_plantada: ["Sim", "No"]
        },
        autoFillMap: {},
        dependencyMap: {
            triggerField: "bioma",
            targetField: "fitofisionomia",
            data: BIOME_DATA
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            
            if (!this.validOptions.bioma.includes(rowData.bioma)) {
                errors.bioma = "Selecione um bioma vlido.";
            }
            
            if (rowData.bioma) {
                const validFitosForBiome = BIOME_DATA[rowData.bioma];
                if (!validFitosForBiome) {
                    errors.bioma = "Bioma desconhecido na base de dados.";
                } else {
                    if (!rowData.fitofisionomia) {
                        errors.fitofisionomia = "Obrigatrio.";
                    } else if (!validFitosForBiome.includes(rowData.fitofisionomia)) {
                        errors.fitofisionomia = `Esta fitofisionomia no pertence ao bioma ${rowData.bioma}.`;
                    }
                }
            } else if (!rowData.fitofisionomia) {
                errors.fitofisionomia = "Obrigatrio.";
            }

            const normalizedPlantada = normalizeString(rowData.area_plantada);
            if (['sim', 's'].includes(normalizedPlantada)) rowData.area_plantada = 'Sim';
            else if (['nao', 'n'].includes(normalizedPlantada)) rowData.area_plantada = 'No';

            if (!this.validOptions.area_plantada.includes(rowData.area_plantada)) {
                errors.area_plantada = "Deve ser 'Sim' ou 'No'.";
            }

            if (rowData.area_plantada === 'Sim') {
                if (!isFilled(rowData.plantio)) {
                    errors.plantio = "Obrigatrio se a rea for plantada.";
                }
            } else {
                if (isFilled(rowData.plantio)) {
                    errors.plantio = "Deve estar vazio se a rea no for plantada.";
                }
            }

            const areaInicioVal = rowData.area_inicio_ano;
            if (!isFilled(areaInicioVal) || isNaN(parseFloat(areaInicioVal)) || parseFloat(areaInicioVal) < 0) {
                errors.area_inicio_ano = "Deve ser um nmero positivo ou zero.";
            }

            const areaFimVal = rowData.area_fim_ano;
            if (!isFilled(areaFimVal) || isNaN(parseFloat(areaFimVal)) || parseFloat(areaFimVal) < 0) {
                errors.area_fim_ano = "Deve ser um nmero positivo ou zero.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    electricity_purchase: {
        displayName: "Compra de Eletricidade",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            fonte_energia: "Fonte de Energia",
            especificar_fonte: "Especificar Fonte",
            consumo: "Consumo",
            unidade_medida: "Unidade de Medida",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            fonte_energia: ["Sistema Interligado Nacional", "Mercado Livre Convencional", "Mercado Livre Incentivado", "Fonte Energtica Especfica"],
            especificar_fonte: ["Solar", "Elica", "Biomassa", "No identificado", "Outros tipos de fonte"],
            unidade_medida: ["kWh", "MWh"]
        },
        dependencyMap: {
            triggerField: "fonte_energia",
            targetField: "especificar_fonte",
            data: {
                "Mercado Livre Convencional": ["Solar", "Elica", "Biomassa", "No identificado", "Outros tipos de fonte"],
                "Mercado Livre Incentivado": ["Solar", "Elica", "Biomassa", "No identificado"],
                "Fonte Energtica Especfica": ["Solar", "Elica", "Biomassa", "No identificado"],
                "Sistema Interligado Nacional": []
            }
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = `Perodo invlido.`;
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";

            if (!this.validOptions.fonte_energia.includes(rowData.fonte_energia)) {
                errors.fonte_energia = "Selecione uma fonte de energia vlida.";
            }

            const consumoVal = rowData.consumo;
            if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) < 0) {
                errors.consumo = `Entrada invlida ('${consumoVal}'). Insira um nmero decimal positivo ou zero.`;
            }

            if (!this.validOptions.unidade_medida.includes(rowData.unidade_medida)) {
                errors.unidade_medida = "Selecione 'kWh' ou 'MWh'.";
            }

            const isSIN = rowData.fonte_energia === 'Sistema Interligado Nacional';
            if (!isSIN) {
                if (!isFilled(rowData.especificar_fonte)) {
                    errors.especificar_fonte = "Obrigatrio selecionar uma especificao para esta fonte de energia.";
                } else if (!this.validOptions.especificar_fonte.includes(rowData.especificar_fonte)) {
                    errors.especificar_fonte = "Especificao invlida.";
                } else {
                    const allowedOptions = this.dependencyMap.data[rowData.fonte_energia];
                    if (allowedOptions && !allowedOptions.includes(rowData.especificar_fonte)) {
                        errors.especificar_fonte = `A opo '${rowData.especificar_fonte}' no  vlida para '${rowData.fonte_energia}'.`;
                    }
                }
            } else {
                if (isFilled(rowData.especificar_fonte)) {
                    errors.especificar_fonte = "Este campo s deve ser preenchido se a fonte no for SIN.";
                }
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    solid_waste: {
        displayName: "Resduos Slidos",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            destinacao_final: "Destinao Final",
            tipo_residuo: "Tipo de Resduo",
            quantidade_gerado: "Quantidade Gerado",
            unidade: "Unidade",
            informar_cidade_uf: "Cidade/UF de Destino",
            local_controlado_empresa: "O local de disposio  controlado pela empresa?",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            destinacao_final: ["Aterro", "Compostagem", "Incinerao", "Cogerao", "Reciclagem"],
            tipo_residuo: [
                "A - Papis/papelo",
                "C - Resduos alimentares",
                "D - Madeira",
                "E - Resduos de jardim e parque",
                "F - Fraldas",
                "G - Borracha e couro",
                "H - Lodo de esgoto",
                "I - Outros materiais inertes",
                "J - Outros Resduos Orgnicos"
            ],
            unidade: ["Toneladas", "Quilogramas"],
            informar_cidade_uf: ["Sim", "No"],
            local_controlado_empresa: ["Sim", "No"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = `Perodo invlido.`;
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";

            if (!this.validOptions.destinacao_final.includes(rowData.destinacao_final)) {
                errors.destinacao_final = "Selecione uma destinao vlida.";
            }

            if (!this.validOptions.tipo_residuo.includes(rowData.tipo_residuo)) {
                errors.tipo_residuo = "Selecione um tipo de resduo vlido.";
            }

            const quantidadeVal = rowData.quantidade_gerado;
            if (!isFilled(quantidadeVal) || isNaN(parseFloat(quantidadeVal)) || parseFloat(quantidadeVal) <= 0) {
                errors.quantidade_gerado = `Entrada invlida ('${quantidadeVal}'). Insira um nmero decimal e positivo.`;
            }

            if (!this.validOptions.unidade.includes(rowData.unidade)) {
                errors.unidade = "Selecione 'Toneladas' ou 'Quilogramas'.";
            }
            
            const normalizedControlado = normalizeString(rowData.local_controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.local_controlado_empresa = 'Sim'; } 
            else if (['nao', 'n'].includes(normalizedControlado)) { rowData.local_controlado_empresa = 'No'; }
            if (!this.validOptions.local_controlado_empresa.includes(rowData.local_controlado_empresa)) {
                errors.local_controlado_empresa = "Deve ser 'Sim' ou 'No'.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    combustao_movel: {
        displayName: "Combusto Mvel",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            descricao_fonte: "Descrio da Fonte",
            tipo_entrada: "Tipo de Entrada",
            combustivel: "Combustvel",
            consumo: "Consumo",
            unidade_consumo: "Unidade de Consumo",
            distancia_percorrida: "Distncia Percorrida",
            unidade_distancia: "Unidade da Distncia",
            tipo_veiculo: "Tipo de Veculo",
            controlado_empresa: "Controlado pela Empresa?",
            comentarios: "Comentrios"
        },
        displayValueMap: {
            tipo_entrada: {
                consumo: "Por Consumo",
                distancia: "Por Distncia"
            }
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            controlado_empresa: ["Sim", "No"],
            tipo_entrada: ["consumo", "distancia"],
            combustivel: [
                "Gasolina Automotiva", "leo Diesel", "Gs Natural Veicular (GNV)", "Gs Natural Liquefeito (GNL)", "Gs Liquefeito de Petrleo (GLP)", "Querosene de Aviao", "Gasolina de Aviao", "Lubrificantes", "Metanol", "leo Combustvel", "Etanol Hidratado", "Biodiesel (B100)", "Biometano", "Bioquerosene (SAF)", "HVO (diesel verde)", "Biometanol", "Etanol Anidro"
            ],
            unidade_consumo: ["Litros", "m", "kg"],
            unidade_distancia: ["Km", "Milhas"],
            tipo_veiculo: [
                "Automvel a gasolina", "Automvel a etanol", "Automvel flex a gasolina", "Automvel flex a etanol", "Motocicleta a gasolina", "Motocicleta flex a gasolina", "Motocicleta flex a etanol", "Veculo comercial leve a gasolina", "Veculo comercial leve a etanol", "Veculo comercial leve flex a gasolina", "Veculo comercial leve flex a etanol", "Veculo comercial leve a diesel", "Micro-nibus a diesel", "nibus rodovirio a diesel", "nibus urbano a diesel", "Caminho - rgido (3,5 a 7,5 toneladas)", "Caminho - rgido (7,5 a 17 toneladas)", "Caminho - rgido (acima de 17 toneladas)", "Caminho - rgido (mdia)", "Caminho - articulado (3,5 a 33 toneladas)", "Caminho - articulado (acima de 33 toneladas)", "Caminho - articulado (mdia)", "Caminho - caminho (mdia)", "Caminho refrigerado - rgido (3,5 a 7,5 toneladas)", "Caminho refrigerado - rgido (7,5 a 17 toneladas)", "Caminho refrigerado - rgido (acima de 17 toneladas)", "Caminho refrigerado - rgido (mdia)", "Caminho refrigerado - articulado (3,5 a 33 toneladas)", "Caminho refrigerado - articulado (acima de 33 toneladas)", "Caminho refrigerado - articulado (mdia)", "Caminho refrigerado - caminho (mdia)", "Automvel a GNV"
            ]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Gasolina Automotiva": "Litros", "leo Diesel": "Litros", "Gs Natural Veicular (GNV)": "m", "Gs Natural Liquefeito (GNL)": "Litros", "Gs Liquefeito de Petrleo (GLP)": "kg", "Querosene de Aviao": "Litros", "Gasolina de Aviao": "Litros", "Lubrificantes": "Litros", "Metanol": "Litros", "leo Combustvel": "Litros", "Etanol Hidratado": "Litros", "Biodiesel (B100)": "Litros", "Biometano": "m", "Bioquerosene (SAF)": "Litros", "HVO (diesel verde)": "Litros", "Biometanol": "Litros", "Etanol Anidro": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';
            
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = `Perodo invlido.`;
            if (!rowData.descricao_fonte) errors.descricao_fonte = "Obrigatrio.";
            
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'No'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'No'."; }

            if (!this.validOptions.tipo_entrada.includes(rowData.tipo_entrada)) {
                errors.tipo_entrada = "Deve ser 'consumo' ou 'distancia'.";
            } else {
                if (rowData.tipo_entrada === 'consumo') {
                    if (!this.validOptions.combustivel.includes(rowData.combustivel)) { errors.combustivel = "Selecione um combustvel vlido."; }
                    const consumoVal = rowData.consumo;
                    if (consumoVal === '' || isNaN(parseFloat(consumoVal))) { errors.consumo = `Entrada invlida ('${consumoVal}'). Insira um nmero.`; }
                    if (this.autoFillMap.combustivel.map[rowData.combustivel] !== rowData.unidade_consumo) { errors.unidade_consumo = `Unidade incorreta para o combustvel.`; }
                    if (isFilled(rowData.distancia_percorrida)) errors.distancia_percorrida = "Deve estar vazio para entrada por consumo.";
                    if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve estar vazio para entrada por consumo.";
                    if (isFilled(rowData.tipo_veiculo)) errors.tipo_veiculo = "Deve estar vazio para entrada por consumo.";
                } else if (rowData.tipo_entrada === 'distancia') {
                    const distanciaVal = rowData.distancia_percorrida;
                    if (distanciaVal === '' || isNaN(parseFloat(distanciaVal))) { errors.distancia_percorrida = `Entrada invlida ('${distanciaVal}'). Insira um nmero.`; }
                    if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) { errors.unidade_distancia = "Selecione 'Km' ou 'Milhas'."; }
                    if (!this.validOptions.tipo_veiculo.includes(rowData.tipo_veiculo)) { errors.tipo_veiculo = "Selecione um tipo de veculo vlido."; }
                    if (isFilled(rowData.combustivel)) errors.combustivel = "Deve estar vazio para entrada por distncia.";
                    if (isFilled(rowData.consumo)) errors.consumo = "Deve estar vazio para entrada por distncia.";
                    if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve estar vazio para entrada por distncia.";
                }
            }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    combustao_estacionaria: {
        displayName: "Combusto Estacionria",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano", periodo: "Perodo", unidade_empresarial: "Unidade Empresarial", descricao_da_fonte: "Descrio da Fonte", combustivel_estacionario: "Combustvel", consumo: "Consumo", unidade: "Unidade", controlado_empresa: "Controlado pela Empresa?", comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            combustivel_estacionario: [
                "Acetileno", "Alcatro", "Asfaltos", "Bagao de Cana", "Biodiesel (B100)", 
                "Biogs (outros)", "Biogs de aterro", "Biometano", "Caldo de Cana", "Carvo Metalrgico Importado", 
                "Carvo Metalrgico Nacional", "Carvo Vapor 3100 kcal / kg", "Carvo Vapor 3300 kcal / kg", 
                "Carvo Vapor 3700 kcal / kg", "Carvo Vapor 4200 kcal / kg", "Carvo Vapor 4500 kcal / kg", 
                "Carvo Vapor 4700 kcal / kg", "Carvo Vapor 5200 kcal / kg", "Carvo Vapor 5900 kcal / kg", 
                "Carvo Vapor 6000 kcal / kg", "Carvo Vapor sem Especificao", "Carvo Vegetal", 
                "Coque de Carvo Mineral", "Coque de Petrleo", "Etano", "Etanol Anidro", "Etanol Hidratado", 
                "Gs de Coqueria", "Gs de Refinaria", "Gs Liquefeito de Petrleo (GLP)", "Gs Natural Seco", 
                "Gs Natural mido", "Gasolina Automotiva (pura)", "Gasolina de Aviao", "Lenha Comercial", 
                "Licor Negro (Lixvia)", "Lquidos de Gs Natural (LGN)", "Lubrificantes", "Melao", "Nafta", 
                "leo Combustvel", "leo de Xisto", "leo Diesel (puro)", "leos Residuais", 
                "Outros Produtos de Petrleo", "Parafina", "Petrleo Bruto", "Querosene de Aviao", 
                "Querosene Iluminante", "Resduos Industriais", "Resduos Municipais (frao biomassa)", 
                "Resduos Municipais (frao no-biomassa)", "Resduos Vegetais", "Solventes", "Turfa", 
                "Xisto Betuminoso e Areias Betuminosas"
            ],
            unidade: ["kg", "m", "Toneladas", "Litros", "TJ"],
            controlado_empresa: ["Sim", "No"],
        },
        autoFillMap: {
            combustivel_estacionario: {
                targetColumn: "unidade",
                map: {
                    "Acetileno": "kg", "Alcatro": "m", "Asfaltos": "m", "Bagao de Cana": "Toneladas", 
                    "Biodiesel (B100)": "Litros", "Biogs (outros)": "Toneladas", "Biogs de aterro": "Toneladas", 
                    "Biometano": "Toneladas", "Caldo de Cana": "Toneladas", "Carvo Metalrgico Importado": "Toneladas", 
                    "Carvo Metalrgico Nacional": "Toneladas", "Carvo Vapor 3100 kcal / kg": "Toneladas", 
                    "Carvo Vapor 3300 kcal / kg": "Toneladas", "Carvo Vapor 3700 kcal / kg": "Toneladas", 
                    "Carvo Vapor 4200 kcal / kg": "Toneladas", "Carvo Vapor 4500 kcal / kg": "Toneladas", 
                    "Carvo Vapor 4700 kcal / kg": "Toneladas", "Carvo Vapor 5200 kcal / kg": "Toneladas", 
                    "Carvo Vapor 5900 kcal / kg": "Toneladas", "Carvo Vapor 6000 kcal / kg": "Toneladas", 
                    "Carvo Vapor sem Especificao": "Toneladas", "Carvo Vegetal": "Toneladas", 
                    "Coque de Carvo Mineral": "Toneladas", "Coque de Petrleo": "m", "Etano": "Toneladas", 
                    "Etanol Anidro": "Litros", "Etanol Hidratado": "Litros", "Gs de Coqueria": "Toneladas", 
                    "Gs de Refinaria": "Toneladas", "Gs Liquefeito de Petrleo (GLP)": "Toneladas", 
                    "Gs Natural Seco": "m", "Gs Natural mido": "m", "Gasolina Automotiva (pura)": "Litros", 
                    "Gasolina de Aviao": "Litros", "Lenha Comercial": "Toneladas", "Licor Negro (Lixvia)": "Toneladas", 
                    "Lquidos de Gs Natural (LGN)": "Toneladas", "Lubrificantes": "Litros", "Melao": "Toneladas", 
                    "Nafta": "m", "leo Combustvel": "Litros", "leo de Xisto": "Toneladas", 
                    "leo Diesel (puro)": "Litros", "leos Residuais": "Toneladas", "Outros Produtos de Petrleo": "Toneladas", 
                    "Parafina": "Toneladas", "Petrleo Bruto": "m", "Querosene de Aviao": "Toneladas", 
                    "Querosene Iluminante": "Toneladas", "Resduos Industriais": "TJ", 
                    "Resduos Municipais (frao biomassa)": "Toneladas", "Resduos Municipais (frao no-biomassa)": "Toneladas", 
                    "Resduos Vegetais": "Toneladas", "Solventes": "Litros", "Turfa": "Toneladas", 
                    "Xisto Betuminoso e Areias Betuminosas": "Toneladas"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.descricao_da_fonte) errors.descricao_da_fonte = "Obrigatrio.";
            if (!this.validOptions.combustivel_estacionario.includes(rowData.combustivel_estacionario)) errors.combustivel_estacionario = "Combustvel invlido.";
            const consumoVal = rowData.consumo;
            if (consumoVal === '' || isNaN(parseFloat(consumoVal))) { errors.consumo = `Entrada invlida ('${consumoVal}'). Insira um nmero.`; }
            if (this.autoFillMap.combustivel_estacionario.map[rowData.combustivel_estacionario] !== rowData.unidade) errors.unidade = `Unidade incorreta para o combustvel.`;
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'No'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'No'."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    dados_producao_venda: {
        displayName: "Dados de Produo e Venda",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Perodo", unidade_empresarial: "Unidade Empresarial", produto: "Produto", quantidade_vendida: "Quantidade Vendida", unidade_medida: "Unidade de Medida", comentarios: "Comentrios" },
        validOptions: { periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"] },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.produto) errors.produto = "Obrigatrio.";
            if (!rowData.unidade_medida) errors.unidade_medida = "Obrigatrio.";
            const quantidadeVal = rowData.quantidade_vendida;
            const quantidadeNum = parseInt(quantidadeVal, 10);
            if (isNaN(quantidadeNum) || quantidadeNum <= 0 || String(quantidadeVal).includes('.') || String(quantidadeVal).includes(',')) { errors.quantidade_vendida = `Entrada invlida ('${quantidadeVal}'). Insira um nmero inteiro e positivo.`; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    ippu_lubrificantes: {
        displayName: "IPPU - Lubrificantes",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Perodo", unidade_empresarial: "Unidade Empresarial", fonte_emissao: "Fonte de Emisso / Equipamento", tipo_lubrificante: "Tipo de Lubrificante", consumo: "Consumo", unidade: "Unidade", controlado_empresa: "Controlado pela Empresa?", comentarios: "Comentrios" },
        validOptions: { periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], tipo_lubrificante: ["Lubrificante", "Graxa"], unidade: ["Litros", "kg"], controlado_empresa: ["Sim", "No"] },
        autoFillMap: { tipo_lubrificante: { targetColumn: "unidade", map: { "Lubrificante": "Litros", "Graxa": "kg" } } },
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.fonte_emissao) errors.fonte_emissao = "Obrigatrio.";
            if (!this.validOptions.tipo_lubrificante.includes(rowData.tipo_lubrificante)) errors.tipo_lubrificante = "Tipo invlido.";
            const consumoVal = rowData.consumo;
            const consumoNum = parseFloat(consumoVal);
            if (isNaN(consumoNum) || consumoNum <= 0) { errors.consumo = `Entrada invlida ('${consumoVal}'). Insira um nmero positivo.`; }
            if (this.autoFillMap.tipo_lubrificante.map[rowData.tipo_lubrificante] !== rowData.unidade) { errors.unidade = `Unidade incorreta para o tipo de lubrificante.`; }
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'No'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'No'."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    emissoes_fugitivas: {
        displayName: "Emisses Fugitivas",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Perodo", unidade_empresarial: "Unidade Empresarial", fonte_emissao: "Fonte de Emisso / Equipamento", tipo_gas: "Tipo de Gs", quantidade_reposta: "Quantidade Reposta", unidade: "Unidade", controlado_empresa: "Controlado pela Empresa?", comentarios: "Comentrios" },
        
        gasList: ["Dixido de carbono (CO2)", "Metano (CH4)", "xido nitroso (N2O)", "HFC-23", "HFC-32", "HFC-41", "HFC-125", "HFC-134", "HFC-134a", "HFC-143", "HFC-143a", "HFC-152", "HFC-152a", "HFC-161", "HFC-227ea", "HFC-236cb", "HFC-236ea", "HFC-236fa", "HFC-245ca", "HFC-245fa", "HFC-365mfc", "HFC-43-10mee", "Hexafluoreto de enxofre (SF6)", "Trifluoreto de nitrognio (NF3)", "PFC-14", "PFC-116", "PFC-218", "PFC-318", "PFC-3-1-10", "PFC-4-1-12", "PFC-5-1-14", "PFC-9-1-18", "Trifluorometil pentafluoreto de enxofre (SF5CF3)", "Perfluorociclopropano (c-C3F6)", "R-400", "R-401A", "R-401B", "R-401C", "R-402A", "R-402B", "R-403A", "R-403B", "R-404A", "R-405A", "R-406A", "R-407A", "R-407B", "R-407C", "R-407D", "R-407E", "R-407F", "R-407G", "R-407H", "R-407I", "R-408A", "R-409A", "R-409B", "R-410A", "R-410B", "R-411A", "R-411B", "R-412A", "R-413A", "R-414A", "R-414B", "R-415A", "R-415B", "R-416A", "R-417A", "R-417B", "R-417C", "R-418A", "R-419A", "R-419B", "R-420A", "R-421A", "R-421B", "R-422A", "R-422B", "R-422C", "R-422D", "R-422E", "R-423A", "R-424A", "R-425A", "R-426A", "R-427A", "R-428A", "R-429A", "R-430A", "R-431A", "R-432A", "R-433A", "R-433B", "R-433C", "R-434A", "R-435A", "R-436A", "R-436B", "R-436C", "R-437A", "R-438A", "R-439A", "R-440A", "R-441A", "R-442A", "R-443A", "R-444B", "R-445A", "R-446A", "R-447A", "R-447B", "R-448A", "R-449A", "R-449B", "R-449C", "R-450A", "R-451A", "R-451B", "R-452A", "R-452B", "R-452C", "R-453A", "R-454A", "R-454B", "R-454C", "R-455A", "R-456A", "R-457A", "R-458A", "R-459A", "R-459B", "R-460A", "R-460B", "R-460C", "R-461A", "R-462A", "R-463A", "R-464A", "R-465A", "R-500", "R-501", "R-502", "R-503", "R-504", "R-505", "R-506", "R-507 ou R-507A", "R-508A", "R-508B", "R-509 ou R-509A", "R-510A", "R-511A", "R-512A", "R-513A", "R-513B", "R-514A", "R-515A", "R-516A", "CFC-11", "CFC-12", "CFC-13", "CFC-113", "CFC-114", "CFC-115", "Halon-1301", "Halon-1211", "Halon-2402", "Tetracloreto de carbono (CCl4)", "Bromometano (CH3Br)", "Methyl chloroform (CH3CCl3)", "HCFC-21", "HCFC-22 (R22)", "HCFC-123", "HCFC-124", "HCFC-141b", "HCFC-142b", "HCFC-225ca", "HCFC-225cb"],
        
        get validOptions() { return { periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], tipo_gas: this.gasList, unidade: ["kg"], controlado_empresa: ["Sim", "No"] }; },
        autoFillMap: {},
        validateRow: function(rowData, optionsCache) {
            const errors = {};
            const validGasOptions = optionsCache?.tipo_gas || this.validOptions.tipo_gas;
            const validGasOptionsNormalized = validGasOptions.map(g => g.toLowerCase());
            const gasInputNormalized = (rowData.tipo_gas || '').toLowerCase();
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.fonte_emissao) errors.fonte_emissao = "Obrigatrio.";
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'No'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'No'."; }
            const quantidadeVal = rowData.quantidade_reposta;
            const quantidadeNum = parseFloat(quantidadeVal);
            if (isNaN(quantidadeNum) || quantidadeNum <= 0) { errors.quantidade_reposta = `Entrada invlida ('${quantidadeVal}'). Insira um nmero positivo.`; }
            if (rowData.unidade !== 'kg') errors.unidade = "Unidade deve ser 'kg'.";
            if (!gasInputNormalized || !validGasOptionsNormalized.includes(gasInputNormalized)) { errors.tipo_gas = "Obrigatrio selecionar um gs da lista."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    fertilizantes: {
        displayName: "Fertilizantes",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Perodo", unidade_empresarial: "Unidade Empresarial", tipo_fertilizante: "Tipo de Fertilizante", quantidade_kg: "Quantidade de Fertilizante", unidade: "Unidade", percentual_nitrogenio: "Percentual de Nitrognio (%)", percentual_carbonato: "Percentual de Carbonato (%)", controlado_empresa: "Controlado pela Empresa?", comentarios: "Comentrios" },
        validOptions: { periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], unidade: ["kg"], controlado_empresa: ["Sim", "No"] },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.tipo_fertilizante) errors.tipo_fertilizante = "Obrigatrio.";
            const quantidadeVal = rowData.quantidade_kg;
            const quantidadeNum = parseFloat(quantidadeVal);
            if (isNaN(quantidadeNum) || quantidadeNum <= 0) { errors.quantidade_kg = `Entrada invlida ('${quantidadeVal}'). Insira um nmero positivo.`; }
            const percNVal = rowData.percentual_nitrogenio;
            const percCVal = rowData.percentual_carbonato;
            const percN = parseFloat(percNVal);
            const percC = parseFloat(percCVal);
            if (isNaN(percN) || percN < 0 || percN > 100) { errors.percentual_nitrogenio = `Entrada invlida ('${percNVal}'). Insira um nmero de 0 a 100.`; }
            if (isNaN(percC) || percC < 0 || percC > 100) { errors.percentual_carbonato = `Entrada invlida ('${percCVal}'). Insira um nmero de 0 a 100.`; }
            if (rowData.unidade !== 'kg') errors.unidade = "Unidade deve ser 'kg'.";
            if (!isNaN(percN) && !isNaN(percC) && (percN + percC > 100)) {
                errors.percentual_nitrogenio = "A soma das porcentagens no pode exceder 100%.";
                errors.percentual_carbonato = "A soma das porcentagens no pode exceder 100%.";
            }
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'No'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'No'."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    efluentes_controlados: {
        displayName: "Efluentes Controlados",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Perodo", unidade_empresarial: "Unidade Empresarial", tratamento_ou_destino: "Tratamento ou Destino Final?", tipo_tratamento: "Tipo de Tratamento", tipo_destino_final: "Tipo de Destino Final", qtd_efluente_liquido_m3: "Quantidade de Efluente Lquido Gerado", unidade_efluente_liquido: "Unidade do Efluente Lquido", qtd_componente_organico: "Quantidade de Componente Orgnico Degradvel do Efluente", unidade_componente_organico: "Unidade do Componente Orgnico", qtd_nitrogenio_mg_l: "Quantidade de Nitrognio no Efluente Gerado", unidade_nitrogenio: "Unidade do Nitrognio", componente_organico_removido_lodo: "Componente Orgnico do Efluente Removido com o Lodo", unidade_comp_organico_removido_lodo: "Unidade do Componente Orgnico Removido", comentarios: "Comentrios" },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tratamento_ou_destino: ["Tratamento", "Destino Final"],
            tipo_tratamento: [ "Tratamento aerbio (lodo ativado, lagoa aerada, etc)", "Fossa sptica", "Reator anaerbio", "Lagoa anaerbia profunda (profundidade > 2 metros)", "Lagoa anaerbia rasa (profundidade < 2 metros)", "Lagoa facultativa (profundidade < 2 metros)", "Lagoa de maturao (profundidade < 2 metros)", "Fossas secas" ],
            tipo_destino_final: [ "Lanamento em corpos d'gua (no especificado)", "Lanamento em corpos d'gua (que no reservatrios, lagos e esturios)", "Lanamento em reservatrios, lagos e esturios", "Efluente parado a cu aberto", "Lanamento em reservatrios. lagos e esturios" ],
            unidade_componente_organico: [ "mgDQO/L (Demanda qumica de oxignio)", "mgDBO/L (Demanda biolgica de oxignio)" ],
            unidade_comp_organico_removido_lodo: [ "mgDQO/L (Demanda qumica de oxignio)", "mgDBO/L (Demanda biolgica de oxignio)" ],
            unidade_efluente_liquido: ["m3/ano", "m3/ms"],
            unidade_nitrogenio: ["kgN/m3"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            const qtdEfluenteVal = rowData.qtd_efluente_liquido_m3;
            if (isNaN(parseFloat(qtdEfluenteVal)) || parseFloat(qtdEfluenteVal) <= 0) { errors.qtd_efluente_liquido_m3 = `Entrada invlida ('${qtdEfluenteVal}'). Insira um nmero positivo.`; }
            const qtdCompOrgVal = rowData.qtd_componente_organico;
            if (isNaN(parseFloat(qtdCompOrgVal)) || parseFloat(qtdCompOrgVal) <= 0) { errors.qtd_componente_organico = `Entrada invlida ('${qtdCompOrgVal}'). Insira um nmero positivo.`; }
            const qtdNitroVal = rowData.qtd_nitrogenio_mg_l;
            if (isFilled(qtdNitroVal) && (isNaN(parseFloat(qtdNitroVal)) || parseFloat(qtdNitroVal) < 0)) { errors.qtd_nitrogenio_mg_l = `Entrada invlida ('${qtdNitroVal}'). Insira um nmero positivo ou zero.`; }
            if (isFilled(rowData.unidade_nitrogenio) && rowData.unidade_nitrogenio !== 'kgN/m3') { errors.unidade_nitrogenio = "Unidade deve ser 'kgN/m3'."; }
            const compOrgRemovidoVal = rowData.componente_organico_removido_lodo;
            if (isFilled(compOrgRemovidoVal) && (isNaN(parseFloat(compOrgRemovidoVal)) || parseFloat(compOrgRemovidoVal) < 0)) { errors.componente_organico_removido_lodo = `Entrada invlida ('${compOrgRemovidoVal}'). Insira um nmero positivo ou zero.`; }
            if (!this.validOptions.unidade_efluente_liquido.includes(rowData.unidade_efluente_liquido)) { errors.unidade_efluente_liquido = "Unidade deve ser 'm3/ano' ou 'm3/ms'."; }
            if (!this.validOptions.unidade_componente_organico.includes(rowData.unidade_componente_organico)) errors.unidade_componente_organico = "Unidade do componente invlida.";
            if (isFilled(compOrgRemovidoVal)) { if (!this.validOptions.unidade_comp_organico_removido_lodo.includes(rowData.unidade_comp_organico_removido_lodo)) errors.unidade_comp_organico_removido_lodo = "Unidade do componente removido invlida."; }
            if (rowData.unidade_comp_organico_removido_lodo && !isFilled(compOrgRemovidoVal)) { errors.componente_organico_removido_lodo = "Quantidade  obrigatria se a unidade for selecionada."; }
            if (!this.validOptions.tratamento_ou_destino.includes(rowData.tratamento_ou_destino)) { errors.tratamento_ou_destino = "Escolha entre 'Tratamento' e 'Destino Final'."; } else if (rowData.tratamento_ou_destino === 'Tratamento') {
                if (!this.validOptions.tipo_tratamento.includes(rowData.tipo_tratamento)) { errors.tipo_tratamento = "Selecione um tipo de tratamento vlido."; }
                if (isFilled(rowData.tipo_destino_final)) { errors.tipo_destino_final = "Deve estar vazio quando 'Tratamento'  selecionado."; }
            } else if (rowData.tratamento_ou_destino === 'Destino Final') {
                if (!this.validOptions.tipo_destino_final.includes(rowData.tipo_destino_final)) { errors.tipo_destino_final = "Selecione um tipo de destino final vlido."; }
                if (isFilled(rowData.tipo_tratamento)) { errors.tipo_tratamento = "Deve estar vazio quando 'Destino Final'  selecionado."; }
            }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    // --- ALTERAO AQUI: Renomeado Cabealho ---
    efluentes_domesticos: {
        displayName: "Efluentes Domsticos",
        hasUnits: true,
        headerDisplayNames: { 
            ano: "Ano", 
            periodo: "Perodo", 
            unidade_empresarial: "Unidade Empresarial", 
            tipo_trabalhador: "Tipo de Trabalhador", 
            num_trabalhadores: "N de Trabalhadores", 
            carga_horaria_media: "Carga Horria Mdia (h/dia)", 
            fossa_septica_propriedade: "Fossa sptica na propriedade da empresa?", // Renomeado
            comentarios: "Comentrios" 
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tipo_trabalhador: ["Interno", "Terceiro"],
            fossa_septica_propriedade: ["Sim", "No"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!this.validOptions.tipo_trabalhador.includes(rowData.tipo_trabalhador)) { errors.tipo_trabalhador = "Selecione 'Interno' ou 'Terceiro'."; }
            const numTrabalhadoresVal = rowData.num_trabalhadores;
            const numTrabalhadores = parseInt(numTrabalhadoresVal, 10);
            if (isNaN(numTrabalhadores) || numTrabalhadores <= 0 || String(numTrabalhadoresVal).includes('.') || String(numTrabalhadoresVal).includes(',')) { 
                errors.num_trabalhadores = `Entrada invlida ('${numTrabalhadoresVal}'). Insira um nmero inteiro e positivo.`;
            }
            const cargaHorariaVal = rowData.carga_horaria_media;
            const cargaHoraria = parseFloat(cargaHorariaVal);
            if (isNaN(cargaHoraria) || cargaHoraria <= 0) { errors.carga_horaria_media = `Entrada invlida ('${cargaHorariaVal}'). Insira um nmero maior que zero.`; }
            const normalizedFossa = normalizeString(rowData.fossa_septica_propriedade);
            if (['sim', 's'].includes(normalizedFossa)) { rowData.fossa_septica_propriedade = 'Sim'; } else if (['nao', 'n'].includes(normalizedFossa)) { rowData.fossa_septica_propriedade = 'No'; }
            if (!this.validOptions.fossa_septica_propriedade.includes(rowData.fossa_septica_propriedade)) { errors.fossa_septica_propriedade = "Deve ser 'Sim' ou 'No'."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    mudanca_uso_solo: {
        displayName: "Mudana do Uso do Solo",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Perodo", unidade_empresarial: "Unidade Organizacional", uso_solo_anterior: "Uso do Solo Anterior", bioma: "Bioma", fitofisionomia: "Fitofisionomia", tipo_area: "Tipo de rea", area_hectare: "rea (hectare)", comentarios: "Comentrios" },
        validOptions: { periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], uso_solo_anterior: ["Cultura anual", "Cultura de cana", "Cultura perene", "Pastagem", "Silvicultura", "Vegetao natural", "Assentamentos", "Outros usos"], bioma: ["Amaznia", "Cerrado", "Mata Atlntica", "Caatinga", "Pampa", "Pantanal"], tipo_area: ["rea de vegetao primria manejada", "rea de vegetao primria no manejada", "rea de vegetao secundria"] },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            
            const areaVal = rowData.area_hectare;
            const area = parseFloat(areaVal);
            if (isNaN(area) || area <= 0) { errors.area_hectare = `Entrada invlida ('${areaVal}'). Insira um nmero positivo.`; }

            if (!this.validOptions.uso_solo_anterior.includes(rowData.uso_solo_anterior)) { errors.uso_solo_anterior = "Selecione uma opo vlida."; }
            
            if (rowData.uso_solo_anterior === 'Vegetao natural') {
                if (!this.validOptions.bioma.includes(rowData.bioma)) { errors.bioma = "Bioma  obrigatrio para Vegetao Natural."; }
                if (!rowData.fitofisionomia) { errors.fitofisionomia = "Fitofisionomia  obrigatrio para Vegetao Natural."; }
                if (!this.validOptions.tipo_area.includes(rowData.tipo_area)) { errors.tipo_area = "Tipo de rea  obrigatrio para Vegetao Natural."; }
            } else {
                if (isFilled(rowData.bioma)) { errors.bioma = "Deve estar vazio se o uso do solo no for 'Vegetao natural'."; }
                if (isFilled(rowData.fitofisionomia)) { errors.fitofisionomia = "Deve estar vazio se o uso do solo no for 'Vegetao natural'."; }
                if (isFilled(rowData.tipo_area)) { errors.tipo_area = "Deve estar vazio se o uso do solo no for 'Vegetao natural'."; }
            }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    purchased_goods_services: {
        displayName: "Bens e Servios Comprados",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            descricao_item: "Descrio do Item",
            tipo_item: "Tipo de Item",
            quantidade: "Quantidade Adquirida",
            unidade: "Unidade de Medida",
            valor_aquisicao: "Valor da Aquisio (R$)",
            bens_terceiros: "Bens de Terceiros?",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tipo_item: ["Produto", "Servio"],
            unidade: ["Tonelada", "Quilo", "Unidade", "M", "Litro"],
            bens_terceiros: ["Sim", "No"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            // Validaes Bsicas
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.descricao_item) errors.descricao_item = "Obrigatrio.";
            
            // Validao de Tipo
            if (!this.validOptions.tipo_item.includes(rowData.tipo_item)) {
                errors.tipo_item = "Selecione 'Produto' ou 'Servio'.";
            }

            // Lgica Condicional: Produto vs Servio
            if (rowData.tipo_item === 'Produto') {
                const qtdVal = rowData.quantidade;
                if (!isFilled(qtdVal) || isNaN(parseFloat(qtdVal)) || parseFloat(qtdVal) <= 0) {
                    errors.quantidade = "Quantidade obrigatria para Produtos (nmero positivo).";
                }
                if (!this.validOptions.unidade.includes(rowData.unidade)) {
                    errors.unidade = "Selecione uma unidade vlida para Produtos.";
                }
            } else if (rowData.tipo_item === 'Servio') {
                if (isFilled(rowData.quantidade)) {
                    errors.quantidade = "Deve estar vazio para Servios.";
                }
                if (isFilled(rowData.unidade)) {
                    errors.unidade = "Deve estar vazio para Servios.";
                }
            }

            // Valor da Aquisio (Sempre Obrigatrio)
            const valorVal = rowData.valor_aquisicao;
            if (!isFilled(valorVal) || isNaN(parseFloat(valorVal)) || parseFloat(valorVal) <= 0) {
                errors.valor_aquisicao = "Valor obrigatrio e positivo.";
            }

            // Bens de Terceiros
            const normalizedTerceiros = normalizeString(rowData.bens_terceiros);
            if (['sim', 's'].includes(normalizedTerceiros)) { rowData.bens_terceiros = 'Sim'; } 
            else if (['nao', 'n'].includes(normalizedTerceiros)) { rowData.bens_terceiros = 'No'; }
            if (!this.validOptions.bens_terceiros.includes(rowData.bens_terceiros)) {
                errors.bens_terceiros = "Deve ser 'Sim' ou 'No'.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    capital_goods: {
        displayName: "Bens de Capital",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            bem_capital: "Bem de Capital Adquirido",
            quantidade: "Quantidade Adquirida",
            unidade: "Unidade",
            valor_aquisicao: "Valor da Aquisio (R$)",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.bem_capital) errors.bem_capital = "Obrigatrio.";

            // Inteiro e Positivo
            const qtdVal = rowData.quantidade;
            if (!isFilled(qtdVal) || isNaN(parseInt(qtdVal)) || parseInt(qtdVal) <= 0 || String(qtdVal).includes('.') || String(qtdVal).includes(',')) {
                errors.quantidade = "Quantidade deve ser um nmero inteiro positivo.";
            }

            // Unidade Fixa
            if (rowData.unidade !== 'Unidades') {
                errors.unidade = "A unidade deve ser 'Unidades'.";
            }

            // Float Positivo
            const valorVal = rowData.valor_aquisicao;
            if (!isFilled(valorVal) || isNaN(parseFloat(valorVal)) || parseFloat(valorVal) <= 0) {
                errors.valor_aquisicao = "Valor obrigatrio e positivo.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    upstream_transport: {
        displayName: "Logstica de Insumo",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            insumo_transportado: "Insumo Transportado",
            modal_transporte: "Modal de Transporte",
            tipo_reporte: "Tipo de Reporte (Consumo ou Distncia)",
            combustivel: "Combustvel",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustvel)",
            classificacao_veiculo: "Classificao do Veculo",
            distancia_trecho: "Distncia do Trecho",
            unidade_distancia: "Unidade (Distncia)",
            carga_transportada: "Carga Transportada (t)",
            numero_viagens: "Nmero de Viagens",
            local_embarque: "Local de Embarque",
            local_destino: "Local de Destino",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            modal_transporte: ["Transporte Martimo", "Transporte Ferrovirio", "Transporte Rodovirio"],
            tipo_reporte: ["Consumo", "Distncia"],
            combustivel: [
                "Gasolina Automotiva", "leo Diesel", "Gs Natural Veicular (GNV)", "Gs Natural Liquefeito (GNL)", 
                "Gs Liquefeito de Petrleo (GLP)", "Querosene de Aviao", "Gasolina de Aviao", "Lubrificantes", 
                "Metanol", "leo Combustvel", "Etanol Hidratado", "Biodiesel (B100)", "Biometano", 
                "Bioquerosene (SAF)", "HVO (diesel verde)", "Biometanol", "Etanol Anidro"
            ],
            classificacao_veiculo: [
                "Caminho - rgido (3,5 a 7,5 toneladas)", "Caminho - rgido (7,5 a 17 toneladas)", 
                "Caminho - rgido (acima de 17 toneladas)", "Caminho - rgido (mdia)", 
                "Caminho - articulado (3,5 a 33 toneladas)", "Caminho - articulado (acima de 33 toneladas)", 
                "Caminho - articulado (mdia)", "Caminho - caminho (mdia)", 
                "Caminho refrigerado - rgido (3,5 a 7,5 toneladas)", "Caminho refrigerado - rgido (7,5 a 17 toneladas)", 
                "Caminho refrigerado - rgido (acima de 17 toneladas)", "Caminho refrigerado - rgido (mdia)", 
                "Caminho refrigerado - articulado (3,5 a 33 toneladas)", "Caminho refrigerado - articulado (acima de 33 toneladas)", 
                "Caminho refrigerado - articulado (mdia)", "Caminho refrigerado - caminho (mdia)"
            ],
            unidade_distancia: ["km", "Milhas"]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Gasolina Automotiva": "Litros", "leo Diesel": "Litros", "Gs Natural Veicular (GNV)": "m", 
                    "Gs Natural Liquefeito (GNL)": "Litros", "Gs Liquefeito de Petrleo (GLP)": "kg", 
                    "Querosene de Aviao": "Litros", "Gasolina de Aviao": "Litros", "Lubrificantes": "Litros", 
                    "Metanol": "Litros", "leo Combustvel": "Litros", "Etanol Hidratado": "Litros", 
                    "Biodiesel (B100)": "Litros", "Biometano": "m", "Bioquerosene (SAF)": "Litros", 
                    "HVO (diesel verde)": "Litros", "Biometanol": "Litros", "Etanol Anidro": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            // Validaes Bsicas
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.insumo_transportado) errors.insumo_transportado = "Obrigatrio.";
            
            if (!this.validOptions.modal_transporte.includes(rowData.modal_transporte)) errors.modal_transporte = "Modal invlido.";
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo' ou 'Distncia'.";

            // Lgica Condicional
            if (rowData.tipo_reporte === 'Consumo') {
                // Campos de Consumo Obrigatrios
                if (!this.validOptions.combustivel.includes(rowData.combustivel)) errors.combustivel = "Selecione um combustvel vlido.";
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatrio e positivo.";
                
                // Validao de Unidade Automtica
                const expectedUnit = this.autoFillMap.combustivel.map[rowData.combustivel];
                if (rowData.combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Campos de Distncia devem ser vazios
                if (isFilled(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.distancia_trecho)) errors.distancia_trecho = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.carga_transportada)) errors.carga_transportada = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.numero_viagens)) errors.numero_viagens = "Deve ser vazio para reporte por Consumo.";
            
            } else if (rowData.tipo_reporte === 'Distncia') {
                // Campos de Distncia Obrigatrios
                if (!this.validOptions.classificacao_veiculo.includes(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Classificao de veculo invlida.";
                
                const distVal = rowData.distancia_trecho;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_trecho = "Distncia obrigatria e positiva.";
                
                if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) errors.unidade_distancia = "Selecione 'km' ou 'Milhas'.";
                
                const cargaVal = rowData.carga_transportada;
                if (!isFilled(cargaVal) || isNaN(parseFloat(cargaVal)) || parseFloat(cargaVal) <= 0) errors.carga_transportada = "Carga obrigatria e positiva (toneladas).";
                
                const viagensVal = rowData.numero_viagens;
                if (!isFilled(viagensVal) || isNaN(parseInt(viagensVal)) || parseInt(viagensVal) <= 0) errors.numero_viagens = "Nmero de viagens obrigatrio (inteiro).";

                // Campos de Consumo devem ser vazios
                if (isFilled(rowData.combustivel)) errors.combustivel = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distncia.";
            }

            if (!rowData.local_embarque) errors.local_embarque = "Local de embarque obrigatrio.";
            if (!rowData.local_destino) errors.local_destino = "Local de destino obrigatrio.";

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    business_travel_land: {
        displayName: "Viagens a Negcios Terrestres",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            descricao_viagem: "Descrio da Viagem",
            modal_viagem: "Modal de Viagem",
            tipo_reporte: "Tipo de Reporte (Consumo ou Distncia)",
            combustivel: "Combustvel",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustvel)",
            distancia_percorrida: "Distncia Percorrida",
            unidade_distancia: "Unidade (Distncia)",
            km_reembolsado: "Km Reembolsado?",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tipo_reporte: ["Consumo", "Distncia"],
            modal_viagem: [
                "Automvel a gasolina", "Automvel a etanol", "Automvel flex a gasolina", "Automvel flex a etanol", 
                "Motocicleta a gasolina", "Motocicleta flex a gasolina", "Motocicleta flex a etanol", 
                "Veculo comercial leve a gasolina", "Veculo comercial leve a etanol", "Veculo comercial leve flex a gasolina", 
                "Veculo comercial leve flex a etanol", "Veculo comercial leve a diesel", 
                "Micro-nibus a diesel", "nibus rodovirio a diesel", "nibus urbano a diesel", "Trem", "Metr"
            ],
            combustivel: [
                "Gasolina Automotiva", "leo Diesel", "Gs Natural Veicular (GNV)", "Gs Natural Liquefeito (GNL)", 
                "Gs Liquefeito de Petrleo (GLP)", "Querosene de Aviao", "Gasolina de Aviao", "Lubrificantes", 
                "Metanol", "leo Combustvel", "Etanol Hidratado", "Biodiesel (B100)", "Biometano", 
                "Bioquerosene (SAF)", "HVO (diesel verde)", "Biometanol", "Etanol Anidro"
            ],
            unidade_distancia: ["Km", "Milha"],
            km_reembolsado: ["Sim", "No"]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Gasolina Automotiva": "Litros", "leo Diesel": "Litros", "Gs Natural Veicular (GNV)": "m", 
                    "Gs Natural Liquefeito (GNL)": "Litros", "Gs Liquefeito de Petrleo (GLP)": "kg", 
                    "Querosene de Aviao": "Litros", "Gasolina de Aviao": "Litros", "Lubrificantes": "Litros", 
                    "Metanol": "Litros", "leo Combustvel": "Litros", "Etanol Hidratado": "Litros", 
                    "Biodiesel (B100)": "Litros", "Biometano": "m", "Bioquerosene (SAF)": "Litros", 
                    "HVO (diesel verde)": "Litros", "Biometanol": "Litros", "Etanol Anidro": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            // Validaes Bsicas
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.descricao_viagem) errors.descricao_viagem = "Obrigatrio.";
            
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo' ou 'Distncia'.";

            // CAMPOS GLOBAIS (Obrigatrios para AMBOS os tipos)
            if (!this.validOptions.modal_viagem.includes(rowData.modal_viagem)) errors.modal_viagem = "Modal de viagem invlido.";
            
            const normalizedKm = normalizeString(rowData.km_reembolsado);
            if (['sim', 's'].includes(normalizedKm)) { rowData.km_reembolsado = 'Sim'; } 
            else if (['nao', 'n'].includes(normalizedKm)) { rowData.km_reembolsado = 'No'; }
            if (!this.validOptions.km_reembolsado.includes(rowData.km_reembolsado)) errors.km_reembolsado = "Deve ser 'Sim' ou 'No'.";

            // Lgica Condicional (Especfica)
            if (rowData.tipo_reporte === 'Consumo') {
                // Consumo
                if (!this.validOptions.combustivel.includes(rowData.combustivel)) errors.combustivel = "Selecione um combustvel vlido.";
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatrio e positivo.";
                
                const expectedUnit = this.autoFillMap.combustivel.map[rowData.combustivel];
                if (rowData.combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Distncia deve ser vazio
                if (isFilled(rowData.distancia_percorrida)) errors.distancia_percorrida = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve ser vazio para reporte por Consumo.";
            
            } else if (rowData.tipo_reporte === 'Distncia') {
                // Distncia
                const distVal = rowData.distancia_percorrida;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_percorrida = "Distncia obrigatria e positiva.";
                
                if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) errors.unidade_distancia = "Selecione 'Km' ou 'Milha'.";

                // Consumo deve ser vazio
                if (isFilled(rowData.combustivel)) errors.combustivel = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distncia.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    downstream_transport: {
        displayName: "Logstica de Produto Final",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            insumo_transportado: "Insumo Transportado",
            modal_transporte: "Modal de Transporte",
            tipo_reporte: "Tipo de Reporte (Consumo ou Distncia)",
            combustivel: "Combustvel",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustvel)",
            classificacao_veiculo: "Classificao do Veculo",
            distancia_trecho: "Distncia do Trecho",
            unidade_distancia: "Unidade (Distncia)",
            carga_transportada: "Carga Transportada (t)",
            numero_viagens: "Nmero de Viagens",
            local_embarque: "Local de Embarque",
            local_destino: "Local de Destino",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            modal_transporte: ["Transporte Martimo", "Transporte Ferrovirio", "Transporte Rodovirio"],
            tipo_reporte: ["Consumo", "Distncia"],
            combustivel: [
                "leo Diesel", "Gasolina", "Gs Natural Veicular", "Gs Liquefeito de Petrleo", 
                "Querosene de Aviao", "Gasolina de Aviao", "Lubrificantes", 
                "leo combustvel residual", "Etanol", "Biodiesel"
            ],
            classificacao_veiculo: [
                "Caminho - rgido (3,5 a 7,5 toneladas)", "Caminho - rgido (7,5 a 17 toneladas)", 
                "Caminho - rgido (acima de 17 toneladas)", "Caminho - rgido (mdia)", 
                "Caminho - articulado (3,5 a 33 toneladas)", "Caminho - articulado (acima de 33 toneladas)", 
                "Caminho - articulado (mdia)", "Caminho - caminho (mdia)", 
                "Caminho refrigerado - rgido (3,5 a 7,5 toneladas)", "Caminho refrigerado - rgido (7,5 a 17 toneladas)", 
                "Caminho refrigerado - rgido (acima de 17 toneladas)", "Caminho refrigerado - rgido (mdia)", 
                "Caminho refrigerado - articulado (3,5 a 33 toneladas)", "Caminho refrigerado - articulado (acima de 33 toneladas)", 
                "Caminho refrigerado - articulado (mdia)", "Caminho refrigerado - caminho (mdia)"
            ],
            unidade_distancia: ["Km", "Milhas"]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "leo Diesel": "Litros", "Gasolina": "Litros", "Gs Natural Veicular": "m", 
                    "Gs Liquefeito de Petrleo": "kg", "Querosene de Aviao": "Litros", 
                    "Gasolina de Aviao": "Litros", "Lubrificantes": "Litros", 
                    "leo combustvel residual": "Litros", "Etanol": "Litros", "Biodiesel": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.insumo_transportado) errors.insumo_transportado = "Obrigatrio.";
            
            if (!this.validOptions.modal_transporte.includes(rowData.modal_transporte)) errors.modal_transporte = "Modal invlido.";
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo' ou 'Distncia'.";

            // Lgica Condicional
            if (rowData.tipo_reporte === 'Consumo') {
                // Campos de Consumo Obrigatrios
                if (!this.validOptions.combustivel.includes(rowData.combustivel)) errors.combustivel = "Selecione um combustvel vlido.";
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatrio e positivo.";
                
                // Validao de Unidade Automtica
                const expectedUnit = this.autoFillMap.combustivel.map[rowData.combustivel];
                if (rowData.combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Campos de Distncia devem ser vazios
                if (isFilled(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.distancia_trecho)) errors.distancia_trecho = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.carga_transportada)) errors.carga_transportada = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.numero_viagens)) errors.numero_viagens = "Deve ser vazio para reporte por Consumo.";
            
            } else if (rowData.tipo_reporte === 'Distncia') {
                // Campos de Distncia Obrigatrios
                if (!this.validOptions.classificacao_veiculo.includes(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Classificao de veculo invlida.";
                
                const distVal = rowData.distancia_trecho;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_trecho = "Distncia obrigatria e positiva.";
                
                if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) errors.unidade_distancia = "Selecione 'Km' ou 'Milhas'.";
                
                const cargaVal = rowData.carga_transportada;
                if (!isFilled(cargaVal) || isNaN(parseFloat(cargaVal)) || parseFloat(cargaVal) <= 0) errors.carga_transportada = "Carga obrigatria e positiva (toneladas).";
                
                const viagensVal = rowData.numero_viagens;
                if (!isFilled(viagensVal) || isNaN(parseInt(viagensVal)) || parseInt(viagensVal) <= 0) errors.numero_viagens = "Nmero de viagens obrigatrio (inteiro).";

                // Campos de Consumo devem ser vazios
                if (isFilled(rowData.combustivel)) errors.combustivel = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distncia.";
            }

            if (!rowData.local_embarque) errors.local_embarque = "Local de embarque obrigatrio.";
            if (!rowData.local_destino) errors.local_destino = "Local de destino obrigatrio.";

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    waste_transport: {
        displayName: "Logstica de Resduos",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            insumo_transportado: "Resduo Transportado",
            tipo_reporte: "Tipo de Reporte",
            combustivel: "Combustvel",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustvel)",
            classificacao_veiculo: "Classificao do Veculo",
            distancia_trecho: "Distncia do Trecho",
            unidade_distancia: "Unidade (Distncia)",
            carga_transportada: "Carga Transportada (t)",
            numero_viagens: "Nmero de Viagens",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tipo_reporte: ["Consumo", "Distncia"],
            combustivel: [
                "leo Diesel", "Gasolina", "Gs Natural Veicular", "Gs Liquefeito de Petrleo", 
                "Querosene de Aviao", "Gasolina de Aviao", "Lubrificantes", 
                "leo combustvel residual", "Etanol", "Biodiesel"
            ],
            classificacao_veiculo: [
                "Caminho - rgido (3,5 a 7,5 toneladas)", "Caminho - rgido (7,5 a 17 toneladas)", 
                "Caminho - rgido (acima de 17 toneladas)", "Caminho - rgido (mdia)", 
                "Caminho - articulado (3,5 a 33 toneladas)", "Caminho - articulado (acima de 33 toneladas)", 
                "Caminho - articulado (mdia)", "Caminho - caminho (mdia)", 
                "Caminho refrigerado - rgido (3,5 a 7,5 toneladas)", "Caminho refrigerado - rgido (7,5 a 17 toneladas)", 
                "Caminho refrigerado - rgido (acima de 17 toneladas)", "Caminho refrigerado - rgido (mdia)", 
                "Caminho refrigerado - articulado (3,5 a 33 toneladas)", "Caminho refrigerado - articulado (acima de 33 toneladas)", 
                "Caminho refrigerado - articulado (mdia)", "Caminho refrigerado - caminho (mdia)"
            ],
            unidade_distancia: ["Km", "Milhas"]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "leo Diesel": "Litros", "Gasolina": "Litros", "Gs Natural Veicular": "m", 
                    "Gs Liquefeito de Petrleo": "kg", "Querosene de Aviao": "Litros", 
                    "Gasolina de Aviao": "Litros", "Lubrificantes": "Litros", 
                    "leo combustvel residual": "Litros", "Etanol": "Litros", "Biodiesel": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.insumo_transportado) errors.insumo_transportado = "Obrigatrio.";
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo' ou 'Distncia'.";

            // Lgica Condicional
            if (rowData.tipo_reporte === 'Consumo') {
                if (!this.validOptions.combustivel.includes(rowData.combustivel)) errors.combustivel = "Selecione um combustvel vlido.";
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatrio e positivo.";
                
                // Validao de Unidade Automtica
                const expectedUnit = this.autoFillMap.combustivel.map[rowData.combustivel];
                if (rowData.combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Campos de Distncia devem ser vazios
                if (isFilled(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.distancia_trecho)) errors.distancia_trecho = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.carga_transportada)) errors.carga_transportada = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.numero_viagens)) errors.numero_viagens = "Deve ser vazio para reporte por Consumo.";
            
            } else if (rowData.tipo_reporte === 'Distncia') {
                if (!this.validOptions.classificacao_veiculo.includes(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Classificao de veculo invlida.";
                
                const distVal = rowData.distancia_trecho;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_trecho = "Distncia obrigatria e positiva.";
                
                if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) errors.unidade_distancia = "Selecione 'Km' ou 'Milhas'.";
                
                const cargaVal = rowData.carga_transportada;
                if (!isFilled(cargaVal) || isNaN(parseFloat(cargaVal)) || parseFloat(cargaVal) <= 0) errors.carga_transportada = "Carga obrigatria e positiva (toneladas).";
                
                const viagensVal = rowData.numero_viagens;
                if (!isFilled(viagensVal) || isNaN(parseInt(viagensVal)) || parseInt(viagensVal) <= 0) errors.numero_viagens = "Nmero de viagens obrigatrio (inteiro).";

                // Campos de Consumo devem ser vazios
                if (isFilled(rowData.combustivel)) errors.combustivel = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distncia.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    home_office: {
        displayName: "Home Office",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            regime_trabalho: "Regime de Trabalho (Dias)",
            num_funcionarios: "Nmero de Funcionrios",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            
            // Regime de Trabalho vem da descrio da fonte, ento  obrigatrio
            if (!rowData.regime_trabalho) errors.regime_trabalho = "Obrigatrio.";

            const numFuncVal = rowData.num_funcionarios;
            if (!isFilled(numFuncVal) || isNaN(parseInt(numFuncVal)) || parseInt(numFuncVal) <= 0 || String(numFuncVal).includes('.') || String(numFuncVal).includes(',')) {
                errors.num_funcionarios = "Deve ser um nmero inteiro e positivo.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    air_travel: {
        displayName: "Viagens Areas",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            descricao_viagem: "Descrio da Viagem",
            codigo_aeroporto_partida: "Cdigo do Aeroporto de Partida",
            codigo_aeroporto_chegada: "Cdigo do Aeroporto de Chegada",
            numero_viagens: "Nmero de Viagens",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.descricao_viagem) errors.descricao_viagem = "Obrigatrio.";

            if (!rowData.codigo_aeroporto_partida) errors.codigo_aeroporto_partida = "Obrigatrio.";
            if (!rowData.codigo_aeroporto_chegada) errors.codigo_aeroporto_chegada = "Obrigatrio.";

            const numViagensVal = rowData.numero_viagens;
            if (!isFilled(numViagensVal) || isNaN(parseInt(numViagensVal)) || parseInt(numViagensVal) <= 0 || String(numViagensVal).includes('.') || String(numViagensVal).includes(',')) {
                errors.numero_viagens = "Deve ser um nmero inteiro e positivo.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    employee_commuting: {
        displayName: "Transporte de Funcionrios",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            descricao_identificadora: "Identificao do Grupo",
            meio_utilizado: "Meio Utilizado",
            tipo_reporte: "Tipo de Reporte",
            tipo_combustivel: "Tipo de Combustvel",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustvel)",
            distancia_km: "Distncia (km)",
            endereco_funcionario: "Endereo Funcionrio",
            endereco_trabalho: "Endereo Trabalho",
            dias_deslocados: "Dias Deslocados (Opcional)",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            meio_utilizado: [
                "Transporte fretado - Van", "Transporte fretado - nibus de viagem", "Tranporte fretado - Automvel pequeno",
                "Transporte pblico - Metr", "Transporte pblico - nibus", "Transporte pblico - trem urbano",
                "Veculo prprio - automvel", "Veculo prprio - motocicleta", "Veculo prprio - bicicleta",
                "Uber", "Sem informao"
            ],
            tipo_reporte: ["Consumo", "Distncia", "Endereo"],
            tipo_combustivel: [
                "Gasolina Automotiva", "leo Diesel", "Gs Natural Veicular (GNV)", "Gs Natural Liquefeito (GNL)",
                "Gs Liquefeito de Petrleo (GLP)", "Querosene de Aviao", "Gasolina de Aviao", "Lubrificantes",
                "Metanol", "leo Combustvel", "Etanol Hidratado", "Biodiesel (B100)", "Biometano",
                "Bioquerosene (SAF)", "HVO (diesel verde)", "Biometanol", "Etanol Anidro"
            ]
        },
        autoFillMap: {
            tipo_combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Gasolina Automotiva": "litros", "leo Diesel": "litros", "Gs Natural Veicular (GNV)": "m",
                    "Gs Natural Liquefeito (GNL)": "litros", "Gs Liquefeito de Petrleo (GLP)": "kg",
                    "Querosene de Aviao": "litros", "Gasolina de Aviao": "litros", "Lubrificantes": "litros",
                    "Metanol": "litros", "leo Combustvel": "litros", "Etanol Hidratado": "litros",
                    "Biodiesel (B100)": "litros", "Biometano": "m", "Bioquerosene (SAF)": "litros",
                    "HVO (diesel verde)": "litros", "Biometanol": "litros", "Etanol Anidro": "litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.descricao_identificadora) errors.descricao_identificadora = "Obrigatrio.";
            
            if (!this.validOptions.meio_utilizado.includes(rowData.meio_utilizado)) errors.meio_utilizado = "Meio utilizado invlido.";
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo', 'Distncia' ou 'Endereo'.";

            // Lgica Condicional
            if (rowData.tipo_reporte === 'Consumo') {
                if (!this.validOptions.tipo_combustivel.includes(rowData.tipo_combustivel)) errors.tipo_combustivel = "Combustvel invlido.";
                
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatrio e positivo.";
                
                const expectedUnit = this.autoFillMap.tipo_combustivel.map[rowData.tipo_combustivel];
                if (rowData.tipo_combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Limpar outros campos
                if (isFilled(rowData.distancia_km)) errors.distancia_km = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.endereco_funcionario)) errors.endereco_funcionario = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.endereco_trabalho)) errors.endereco_trabalho = "Deve ser vazio para reporte por Consumo.";

            } else if (rowData.tipo_reporte === 'Distncia') {
                const distVal = rowData.distancia_km;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_km = "Distncia obrigatria e positiva.";

                // Limpar outros campos
                if (isFilled(rowData.tipo_combustivel)) errors.tipo_combustivel = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.endereco_funcionario)) errors.endereco_funcionario = "Deve ser vazio para reporte por Distncia.";
                if (isFilled(rowData.endereco_trabalho)) errors.endereco_trabalho = "Deve ser vazio para reporte por Distncia.";

            } else if (rowData.tipo_reporte === 'Endereo') {
                if (!rowData.endereco_funcionario) errors.endereco_funcionario = "Endereo do funcionrio obrigatrio.";
                if (!rowData.endereco_trabalho) errors.endereco_trabalho = "Endereo do trabalho obrigatrio.";

                // Limpar outros campos
                if (isFilled(rowData.tipo_combustivel)) errors.tipo_combustivel = "Deve ser vazio para reporte por Endereo.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Endereo.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Endereo.";
                if (isFilled(rowData.distancia_km)) errors.distancia_km = "Deve ser vazio para reporte por Endereo.";
            }

            // Dias Deslocados (Opcional, mas se preenchido deve ser inteiro positivo)
            const diasVal = rowData.dias_deslocados;
            if (isFilled(diasVal)) {
                if (isNaN(parseInt(diasVal)) || parseInt(diasVal) <= 0 || String(diasVal).includes('.') || String(diasVal).includes(',')) {
                    errors.dias_deslocados = "Deve ser um nmero inteiro positivo.";
                }
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    energy_generation: {
        displayName: "Gerao de Energia",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            // descricao_fonte REMOVIDO, pois o "fonte_geracao" atuar como identificador
            fonte_geracao: "Fonte de Gerao",
            total_geracao: "Total de Gerao",
            unidade_medida: "Unidade de Medida",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            fonte_geracao: ["Elica", "Solar", "Hidro", "Biomassa", "Carvo"],
            unidade_medida: ["KWh", "MWh"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            
            if (!this.validOptions.fonte_geracao.includes(rowData.fonte_geracao)) {
                errors.fonte_geracao = "Selecione uma fonte vlida.";
            }

            const totalVal = rowData.total_geracao;
            if (!isFilled(totalVal) || isNaN(parseFloat(totalVal)) || parseFloat(totalVal) < 0) {
                errors.total_geracao = `Entrada invlida ('${totalVal}'). Insira um nmero positivo ou zero.`;
            }

            if (!this.validOptions.unidade_medida.includes(rowData.unidade_medida)) {
                errors.unidade_medida = "Selecione 'KWh' ou 'MWh'.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    planted_forest: {
        displayName: "rea de Floresta Plantada",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Perodo",
            unidade_empresarial: "Unidade Empresarial",
            identificacao_area: "Identificao da rea",
            nome_especie: "Nome da Espcie",
            area_antepenultimo: "rea no final de {ANO-2} (ha)",
            idade_antepenultimo: "Faixa de idade em {ANO-2} (anos)",
            idade_penultimo: "Faixa de idade em {ANO-1} (anos)",
            area_colhida_penultimo: "rea Colhida/Desmatada em {ANO-1} (ha)",
            area_atual: "rea no final de {ANO} (ha)",
            comentarios: "Comentrios"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            nome_especie: ["Amaznia", "Cerrado", "Mata Atlntica", "Caatinga", "Pampa", "Pantanal"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dgitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Perodo invlido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatrio.";
            if (!rowData.identificacao_area) errors.identificacao_area = "Obrigatrio.";

            if (!this.validOptions.nome_especie.includes(rowData.nome_especie)) {
                errors.nome_especie = "Selecione uma espcie vlida.";
            }

            // Validao de Floats
            const floatFields = ['area_antepenultimo', 'area_colhida_penultimo', 'area_atual'];
            floatFields.forEach(field => {
                const val = rowData[field];
                if (isFilled(val)) {
                    if (isNaN(parseFloat(val)) || parseFloat(val) < 0) {
                        errors[field] = "Deve ser um nmero positivo.";
                    }
                }
            });

            // Validao de Inteiros
            const intFields = ['idade_antepenultimo', 'idade_penultimo'];
            intFields.forEach(field => {
                const val = rowData[field];
                if (isFilled(val)) {
                    if (isNaN(parseInt(val)) || parseInt(val) < 0 || String(val).includes('.') || String(val).includes(',')) {
                        errors[field] = "Deve ser um nmero inteiro positivo.";
                    }
                }
            });

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    }
};
</file>

<file path="frontend/assets.js">
// arquivo: frontend/assets.js


import { validationSchemas } from '../shared/validators.js';

document.addEventListener('DOMContentLoaded', () => {
    
    
    const assetSchemas = {
        electricity_purchase: {
            displayName: "Compra de Eletricidade",
            fields: {
                fonte_energia: { label: "Fonte de Energia (Descrio)", type: "select" },
                especificar_fonte: { label: "Especificar Fonte Padro", type: "select", showIf: { field: "fonte_energia", value: ["Mercado Livre Convencional", "Mercado Livre Incentivado", "Fonte Energtica Especfica"] } },
                unidade_medida: { label: "Unidade de Medida Padro", type: "select" }
            }
        },
        solid_waste: {
            displayName: "Resduos Slidos",
            fields: {
                destinacao_final: { label: "Destinao Final (Descrio)", type: "select" },
                tipo_residuo: { label: "Tipo de Resduo Padro", type: "select" },
                unidade: { label: "Unidade Padro", type: "select" },
                cidade_uf_destino: { label: "Cidade/UF de Destino", type: "text", placeholder: "Ex: Porto Alegre/RS", showIf: { field: "destinacao_final", value: "Aterro" } },
                local_controlado_empresa: { label: "Local Controlado pela Empresa?", type: "select" },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        purchased_goods_services: {
            displayName: "Bens e Servios Comprados",
            fields: {
                tipo_item: { label: "Tipo (Produto ou Servio) Padro", type: "select" },
                unidade: { label: "Unidade de Medida Padro", type: "select", showIf: { field: "tipo_item", value: "Produto" } },
                bens_terceiros: { label: "Bens comprados por terceiros? (Padro)", type: "select" },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        capital_goods: {
            displayName: "Bens de Capital",
            fields: {
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        upstream_transport: {
            displayName: "Logstica de Insumo",
            fields: {
                modal_transporte: { label: "Modal de Transporte Padro", type: "select" },
                tipo_reporte: { label: "Forma de Reporte Padro", type: "select" },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        downstream_transport: {
            displayName: "Logstica de Produto Final",
            fields: {
                insumo_transportado: { label: "Produto Transportado (Descrio)", type: "text" },
                modal_transporte: { label: "Modal de Transporte Padro", type: "select" },
                tipo_reporte: { label: "Forma de Reporte Padro", type: "select" },
                
                // Consumo
                combustivel: { label: "Combustvel Padro", type: "select", showIf: { field: "tipo_reporte", value: "Consumo" } },
                unidade_consumo: { label: "Unidade (Preenchimento Automtico)", type: "text", showIf: { field: "tipo_reporte", value: "Consumo" }, disabled: true },
                
                // Distncia
                classificacao_veiculo: { label: "Classificao do Veculo Padro", type: "select", showIf: { field: "tipo_reporte", value: "Distncia" } },
                unidade_distancia: { label: "Unidade de Distncia Padro", type: "select", showIf: { field: "tipo_reporte", value: "Distncia" } },

                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        waste_transport: {
            displayName: "Logstica de Resduos",
            fields: {
                insumo_transportado: { label: "Resduo Transportado (Descrio)", type: "text" },
                tipo_reporte: { label: "Forma de Reporte Padro", type: "select" },
                
                // Consumo
                combustivel: { label: "Combustvel Padro", type: "select", showIf: { field: "tipo_reporte", value: "Consumo" } },
                unidade_consumo: { label: "Unidade (Preenchimento Automtico)", type: "text", showIf: { field: "tipo_reporte", value: "Consumo" }, disabled: true },
                
                // Distncia
                classificacao_veiculo: { label: "Classificao do Veculo Padro", type: "select", showIf: { field: "tipo_reporte", value: "Distncia" } },
                unidade_distancia: { label: "Unidade de Distncia Padro", type: "select", showIf: { field: "tipo_reporte", value: "Distncia" } },

                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        home_office: {
            displayName: "Home Office",
            fields: {
                regime_trabalho: { 
                    label: "Dias da semana em Home Office (Regime)", 
                    type: "checkbox-group", 
                    options: ["Segunda", "Tera", "Quarta", "Quinta", "Sexta", "Sbado", "Domingo"]
                },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        air_travel: {
            displayName: "Viagens Areas",
            fields: {
                descricao_viagem: { label: "Descrio da Viagem (Grupo/Categoria)", type: "text", placeholder: "Ex: Viagens Comerciais, Diretoria..." },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        employee_commuting: {
            displayName: "Transporte de Funcionrios",
            fields: {
                meio_utilizado: { label: "Meio Utilizado (Descrio)", type: "select" },
                tipo_reporte: { label: "Forma de Reporte Padro", type: "select" },
                
                // Consumo
                tipo_combustivel: { label: "Combustvel Padro", type: "select", showIf: { field: "tipo_reporte", value: "Consumo" } },
                unidade_consumo: { label: "Unidade (Preenchimento Automtico)", type: "text", showIf: { field: "tipo_reporte", value: "Consumo" }, disabled: true },

                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        energy_generation: {
            displayName: "Gerao de Energia",
            fields: {
                fonte_geracao: { label: "Tipo de Fonte Padro", type: "select" },
                unidade_medida: { label: "Unidade de Medida Padro", type: "select" },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        // --- SPRINT 19: Floresta Plantada ---
        planted_forest: {
            displayName: "rea de Floresta Plantada",
            fields: {
                identificacao_area: { label: "Identificao da rea (Descrio)", type: "text", placeholder: "Ex: Talho A - Fazenda Norte" },
                nome_especie: { label: "Espcie Padro", type: "select" },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        // --- SPRINT 21: rea de Conservao (SEM DESCRIO MANUAL) ---
        conservation_area: {
            displayName: "rea de Conservao",
            fields: {
                // Bioma agora atua como "Descrio" na lista
                bioma: { label: "Bioma (Descrio)", type: "select" },
                fitofisionomia: { label: "Fitofisionomia", type: "select" }, 
                area_plantada: { label: "rea de conservao plantada?", type: "select" },
                plantio: { label: "Plantio", type: "text", placeholder: "Ex: 2010", showIf: { field: "area_plantada", value: "Sim" } },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        business_travel_land: {
            displayName: "Viagens a Negcios Terrestres",
            fields: {
                tipo_reporte: { label: "Forma de Reporte Padro", type: "select" },
                
                // Campos GLOBAIS
                modal_viagem: { label: "Modal de Viagem Padro", type: "select" },
                km_reembolsado: { label: "Reembolso de Km (Padro)?", type: "select" },
                
                // Campos Especficos para Consumo
                combustivel: { label: "Combustvel Padro", type: "select", showIf: { field: "tipo_reporte", value: "Consumo" } }, 
                unidade_consumo: { label: "Unidade (Preenchimento Automtico)", type: "text", showIf: { field: "tipo_reporte", value: "Consumo" }, disabled: true }, 

                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        combustao_estacionaria: { 
            displayName: "Combusto Estacionria", 
            fields: { 
                combustivel_estacionario: { label: "Combustvel Padro", type: "select" },
                unidade: { label: "Unidade de Consumo", type: "text", disabled: true },
                controlado_empresa: { label: "Controlado pela Empresa?", type: "select", options: ["Sim", "No"] }
            } 
        },
        combustao_movel: { 
            displayName: "Combusto Mvel", 
            fields: { 
                tipo_entrada: { label: "Como os dados sero reportados?", type: "select" }, 
                combustivel: { label: "Combustvel Padro", type: "select", showIf: { field: "tipo_entrada", value: "consumo" } }, 
                unidade_consumo: { label: "Unidade de Consumo", type: "text", showIf: { field: "tipo_entrada", value: "consumo" }, disabled: true }, 
                tipo_veiculo: { label: "Tipo de Veculo Padro", type: "select", showIf: { field: "tipo_entrada", value: "distancia" } },
                controlado_empresa: { label: "Controlado pela Empresa?", type: "select", options: ["Sim", "No"] }
            } 
        },
        dados_producao_venda: { 
            displayName: "Dados de Produo e Venda", 
            fields: { 
                unidade_medida: { label: "Unidade de Medida Padro", type: "text" } 
            } 
        },
        ippu_lubrificantes: { 
            displayName: "IPPU - Lubrificantes", 
            fields: { 
                tipo_lubrificante: { label: "Tipo de Lubrificante Padro", type: "select" }, 
                unidade: { label: "Unidade de Consumo Padro", type: "text", disabled: true },
                controlado_empresa: { label: "Controlado pela Empresa?", type: "select", options: ["Sim", "No"] }
            } 
        },
        emissoes_fugitivas: { 
            displayName: "Emisses Fugitivas", 
            fields: { 
                tipo_gas: { label: "Gs Padro", type: "select" },
                controlado_empresa: { label: "Controlado pela Empresa?", type: "select", options: ["Sim", "No"] }
            } 
        },
        fertilizantes: { 
            displayName: "Fertilizantes", 
            fields: { 
                percentual_nitrogenio: { label: "Percentual de Nitrognio Padro (%)", type: "number", min: 0, max: 100, step: 0.01 }, 
                percentual_carbonato: { label: "Percentual de Carbonato Padro (%)", type: "number", min: 0, max: 100, step: 0.01 },
                controlado_empresa: { label: "Controlado pela Empresa?", type: "select", options: ["Sim", "No"] }
            } 
        },
        efluentes_controlados: {
            displayName: "Efluentes Controlados",
            fields: {
                tratamento_ou_destino: { label: "Tratamento ou Destino Final (Padro)?", type: "select" },
                tipo_tratamento: { label: "Tipo de Tratamento Padro", type: "select", showIf: { field: "tratamento_ou_destino", value: "Tratamento" } },
                tipo_destino_final: { label: "Tipo de Destino Final Padro", type: "select", showIf: { field: "tratamento_ou_destino", value: "Destino Final" } },
                unidade_componente_organico: { label: "Unidade Padro (Componente Orgnico)", type: "select" }
            }
        },
        // --- ATUALIZADO AQUI (Efluentes Domsticos) ---
        efluentes_domesticos: {
            displayName: "Efluentes Domsticos",
            fields: {
                tipo_trabalhador: { label: "Tipo de Trabalhador (Descrio)", type: "select", options: ["Interno", "Terceiro"] },
                fossa_septica_propriedade: { label: "Fossa sptica na propriedade da empresa?", type: "select", options: ["Sim", "No"] },
                responsible_contact_id: { label: "Responsvel pela Informao", type: "select", isContact: true }
            }
        },
        mudanca_uso_solo: {
            displayName: "Mudana do Uso do Solo",
            fields: {
                uso_solo_anterior: { label: "Uso do Solo Anterior (Padro)", type: "select" },
                bioma: { label: "Bioma Padro", type: "select", showIf: { field: "uso_solo_anterior", value: "Vegetao natural" } },
                fitofisionomia: { label: "Fitofisionomia Padro", type: "text", showIf: { field: "uso_solo_anterior", value: "Vegetao natural" } },
                tipo_area: { label: "Tipo de rea Padro", type: "select", showIf: { field: "uso_solo_anterior", value: "Vegetao natural" } }
            }
        }
    };
    
    const navPlaceholder = document.getElementById('nav-placeholder');
    const sourceSelector = document.getElementById('source-selector');
    const assetManagementSection = document.getElementById('asset-management-section');
    const form = document.getElementById('asset-form');
    const assetIdInput = document.getElementById('asset-id');
    const specificFieldsContainer = document.getElementById('specific-fields-container');
    const assetsThead = document.getElementById('assets-thead');
    const assetsTbody = document.getElementById('assets-tbody');
    const formTitle = document.getElementById('form-title');
    const tableTitle = document.getElementById('table-title');
    const cancelBtn = document.getElementById('cancel-btn');
    const unitSelect = document.getElementById('asset-unit');
    let currentSourceType = null;
    let contactsList = [];

    async function initializePage() { 
        if (navPlaceholder) { 
            fetch('nav.html').then(response => response.text()).then(data => { navPlaceholder.innerHTML = data; }); 
        } 
        const sortedSourceTypes = Object.keys(assetSchemas).sort((a, b) => 
            assetSchemas[a].displayName.localeCompare(assetSchemas[b].displayName)
        );
        sortedSourceTypes.forEach(sourceType => {
            const option = document.createElement('option');
            option.value = sourceType;
            option.textContent = assetSchemas[sourceType].displayName;
            sourceSelector.appendChild(option);
        });
        
        try { 
            const [unitsResponse, contactsResponse] = await Promise.all([ 
                fetch('/api/units'), 
                fetch('/api/contacts') 
            ]); 
            const unitsList = await unitsResponse.json(); 
            contactsList = await contactsResponse.json();
            
            unitSelect.innerHTML = '<option value="">-- Selecione --</option>'; 
            if (unitsList.length > 1) { 
                const allUnitsOption = document.createElement('option'); 
                allUnitsOption.value = 'all'; 
                allUnitsOption.textContent = '*** TODAS AS UNIDADES ***'; 
                unitSelect.appendChild(allUnitsOption); 
            } 
            unitsList.forEach(unit => { 
                const option = document.createElement('option'); 
                option.value = unit.id; 
                option.textContent = unit.name; 
                unitSelect.appendChild(option); 
            }); 
        } catch (error) { 
            console.error("Erro na inicializao da pgina:", error); 
        } 
    }
    
    async function handleSourceSelection() { 
        currentSourceType = sourceSelector.value; 
        resetForm(); 
        if (!currentSourceType) { 
            assetManagementSection.style.display = 'none'; 
            return; 
        } 
        const schema = assetSchemas[currentSourceType]; 
        formTitle.textContent = `Adicionar Nova Fonte`; 
        tableTitle.textContent = `Fontes de ${schema.displayName} Cadastradas`; 
        await buildDynamicForm(schema); 
        buildDynamicTableHeaders(schema); 
        loadAssetTypologies(); 
        assetManagementSection.style.display = 'block'; 
    }
    
    function buildDynamicTableHeaders(schema) { 
        assetsThead.innerHTML = ''; 
        const headerRow = document.createElement('tr'); 
        
        // --- Lista de Schemas que usam Descrio Customizada (ATUALIZADA) ---
        // Adicionado 'efluentes_domesticos'
        const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area', 'efluentes_controlados', 'efluentes_domesticos'].includes(currentSourceType);
        const mainDescriptionKey = usesCustomDescription ? Object.keys(schema.fields)[0] : 'description';
        const mainDescriptionLabel = usesCustomDescription ? schema.fields[mainDescriptionKey].label : 'Descrio';

        let headers = `<th>${mainDescriptionLabel}</th><th>Unidade</th><th>Frequncia</th>`; 
        
        for (const key in schema.fields) { 
            if (usesCustomDescription && key === mainDescriptionKey) continue;
            headers += `<th>${schema.fields[key].label}</th>`; 
        } 
        headers += '<th>Aes</th>'; 
        headerRow.innerHTML = headers; 
        assetsThead.appendChild(headerRow); 
    }
    
    async function loadAssetTypologies() { 
        if (!currentSourceType) return; 
        try { 
            const response = await fetch(`/api/asset-typologies?source_type=${currentSourceType}`); 
            const typologies = await response.json(); 
            assetsTbody.innerHTML = ''; 
            typologies.forEach(typo => { 
                const tr = document.createElement('tr'); 
                
                // --- Lista de Schemas que usam Descrio Customizada (ATUALIZADA) ---
                const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area', 'efluentes_controlados', 'efluentes_domesticos'].includes(currentSourceType);
                const mainDescriptionKey = usesCustomDescription ? Object.keys(assetSchemas[currentSourceType].fields)[0] : 'description';

                const mainDescription = usesCustomDescription 
                    ? (typo.asset_fields[mainDescriptionKey] || typo.description) 
                    : typo.description;
                
                // Lgica de limpeza de dados para exibio
                const displayFields = { ...typo.asset_fields };
                if (currentSourceType === 'combustao_movel') {
                    const tipoEntrada = displayFields.tipo_entrada;
                    if (tipoEntrada === 'consumo') {
                        displayFields.tipo_veiculo = ''; 
                    } else if (tipoEntrada === 'distancia') {
                        displayFields.combustivel = ''; 
                        displayFields.unidade_consumo = '';
                    }
                } else if (currentSourceType === 'business_travel_land') {
                     const tipoReporte = displayFields.tipo_reporte;
                     if (tipoReporte === 'Consumo') {
                         // modal e reembolso so globais
                     } else if (tipoReporte === 'Distncia') {
                         displayFields.combustivel = '';
                         displayFields.unidade_consumo = '';
                     }
                } else if (currentSourceType === 'downstream_transport' || currentSourceType === 'waste_transport') {
                     const tipoReporte = displayFields.tipo_reporte;
                     if (tipoReporte === 'Consumo') {
                         displayFields.classificacao_veiculo = '';
                         displayFields.unidade_distancia = '';
                     } else if (tipoReporte === 'Distncia') {
                         displayFields.combustivel = '';
                         displayFields.unidade_consumo = '';
                     }
                } else if (currentSourceType === 'employee_commuting') {
                     const tipoReporte = displayFields.tipo_reporte;
                     if (tipoReporte === 'Consumo') {
                         // Mantm combustvel
                     } else if (tipoReporte === 'Distncia') {
                         displayFields.tipo_combustivel = '';
                         displayFields.unidade_consumo = '';
                     } else if (tipoReporte === 'Endereo') {
                         displayFields.tipo_combustivel = '';
                         displayFields.unidade_consumo = '';
                     }
                }
                
                const frequencyText = typo.reporting_frequency === 'mensal' ? 'Mensal' : 'Anual';
                let rowHtml = `<td>${mainDescription}</td><td>${typo.unit_name}</td><td>${frequencyText}</td>`; 
                const schema = assetSchemas[currentSourceType]; 
                
                for (const key in schema.fields) { 
                    if (usesCustomDescription && key === mainDescriptionKey) continue;
                    if (key === 'responsible_contact_id') {
                        rowHtml += `<td>${typo.responsible_contact_name || ''}</td>`;
                    } else {
                        rowHtml += `<td>${displayFields[key] || ''}</td>`; 
                    }
                } 
                rowHtml += `<td> <button class="action-btn edit-btn" data-id="${typo.id}">Editar</button> <button class="action-btn delete-btn" data-id="${typo.id}">Deletar</button> </td>`; 
                tr.innerHTML = rowHtml; 
                assetsTbody.appendChild(tr); 
            }); 
        } catch (error) { 
            console.error("Erro ao carregar tipologias:", error); 
        } 
    }
    
    async function handleFormSubmit(e) { 
        e.preventDefault(); 
        const id = assetIdInput.value; 
        const asset_fields = {}; 
        
        let responsibleContactId = null;
        let reportingFrequency = document.getElementById('reporting-frequency').value;

        form.querySelectorAll('[data-key]').forEach(input => {
             const fieldWrapper = input.closest('.form-group');
             if (fieldWrapper && fieldWrapper.style.display !== 'none') {
                 const key = input.dataset.key;
                 if (key === 'responsible_contact_id') {
                     responsibleContactId = input.value;
                 } else if (key !== 'reporting_frequency') {
                     asset_fields[key] = input.value;
                 }
             }
        });

        // --- VALIDAO ESPECFICA PARA FERTILIZANTES ---
        if (currentSourceType === 'fertilizantes') {
            const percN = parseFloat(asset_fields.percentual_nitrogenio) || 0;
            const percC = parseFloat(asset_fields.percentual_carbonato) || 0;
            if ((percN + percC) > 100) {
                alert(`A soma das porcentagens (${(percN + percC).toFixed(2)}%) excede 100%. Por favor, corrija os valores.`);
                return; // Interrompe o salvamento
            }
        }

        // --- Lista de Schemas que usam Descrio Customizada (ATUALIZADA) ---
        const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area', 'efluentes_controlados', 'efluentes_domesticos'].includes(currentSourceType);
        const mainDescriptionKey = usesCustomDescription ? Object.keys(assetSchemas[currentSourceType].fields)[0] : null;

        const descriptionValue = usesCustomDescription
            ? asset_fields[mainDescriptionKey]
            : document.getElementById('asset-description').value;
        
        const unitValue = document.getElementById('asset-unit').value; 
        const data = { 
            description: descriptionValue, 
            unit_id: unitValue, 
            source_type: currentSourceType, 
            asset_fields: asset_fields,
            responsible_contact_id: responsibleContactId,
            reporting_frequency: reportingFrequency
        }; 
        
        const method = id ? 'PUT' : 'POST'; 
        const url = id ? `/api/asset-typologies/${id}` : '/api/asset-typologies'; 
        try { 
            const response = await fetch(url, { method: method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }); 
            if (!response.ok) { 
                const errorData = await response.json(); 
                throw new Error(errorData.error || 'Falha ao salvar a fonte.'); 
            } 
            
            if (id) {
                resetForm();
            } else {
                assetIdInput.value = '';
            }
            
            loadAssetTypologies(); 
        } catch (error) { 
            console.error("Erro ao salvar:", error); 
            alert(`Ocorreu um erro ao salvar: ${error.message}`); 
        } 
    }
    
    async function handleTableClick(e) {
        const target = e.target;
        const id = target.dataset.id;
        if (!id) return;

        if (target.classList.contains('edit-btn')) {
            const response = await fetch(`/api/asset-typologies?source_type=${currentSourceType}`);
            const typologies = await response.json();
            const typoToEdit = typologies.find(t => t.id == id);
            
            if (typoToEdit) {
                assetIdInput.value = typoToEdit.id;
                
                // --- Lista de Schemas que usam Descrio Customizada (ATUALIZADA) ---
                const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area', 'efluentes_controlados', 'efluentes_domesticos'].includes(currentSourceType);
                if (!usesCustomDescription) {
                    document.getElementById('asset-description').value = typoToEdit.description;
                }
                
                document.getElementById('asset-unit').value = typoToEdit.unit_id;
                
                await buildDynamicForm(assetSchemas[currentSourceType]); 
                
                document.getElementById('reporting-frequency').value = typoToEdit.reporting_frequency;

                form.querySelectorAll('[data-key]').forEach(input => {
                    const key = input.dataset.key;
                    if (key === 'responsible_contact_id') {
                        input.value = typoToEdit.responsible_contact_id || '';
                    } else if (typoToEdit.asset_fields[key] !== undefined) {
                        input.value = typoToEdit.asset_fields[key];
                        
                        // Lgica especial para checkbox-group
                        if (assetSchemas[currentSourceType].fields[key].type === 'checkbox-group') {
                            const selectedValues = (typoToEdit.asset_fields[key] || '').split(', ');
                            const container = input.closest('.form-group');
                            container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                                cb.checked = selectedValues.includes(cb.value);
                            });
                        }
                    }
                        
                    const conditionalTriggers = ['tipo_entrada', 'tratamento_ou_destino', 'uso_solo_anterior', 'destinacao_final', 'fonte_energia', 'tipo_item', 'tipo_reporte', 'combustivel', 'tipo_combustivel', 'area_plantada', 'bioma', 'tipo_lubrificante'];
                    if (conditionalTriggers.includes(key)) {
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });

                formTitle.textContent = `Editando Fonte: ${typoToEdit.description}`;
                cancelBtn.style.display = 'inline-block';
                window.scrollTo(0,0);
            }
        } else if (target.classList.contains('delete-btn')) {
            if (confirm('Tem certeza que deseja deletar esta fonte?')) {
                try {
                    await fetch(`/api/asset-typologies/${id}`, { method: 'DELETE' });
                    loadAssetTypologies();
                } catch (error) {
                    console.error("Erro ao deletar:", error);
                    alert('Ocorreu um erro ao deletar. Verifique o console.');
                }
            }
        }
    }
    
    function resetForm() {
        form.reset();
        assetIdInput.value = '';
        if (currentSourceType) {
            formTitle.textContent = `Adicionar Nova Fonte`;
        }
        cancelBtn.style.display = 'none';

        const descriptionGroup = document.getElementById('asset-description').parentElement;
        // --- Lista de Schemas que usam Descrio Customizada (ATUALIZADA) ---
        const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area', 'efluentes_controlados', 'efluentes_domesticos'].includes(currentSourceType);

        if (usesCustomDescription) {
            descriptionGroup.style.display = 'none';
            descriptionGroup.querySelector('input').required = false;
        } else {
            descriptionGroup.style.display = '';
            descriptionGroup.querySelector('input').required = true;
        }

        const triggerFields = ['field-tipo_entrada', 'field-tratamento_ou_destino', 'uso_solo_anterior', 'field-combustivel', 'field-combustivel_estacionario', 'field-destinacao_final', 'field-fonte_energia', 'field-tipo_item', 'field-tipo_reporte', 'field-tipo_combustivel', 'field-area_plantada', 'field-bioma', 'field-tipo_lubrificante'];
        triggerFields.forEach(id => {
            const trigger = document.getElementById(id);
            if (trigger) trigger.dispatchEvent(new Event('change'));
        });
        
        // Resetar checkboxes
        form.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
    }

    async function buildDynamicForm(schema) { 
        specificFieldsContainer.innerHTML = '';
        form.querySelectorAll('.dynamic-field').forEach(el => el.remove()); 
        
        const fieldElements = {};
        const triggerFields = new Set();
        const autoFillTriggers = new Set();
        // --- Lista de Schemas que usam Descrio Customizada (ATUALIZADA) ---
        const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area', 'efluentes_controlados', 'efluentes_domesticos'].includes(currentSourceType);
        
        const firstRowContainer = document.querySelector('#asset-form .form-row');
        const descriptionFieldGroup = document.getElementById('asset-description').parentElement;

        const validationSchema = validationSchemas[currentSourceType];
        
        if (validationSchema && validationSchema.autoFillMap) {
            Object.keys(validationSchema.autoFillMap).forEach(key => autoFillTriggers.add(key));
        }

        let dependencyConfig = null;
        if (validationSchema && validationSchema.dependencyMap) {
            dependencyConfig = validationSchema.dependencyMap;
            triggerFields.add(dependencyConfig.triggerField);
        }

        for (const key in schema.fields) {
            if (schema.fields[key].showIf) {
                triggerFields.add(schema.fields[key].showIf.field);
            }
        }
        
        const frequencyWrapper = document.createElement('div');
        frequencyWrapper.className = 'form-row dynamic-field';
        frequencyWrapper.innerHTML = `
            <div class="form-group">
                <label for="reporting-frequency">Frequncia de Reporte</label>
                <select id="reporting-frequency" data-key="reporting_frequency">
                    <option value="anual">Anual</option>
                    <option value="mensal">Mensal</option>
                </select>
            </div>
        `;
        specificFieldsContainer.appendChild(frequencyWrapper);


        for (const key in schema.fields) { 
            const field = schema.fields[key]; 
            const wrapper = document.createElement('div');
            wrapper.className = 'form-group dynamic-field';
            wrapper.id = `row-${key}`; 
            
            const label = document.createElement('label'); 
            label.setAttribute('for', `field-${key}`); 
            label.textContent = field.label; 
            
            let input; 
            
            if (field.type === 'select') {
                input = document.createElement('select');
            } else if (field.type === 'checkbox-group') {
                input = document.createElement('input');
                input.type = 'hidden'; 
                
                const checkboxContainer = document.createElement('div');
                checkboxContainer.style.display = 'flex';
                checkboxContainer.style.flexWrap = 'wrap';
                checkboxContainer.style.gap = '10px';
                checkboxContainer.style.marginTop = '5px';

                field.options.forEach(opt => {
                    const cbWrapper = document.createElement('div');
                    cbWrapper.style.display = 'flex';
                    cbWrapper.style.alignItems = 'center';
                    
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.value = opt;
                    cb.id = `cb-${key}-${opt}`;
                    cb.style.marginRight = '5px';
                    
                    const cbLabel = document.createElement('label');
                    cbLabel.htmlFor = `cb-${key}-${opt}`;
                    cbLabel.textContent = opt;
                    cbLabel.style.fontWeight = 'normal';
                    cbLabel.style.marginBottom = '0';

                    cb.addEventListener('change', () => {
                        const checkedOptions = Array.from(checkboxContainer.querySelectorAll('input[type="checkbox"]:checked'))
                                                    .map(c => c.value);
                        input.value = checkedOptions.join(', ');
                    });

                    cbWrapper.appendChild(cb);
                    cbWrapper.appendChild(cbLabel);
                    checkboxContainer.appendChild(cbWrapper);
                });
                
                wrapper.appendChild(label);
                wrapper.appendChild(checkboxContainer);
            } else { 
                input = document.createElement('input'); 
                input.type = field.type || 'text';
                if(field.placeholder) input.placeholder = field.placeholder;
            }
            
            input.id = `field-${key}`; 
            input.dataset.key = key; 
            input.required = !field.showIf && field.type !== 'checkbox-group'; 
            if (field.disabled) input.disabled = true;

            if (field.type === 'select') {
                input.innerHTML = '<option value="">-- Selecione --</option>';

                if (field.isContact) {
                    contactsList.forEach(contact => {
                        const option = document.createElement('option');
                        option.value = contact.id;
                        option.textContent = `${contact.name} (${contact.unit_name || 'N/A'})`;
                        input.appendChild(option);
                    });
                } else {
                    const displayMap = validationSchema.displayValueMap?.[key];
                    const options = validationSchema.validOptions?.[key] || field.options || [];

                    options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = (displayMap && displayMap[opt]) ? displayMap[opt] : opt;
                        input.appendChild(option);
                    });
                }
            }
            
            fieldElements[key] = { row: wrapper, input: input, config: field };

            if (field.type !== 'checkbox-group') {
                wrapper.appendChild(label); 
                wrapper.appendChild(input); 
            } else {
                wrapper.appendChild(input); 
            }

            const mainDescriptionKey = usesCustomDescription ? Object.keys(schema.fields)[0] : null;

            if (usesCustomDescription && key === mainDescriptionKey) {
                firstRowContainer.insertBefore(wrapper, descriptionFieldGroup);
            } else {
                let targetRow = Array.from(specificFieldsContainer.querySelectorAll('.form-row.dynamic-field')).pop();
                if (!targetRow || targetRow.children.length >= 2) {
                    targetRow = document.createElement('div');
                    targetRow.className = 'form-row dynamic-field';
                    specificFieldsContainer.appendChild(targetRow);
                }
                wrapper.className = 'form-group dynamic-field';
                targetRow.appendChild(wrapper);
            }


            if (triggerFields.has(key) || autoFillTriggers.has(key)) {
                input.addEventListener('change', () => {
                    const selectedValue = input.value;
                    
                    // Lgica ShowIf
                    for (const fieldKey in fieldElements) {
                        const element = fieldElements[fieldKey];
                        const showIfConfig = element.config.showIf;
                        
                        if (showIfConfig && showIfConfig.field === key) {
                            const conditionValues = Array.isArray(showIfConfig.value) ? showIfConfig.value : [showIfConfig.value];
                            const isVisible = conditionValues.includes(selectedValue);
                            
                            element.row.style.display = isVisible ? '' : 'none';
                            element.input.required = isVisible;
                        }
                    }

                    // Lgica AutoFill
                    if (autoFillTriggers.has(key)) {
                        const rule = validationSchema.autoFillMap[key];
                        const targetValue = rule.map[selectedValue];
                        const targetField = fieldElements[rule.targetColumn];
                        if (targetField && targetValue !== undefined) {
                            targetField.input.value = targetValue;
                        } else if (targetField) {
                            targetField.input.value = '';
                        }
                    }

                    // Lgica de Dependncia (Dropdown Dinmico)
                    if (dependencyConfig && dependencyConfig.triggerField === key) {
                        const targetFieldKey = dependencyConfig.targetField;
                        const targetElement = fieldElements[targetFieldKey];
                        
                        if (targetElement && targetElement.input.tagName === 'SELECT') {
                            targetElement.input.innerHTML = '<option value="">-- Selecione --</option>';
                            const dependentOptions = dependencyConfig.data[selectedValue];
                            if (dependentOptions && Array.isArray(dependentOptions)) {
                                dependentOptions.forEach(opt => {
                                    const option = document.createElement('option');
                                    option.value = opt;
                                    option.textContent = opt;
                                    targetElement.input.appendChild(option);
                                });
                            }
                        }
                    }
                });
            }
        }
        
        new Set([...triggerFields, ...autoFillTriggers]).forEach(triggerKey => {
            const triggerElement = fieldElements[triggerKey];
            if (triggerElement) {
                triggerElement.input.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
        
        resetForm();
    }
    
    sourceSelector.addEventListener('change', handleSourceSelection);
    form.addEventListener('submit', handleFormSubmit);
    assetsTbody.addEventListener('click', handleTableClick);
    cancelBtn.addEventListener('click', resetForm);
    
    initializePage();
});
</file>

<file path="backend/server.js">
// arquivo: backend/server.js

// --- 1. IMPORTAES ---
const express = require('express');
const cors = require('cors');
const path = require('path');
const multer = require('multer');
const csv = require('csv-parser');
const xlsx = require('xlsx');
const fs = require('fs');
const bcrypt = require('bcrypt');
const db = require('./database.js'); 
const { validationSchemas } = require('../shared/validators.js');

// --- 2. CONFIGURAES ---
const app = express();
const PORT = process.env.PORT || 8080;
const saltRounds = 10;
const upload = multer({ dest: path.join(__dirname, 'uploads/') });

// --- 3. MIDDLEWARES ---
app.use(cors());
app.use(express.json());
const frontendPath = path.join(__dirname, '..', 'frontend');
app.use(express.static(frontendPath));
const sharedPath = path.join(__dirname, '..', 'shared');
app.use('/shared', express.static(sharedPath));

app.use((req, res, next) => {
    if (req.path.endsWith('.js')) res.contentType('text/javascript');
    next();
});

// --- 4. ROTA PRINCIPAL ---
app.get('/', (req, res) => {
    res.sendFile(path.join(frontendPath, 'login.html'));
});

// --- 5. ROTAS DA API ---

// Rotas de Autenticao
app.post('/api/register', async (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({ message: "Email e senha so obrigatrios." });
    }
    try {
        const hashedPassword = await bcrypt.hash(password, saltRounds);
        const sql = "INSERT INTO users (email, password) VALUES (?, ?)";
        db.run(sql, [email, hashedPassword], function(err) {
            if (err) {
                if (err.message.includes('UNIQUE constraint failed')) {
                    return res.status(409).json({ message: "E-mail j cadastrado." });
                }
                return res.status(500).json({ message: "Erro ao registrar usurio.", error: err.message });
            }
            res.status(201).json({ message: "Usurio registrado com sucesso!", userId: this.lastID });
        });
    } catch (error) {
        res.status(500).json({ message: "Erro interno no servidor.", error: error.message });
    }
});

app.post('/api/login', (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({ message: "Email e senha so obrigatrios." });
    }
    const sql = "SELECT * FROM users WHERE email = ?";
    db.get(sql, [email], (err, user) => {
        if (err) {
            return res.status(500).json({ message: "Erro no servidor.", error: err.message });
        }
        if (!user) {
            return res.status(404).json({ message: "Usurio no encontrado." });
        }
        bcrypt.compare(password, user.password, (err, result) => {
            if (err) {
                return res.status(500).json({ message: "Erro ao verificar senha.", error: err.message });
            }
            if (result) {
                res.status(200).json({ message: "Login bem-sucedido!" });
            } else {
                res.status(401).json({ message: "Senha incorreta." });
            }
        });
    });
});

// Rotas de Contatos (Responsveis)
app.get('/api/contacts', (req, res) => {
    const sqlContacts = `
        SELECT 
            c.id, c.name, c.unit_id, c.email, c.phone,
            u.name as unit_name 
        FROM contacts c
        LEFT JOIN units u ON c.unit_id = u.id
        ORDER BY c.name
    `;
    db.all(sqlContacts, [], (err, contacts) => {
        if (err) return res.status(500).json({ "error": err.message });

        const sqlAssociations = "SELECT * FROM contact_source_associations";
        db.all(sqlAssociations, [], (err, associations) => {
            if (err) return res.status(500).json({ "error": err.message });
            
            const contactsWithSources = contacts.map(contact => {
                const associatedSources = associations
                    .filter(assoc => assoc.contact_id === contact.id)
                    .map(assoc => assoc.source_type);
                return { ...contact, sources: associatedSources };
            });

            res.json(contactsWithSources);
        });
    });
});
app.post('/api/contacts', (req, res) => {
    const { name, unit_id, email, phone, sources = [] } = req.body;
    if (!name) return res.status(400).json({ "error": "O nome  obrigatrio." });

    db.run("INSERT INTO contacts (name, unit_id, email, phone) VALUES (?, ?, ?, ?)", [name, unit_id, email, phone], function(err) {
        if (err) return res.status(500).json({ "error": err.message });
        
        const contactId = this.lastID;
        if (sources.length === 0) {
            return res.status(201).json({ "id": contactId });
        }

        const placeholders = sources.map(() => '(?, ?)').join(',');
        const sql = `INSERT INTO contact_source_associations (contact_id, source_type) VALUES ${placeholders}`;
        
        const params = [];
        sources.forEach(sourceType => {
            params.push(contactId, sourceType);
        });

        db.run(sql, params, function(err) {
            if (err) return res.status(500).json({ "error": `Erro ao salvar associaes: ${err.message}` });
            res.status(201).json({ "id": contactId });
        });
    });
});
app.put('/api/contacts/:id', (req, res) => {
    const contactId = req.params.id;
    const { name, unit_id, email, phone, sources = [] } = req.body;

    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        db.run("UPDATE contacts SET name = ?, unit_id = ?, email = ?, phone = ? WHERE id = ?", [name, unit_id, email, phone, contactId]);
        db.run("DELETE FROM contact_source_associations WHERE contact_id = ?", [contactId]);

        if (sources.length > 0) {
            const placeholders = sources.map(() => '(?, ?)').join(',');
            const sql = `INSERT INTO contact_source_associations (contact_id, source_type) VALUES ${placeholders}`;
            const params = [];
            sources.forEach(sourceType => params.push(contactId, sourceType));
            db.run(sql, params);
        }

        db.run("COMMIT", (err) => {
            if (err) {
                db.run("ROLLBACK");
                return res.status(500).json({ "error": `Erro na transao: ${err.message}` });
            }
            res.status(200).json({ changes: 1 });
        });
    });
});
app.delete('/api/contacts/:id', (req, res) => {
    db.run("DELETE FROM contacts WHERE id = ?", [req.params.id], function(err) {
        if (err) return res.status(500).json({ "error": err.message });
        res.status(200).json({ deleted: this.changes });
    });
});

// --- ROTAS DE UNIDADES ---
app.get('/api/units', (req, res) => {
    db.all("SELECT * FROM units ORDER BY name", [], (err, rows) => {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.json(rows);
    });
});
app.post('/api/units', (req, res) => {
    const { name, cidade, estado, pais, numero_colaboradores } = req.body;
    if (!name || !cidade || !estado || !pais || !numero_colaboradores) { 
        return res.status(400).json({ "error": "Todos os campos so obrigatrios." }); 
    }
    const sql = "INSERT INTO units (name, cidade, estado, pais, numero_colaboradores) VALUES (?, ?, ?, ?, ?)";
    const params = [name, cidade, estado, pais, numero_colaboradores];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(201).json({ "id": this.lastID });
    });
});
app.put('/api/units/:id', (req, res) => {
    const { name, cidade, estado, pais, numero_colaboradores } = req.body;
    if (!name || !cidade || !estado || !pais || !numero_colaboradores) { 
        return res.status(400).json({ "error": "Todos os campos so obrigatrios." }); 
    }
    const sql = "UPDATE units SET name = ?, cidade = ?, estado = ?, pais = ?, numero_colaboradores = ? WHERE id = ?";
    const params = [name, cidade, estado, pais, numero_colaboradores, req.params.id];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ changes: this.changes });
    });
});
app.delete('/api/units/:id', (req, res) => {
    db.run("DELETE FROM units WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

// Rotas de Upload e Template
app.post('/api/upload', upload.single('file'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).send('Nenhum arquivo enviado.');
        }
        const filePath = req.file.path;
        const { source_type } = req.body; 

        const normalizeHeader = (header) => {
            return header.toString()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                .trim()
                .replace(/[\(\)]/g, '')
                .replace(/[^\w\s-]/g, '')
                .replace(/[\s-]+/g, '_');
        };
        
        const processAndSendData = (data) => {
            const processedData = data.map(row => {
                const newRow = {};
                for (const key in row) {
                    let value = row[key];

                    if (source_type === 'combustao_movel' && key === 'tipo_entrada' && typeof value === 'string') {
                         const normalizedInput = value
                            .toLowerCase()
                            .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                            .trim();
                        
                        if (normalizedInput === 'por consumo') {
                            value = 'consumo';
                        } else if (normalizedInput === 'por distancia') {
                            value = 'distancia';
                        }
                    }

                    if (typeof value === 'string') {
                        value = value.trim();
                    }
                    newRow[key] = value;
                }
                return newRow;
            });
            fs.unlinkSync(filePath);
            res.status(200).json(processedData);
        };
        
        const schema = validationSchemas[source_type];
        if (!schema) {
            fs.unlinkSync(filePath);
            return res.status(400).json({ message: 'Tipo de fonte invlido fornecido.' });
        }
        const headerMap = {};
        for(const key in schema.headerDisplayNames) {
            headerMap[normalizeHeader(schema.headerDisplayNames[key])] = key;
        }

        // Adiciona mapeamento para a chave oculta se ela existir no arquivo
        headerMap['id_fonte'] = 'id_fonte';

        if (req.file.originalname.endsWith('.xlsx') || req.file.originalname.endsWith('.xls')) {
            const workbook = xlsx.readFile(filePath);
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            
            const jsonData = xlsx.utils.sheet_to_json(worksheet, { defval: "", raw: true });

            const results = jsonData.map(row => {
                const newRow = {};
                for (const excelHeader in row) {
                    const normalized = normalizeHeader(excelHeader);
                    const schemaKey = headerMap[normalized];
                    if (schemaKey) {
                        newRow[schemaKey] = row[excelHeader] !== null && row[excelHeader] !== undefined ? String(row[excelHeader]) : "";
                    }
                }
                return newRow;
            });
            
            processAndSendData(results);
        } else {
            let results = [];
            fs.createReadStream(filePath)
                .pipe(csv({
                    mapHeaders: ({ header }) => headerMap[normalizeHeader(header)] || normalizeHeader(header)
                }))
                .on('data', (data) => results.push(data))
                .on('end', () => {
                    processAndSendData(results);
                });
        }
    } catch (error) {
        console.error("Erro no upload:", error);
        if (req.file && fs.existsSync(req.file.path)) {
            fs.unlinkSync(req.file.path);
        }
        res.status(500).json({ message: 'Erro interno ao processar o arquivo.' });
    }
});
app.get('/api/template/:tableName', (req, res) => {
    const { tableName } = req.params;
    const { format = 'csv' } = req.query;
    const schema = validationSchemas[tableName];
    if (!schema) { return res.status(404).send('Tipo de tabela no encontrado.'); }
    const headers = Object.values(schema.headerDisplayNames);
    if (format === 'xlsx') {
        const workbook = xlsx.utils.book_new();
        const worksheet = xlsx.utils.aoa_to_sheet([headers]);
        xlsx.utils.book_append_sheet(workbook, worksheet, 'Dados');
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=${tableName}_template.xlsx`);
        res.status(200).send(buffer);
    } else {
        const csvContent = headers.join(',');
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=${tableName}_template.csv`);
        res.status(200).send(csvContent);
    }
});
app.post('/api/export', (req, res) => {
    const { data, tableName } = req.body;
    if (!Array.isArray(data) || data.length === 0) { return res.status(400).send('Nenhum dado fornecido para exportao.'); }
    try {
        const worksheet = xlsx.utils.json_to_sheet(data);
        if (data.length > 0) {
            const headers = Object.keys(data[0]);
            worksheet['!cols'] = headers.map(header => {
                const maxLength = Math.max(...data.map(row => (row[header] || "").toString().length), header.length);
                return { wch: maxLength + 2 };
            });
        }
        const workbook = xlsx.utils.book_new();
        const sheetName = (tableName ? tableName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Dados Exportados').substring(0, 31);
        xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        const fileName = tableName ? `${tableName}_export.xlsx` : 'export.xlsx';
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=${fileName}_export.xlsx`);
        res.status(200).send(buffer);
    } catch (error) {
        console.error("Erro ao exportar para Excel:", error);
        res.status(500).json({ message: "Erro interno ao gerar o arquivo Excel." });
    }
});
app.post('/api/save-data/:tableName', (req, res) => {
    const { tableName } = req.params;
    const dataRows = req.body;
    
    // --- SPRINT 21: Mapeamento de tabelas ---
    const allowedTables = { 
        combustao_movel: 'mobile_combustion_data', 
        combustao_estacionaria: 'stationary_combustion_data', 
        dados_producao_venda: 'production_sales_data', 
        ippu_lubrificantes: 'lubricants_ippu_data', 
        emissoes_fugitivas: 'fugitive_emissions_data', 
        fertilizantes: 'fertilizers_data',
        efluentes_controlados: 'effluents_controlled_data',
        efluentes_domesticos: 'domestic_effluents_data',
        mudanca_uso_solo: 'land_use_change_data',
        solid_waste: 'solid_waste_data',
        electricity_purchase: 'electricity_purchase_data',
        purchased_goods_services: 'purchased_goods_services_data',
        capital_goods: 'capital_goods_data',
        upstream_transport: 'upstream_transport_data',
        business_travel_land: 'business_travel_land_data',
        downstream_transport: 'downstream_transport_data',
        waste_transport: 'waste_transport_data',
        home_office: 'home_office_data',
        air_travel: 'air_travel_data',
        employee_commuting: 'employee_commuting_data',
        energy_generation: 'energy_generation_data',
        planted_forest: 'planted_forest_data',
        conservation_area: 'conservation_area_data'
    };

    if (!allowedTables[tableName]) { return res.status(400).json({ message: "Tipo de tabela invlido." }); }
    if (!dataRows || dataRows.length === 0) { return res.status(400).json({ message: "Nenhum dado para salvar." }); }
    
    const dbTableName = allowedTables[tableName];
    
    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        let errorOccurred = false;
        
        dataRows.forEach(row => {
            if (errorOccurred) return;

            const booleanFields = {
                'controlado_empresa': 'controlado_empresa',
                'fossa_septica_propriedade': 'fossa_septica_propriedade',
                'local_controlado_empresa': 'local_controlado_empresa',
                'informar_cidade_uf': 'informar_cidade_uf',
                'bens_terceiros': 'bens_terceiros',
                'km_reembolsado': 'km_reembolsado',
                'area_plantada': 'area_plantada'
            };
            
            for (const frontEndKey in booleanFields) {
                if (row.hasOwnProperty(frontEndKey)) {
                    let val = row[frontEndKey];
                    if (val && typeof val === 'string') {
                         val = val.trim();
                         if(['sim', 's', 'Sim'].includes(val)) val = 'Sim';
                         else if(['nao', 'n', 'no', 'No'].includes(val)) val = 'No';
                    }
                    row[booleanFields[frontEndKey]] = val;
                }
            }

            const sanitizedRow = {};
            
            // --- SPRINT 21: Auto-preencher Descrio para Conservation Area ---
            if (tableName === 'conservation_area') {
                // Combina Bioma e Fitofisionomia para ter uma descrio til no banco
                row.descricao = `${row.bioma || ''} - ${row.fitofisionomia || ''}`;
            }
            
            // Remove a chave oculta antes de salvar
            delete row.id_fonte;

            for (const key in row) {
                if (row[key] !== '' && row[key] !== null && row[key] !== undefined) {
                    sanitizedRow[key] = row[key];
                }
            }
            
            if (Object.keys(sanitizedRow).length === 0) return;
            
            const columns = Object.keys(sanitizedRow);
            const placeholders = columns.map(() => '?').join(', ');
            const sql = `INSERT INTO ${dbTableName} (${columns.join(', ')}) VALUES (${placeholders})`;
            const values = Object.values(sanitizedRow);

            db.run(sql, values, (err) => {
                if (err) { console.error("Erro ao inserir linha:", err, "SQL:", sql, "Valores:", values); errorOccurred = true; }
            });
        });

        const operation = errorOccurred ? "ROLLBACK" : "COMMIT";
        db.run(operation, (err) => {
            if (err) { return res.status(500).json({ message: `Erro crtico durante a transao (${operation}).` }); }
            if (errorOccurred) { return res.status(500).json({ message: "Erro ao salvar os dados. A transao foi revertida." }); }
            res.status(201).json({ message: `Dados de "${tableName}" salvos com sucesso!` });
        });
    });
});

// --- ROTAS DE CADASTRO DE FONTES ---
app.get('/api/asset-typologies', (req, res) => {
    const { source_type } = req.query;
    let sql = `
        SELECT 
            T.*, 
            U.name as unit_name,
            C.name as responsible_contact_name 
        FROM asset_typologies T 
        JOIN units U ON T.unit_id = U.id
        LEFT JOIN contacts C ON T.responsible_contact_id = C.id
    `;
    const params = [];
    if (source_type) {
        sql += " WHERE T.source_type = ?";
        params.push(source_type);
    }
    sql += " ORDER BY U.name, T.description";
    
    db.all(sql, params, (err, rows) => {
        if (err) {
            res.status(500).json({ "error": err.message });
            return;
        }
        
        const results = rows.map(row => {
            const fields = JSON.parse(row.asset_fields || '{}');
            return { ...row, asset_fields: fields };
        });
        
        res.json(results);
    });
});
app.post('/api/asset-typologies', (req, res) => {
    const { unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency } = req.body;
    if (!unit_id || !source_type || !description || !asset_fields || !reporting_frequency) { return res.status(400).json({ "error": "Campos obrigatrios faltando." }); }
    const assetFieldsStr = JSON.stringify(asset_fields);
    const contactId = responsible_contact_id || null;

    if (unit_id === 'all') {
        db.all("SELECT id FROM units", [], (err, units) => {
            if (err) return res.status(500).json({ "error": `Erro ao buscar unidades: ${err.message}` });
            if (!units || units.length === 0) return res.status(404).json({ "error": "Nenhuma unidade cadastrada para aplicar a regra." });

            const sql = `INSERT INTO asset_typologies (unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency) VALUES (?, ?, ?, ?, ?, ?)`;
            db.serialize(() => {
                db.run("BEGIN TRANSACTION");
                let errorOccurred = false;
                units.forEach(unit => {
                    if (errorOccurred) return;
                    db.run(sql, [unit.id, source_type, description, assetFieldsStr, contactId, reporting_frequency], function(err) {
                        if (err) { console.error("Erro ao inserir tipologia para unidade " + unit.id, err); errorOccurred = true; }
                    });
                });
                const operation = errorOccurred ? "ROLLBACK" : "COMMIT";
                db.run(operation, (err) => {
                    if (err) return res.status(500).json({ message: `Erro crtico durante a transao (${operation}).` });
                    if (errorOccurred) return res.status(500).json({ message: "Erro ao salvar as fontes. A operao foi revertida." });
                    res.status(201).json({ "message": `Fonte '${description}' criada para ${units.length} unidades com sucesso.` });
                });
            });
        });
    } else {
        const sql = `INSERT INTO asset_typologies (unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency) VALUES (?, ?, ?, ?, ?, ?)`;
        db.run(sql, [unit_id, source_type, description, assetFieldsStr, contactId, reporting_frequency], function(err) {
            if (err) { return res.status(500).json({ "error": err.message }); }
            res.status(201).json({ "id": this.lastID });
        });
    }
});
app.put('/api/asset-typologies/:id', (req, res) => {
    const { unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency } = req.body;
    if (!unit_id || !source_type || !description || !asset_fields || !reporting_frequency) { return res.status(400).json({ "error": "Campos obrigatrios faltando." }); }
    const sql = `UPDATE asset_typologies SET unit_id = ?, source_type = ?, description = ?, asset_fields = ?, responsible_contact_id = ?, reporting_frequency = ? WHERE id = ?`;
    const params = [unit_id, source_type, description, JSON.stringify(asset_fields), responsible_contact_id || null, reporting_frequency, req.params.id];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ changes: this.changes });
    });
});

app.delete('/api/asset-typologies/:id', (req, res) => {
    db.run("DELETE FROM asset_typologies WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

app.get('/api/options', (req, res) => {
    const { field_key } = req.query;
    if (!field_key) { return res.status(400).json({ "error": "O parmetro 'field_key'  obrigatrio." }); }
    
    db.all("SELECT * FROM managed_options WHERE field_key = ? ORDER BY value", [field_key], (err, rows) => {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.json(rows);
    });
});
app.post('/api/options', (req, res) => {
    const { field_key, value } = req.body;
    if (!field_key || !value) { return res.status(400).json({ "error": "Campos 'field_key' e 'value' so obrigatrios." }); }
    
    db.run("INSERT INTO managed_options (field_key, value) VALUES (?, ?)", [field_key, value], function(err) {
        if (err) { 
            console.error("Erro ao inserir em managed_options:", err.message);
            res.status(500).json({ "error": err.message }); 
            return;
        }
        res.status(201).json({ "id": this.lastID });
    });
});
app.delete('/api/options/:id', (req, res) => {
    db.run("DELETE FROM managed_options WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

app.get('/api/intelligent-template/:sourceType', (req, res) => {
    const { sourceType } = req.params;
    const { unitId, year, format } = req.query;
    const schema = validationSchemas[sourceType];
    if (!schema) { return res.status(404).send('Tipo de fonte no encontrado.'); }

    // --- ATUALIZADO: Mapeamento de descries ---
    const descriptionKeyMap = { 
        combustao_estacionaria: 'descricao_da_fonte', 
        combustao_movel: 'descricao_fonte', 
        dados_producao_venda: 'produto', 
        ippu_lubrificantes: 'fonte_emissao', 
        emissoes_fugitivas: 'fonte_emissao', 
        fertilizantes: 'tipo_fertilizante',
        efluentes_controlados: 'tratamento_ou_destino',
        mudanca_uso_solo: 'uso_solo_anterior',
        solid_waste: 'destinacao_final',
        electricity_purchase: 'fonte_energia',
        purchased_goods_services: 'descricao_item',
        capital_goods: 'bem_capital',
        upstream_transport: 'insumo_transportado',
        business_travel_land: 'descricao_viagem',
        downstream_transport: 'insumo_transportado',
        waste_transport: 'insumo_transportado',
        home_office: 'regime_trabalho',
        air_travel: 'descricao_viagem',
        employee_commuting: 'descricao_identificadora',
        energy_generation: 'fonte_geracao',
        planted_forest: 'identificacao_area',
        conservation_area: 'bioma',
        // Adicionado Efluentes Domsticos
        efluentes_domesticos: 'tipo_trabalhador'
    };
    
    const getTypologies = new Promise((resolve, reject) => {
        let sql = `
            SELECT 
                T.*, 
                U.name as unit_name
            FROM asset_typologies T 
            JOIN units U ON T.unit_id = U.id
            WHERE T.source_type = ?
        `;
        const params = [sourceType];
        if (unitId && unitId !== 'all') { sql += " AND T.unit_id = ?"; params.push(unitId); }
        db.all(sql, params, (err, rows) => { if (err) return reject(err); resolve(rows); });
    });

    getTypologies.then((typologies) => {
        const dataForExcel = [];
        const headers = schema.headerDisplayNames;
        const headerKeys = Object.keys(headers);
        const reportYear = year || new Date().getFullYear();
        const mainDescriptionKey = descriptionKeyMap[sourceType];

        typologies.forEach(typo => {
            const frequency = typo.reporting_frequency || 'anual';
            const periods = frequency === 'mensal' ? ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"] : ["Anual"];
            const assetFields = JSON.parse(typo.asset_fields || '{}');
            
            periods.forEach(period => {
                const row = {};
                headerKeys.forEach(key => { row[key] = ''; });

                row['ano'] = reportYear;
                row['periodo'] = period;
                row['unidade_empresarial'] = typo.unit_name;
                row['id_fonte'] = typo.id; // --- Chave Primria Oculta ---
                
                if (mainDescriptionKey) {
                    if (['solid_waste', 'electricity_purchase'].includes(sourceType)) {
                        row[mainDescriptionKey] = assetFields[mainDescriptionKey] || '';
                    } else if (sourceType === 'energy_generation') {
                        row[mainDescriptionKey] = assetFields.fonte_geracao || typo.description;
                    } else if (sourceType === 'conservation_area') {
                        row[mainDescriptionKey] = assetFields.bioma || '';
                    } else if (sourceType === 'efluentes_domesticos') {
                        // Garante que o tipo de trabalhador seja o preenchido no cadastro
                        row[mainDescriptionKey] = assetFields.tipo_trabalhador || '';
                    } else {
                        row[mainDescriptionKey] = typo.description;
                    }
                }
                
                // --- INSERO DE DADOS DO CADASTRO NO JSON (Para Front-end) ---
                for (const assetKey in assetFields) { 
                    if (row.hasOwnProperty(assetKey)) { 
                        row[assetKey] = assetFields[assetKey]; 
                    } 
                }
                
                // --- Preenchimentos Especficos ---
                if (sourceType === 'solid_waste' && assetFields.destinacao_final === 'Aterro') {
                    row['informar_cidade_uf'] = assetFields.cidade_uf_destino || '';
                }
                if (sourceType === 'efluentes_controlados') {
                    row['unidade_efluente_liquido'] = frequency === 'mensal' ? 'm3/ms' : 'm3/ano';
                    row['unidade_nitrogenio'] = 'kgN/m3';
                } else if (sourceType === 'emissoes_fugitivas' || sourceType === 'fertilizantes') {
                    row['unidade'] = 'kg';
                } else if (sourceType === 'capital_goods') {
                    row['unidade'] = 'Unidades';
                }
                
                // --- AutoFill (Unidades baseadas em Combustvel) ---
                if (schema.autoFillMap) {
                    for (const triggerKey in schema.autoFillMap) {
                        const rule = schema.autoFillMap[triggerKey];
                        const triggerValue = row[triggerKey];
                        if (triggerValue) {
                            const targetValue = rule.map[triggerValue];
                            if (targetValue !== undefined) {
                                row[rule.targetColumn] = targetValue;
                            }
                        }
                    }
                }
                
                dataForExcel.push(row);
            });
        });

        if (format === 'json') {
            return res.json(dataForExcel);
        }
        
        try {
            // --- LGICA DE EXCLUSO DE COLUNAS DO EXCEL ---
            const excludeColumns = [];
            
            // Regra para Controlado pela Empresa (Agora inclui combustao_movel)
            if (['combustao_estacionaria', 'combustao_movel', 'ippu_lubrificantes', 'emissoes_fugitivas', 'fertilizantes'].includes(sourceType)) {
                excludeColumns.push('controlado_empresa');
            }
            
            // Regra para Unidade
            if (['combustao_estacionaria', 'ippu_lubrificantes'].includes(sourceType)) {
                 excludeColumns.push('unidade'); 
            }
            
            // Regra para Unidade de Consumo (Especfica para Combusto Mvel)
            if (sourceType === 'combustao_movel') {
                excludeColumns.push('unidade_consumo');
            }

            // --- NOVA REGRA: Efluentes Domsticos ---
            if (sourceType === 'efluentes_domesticos') {
                // Remove do Excel para evitar erros de digitao (Case Sensitive)
                excludeColumns.push('fossa_septica_propriedade');
            }

            const dataWithHeaderNames = dataForExcel.map(row => {
                const newRow = {};
                for (const key in row) {
                    if (key === 'id_fonte') continue; // Remove ID oculto do Excel visual
                    if (excludeColumns.includes(key)) continue; // Remove colunas proibidas

                    if (headers[key]) {
                        newRow[headers[key]] = row[key];
                    }
                }
                return newRow;
            });

            // Filtra os cabealhos tambm
            const finalHeaders = Object.keys(headers)
                .filter(key => !excludeColumns.includes(key))
                .map(key => headers[key]);

            const worksheet = xlsx.utils.json_to_sheet(dataWithHeaderNames, { header: finalHeaders });
            worksheet['!cols'] = finalHeaders.map(header => ({ wch: Math.max(header.length, 15) + 2 }));
            const workbook = xlsx.utils.book_new();
            const sheetName = schema.displayName.substring(0, 31);
            xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
            const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
            const fileName = `${sourceType}_template_preenchido_${year}.xlsx`;
            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', `attachment; filename=${fileName}_template.xlsx`);
            res.status(200).send(buffer);
        } catch (error) {
            console.error("Erro ao gerar o template inteligente:", error);
            res.status(500).json({ message: "Erro interno ao gerar o arquivo Excel." });
        }
    }).catch(err => {
        console.error("Erro ao processar dados para o template:", err);
        res.status(500).json({ message: "Erro interno ao processar a gerao do template." });
    });
});

app.listen(PORT, () => {
    console.log(`Servidor iniciado com sucesso na porta ${PORT}`);
});
</file>

</files>

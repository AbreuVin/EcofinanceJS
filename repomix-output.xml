This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/database.js
backend/package.json
backend/server.js
frontend/admin.html
frontend/admin.js
frontend/assets.html
frontend/assets.js
frontend/auth.css
frontend/dashboard.css
frontend/dashboard.html
frontend/dashboard.js
frontend/import.css
frontend/importer.html
frontend/importer.js
frontend/login.html
frontend/login.js
frontend/main.css
frontend/main.js
frontend/nav.html
frontend/register.html
frontend/register.js
frontend/units.html
frontend/units.js
gitignore
shared/validators.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Dependencies
node_modules/
/backend/node_modules/

# Database file
/backend/ecofinance.db

# Misc
.DS_Store
npm-debug.log*
</file>

<file path="frontend/auth.css">
body {
  font-family: sans-serif;
  background-color: #f4f7f6;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
.auth-container {
  background-color: white;
  padding: 40px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  width: 350px;
}
.form-group {
  margin-bottom: 20px;
}
label {
  display: block;
  margin-bottom: 5px;
}
input {
  width: 100%;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
button {
  width: 100%;
  padding: 12px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}
#message {
  margin-top: 20px;
  text-align: center;
}
</file>

<file path="frontend/login.html">
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Login - Ecofinance</title>
  <link rel="stylesheet" href="auth.css">
</head>
<body>
  <div class="auth-container">
    <h2>Login</h2>
    <form id="login-form">
      <div class="form-group">
        <label for="email">Email</label>
        <input type="email" id="email" required>
      </div>
      <div class="form-group">
        <label for="password">Senha</label>
        <input type="password" id="password" required>
      </div>
      <button type="submit">Entrar</button>
    </form>
    <p id="message"></p>
    <p>Não tem uma conta? <a href="register.html">Cadastre-se</a></p>
  </div>
  <script src="login.js"></script>
</body>
</html>
</file>

<file path="frontend/register.html">
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Cadastro - Ecofinance</title>
  <link rel="stylesheet" href="auth.css">
</head>
<body>
  <div class="auth-container">
    <h2>Cadastro</h2>
    <form id="register-form">
      <div class="form-group">
        <label for="email">Email</label>
        <input type="email" id="email" required>
      </div>
      <div class="form-group">
        <label for="password">Senha</label>
        <input type="password" id="password" required>
      </div>
      <button type="submit">Cadastrar</button>
    </form>
    <p id="message"></p>
    <p>Já tem uma conta? <a href="login.html">Faça Login</a></p>
  </div>
  <script src="register.js"></script>
</body>
</html>
</file>

<file path="backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "csv-parser": "^3.0.0",
    "express": "^4.19.2",
    "multer": "^1.4.5-lts.1",
    "sqlite3": "^5.1.7",
    "xlsx": "^0.18.5"
  }
}
</file>

<file path="frontend/login.js">
// arquivo: frontend/login.js

document.addEventListener('DOMContentLoaded', () => {
  const form = document.getElementById('login-form');
  const messageP = document.getElementById('message');
  
  if (!form) {
    console.error('ERRO CRÍTICO: Não foi possível encontrar o elemento com id="login-form".');
    return;
  }

  form.addEventListener('submit', async (event) => {
    event.preventDefault();

    const email = document.getElementById('email').value;
    const password = document.getElementById('password').value;

    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });

      const data = await response.json();

      if (response.ok) {
        messageP.textContent = data.message;
        messageP.style.color = 'green';
        setTimeout(() => {
          window.location.href = 'units.html'; 
        }, 1000);
      } else {
        messageP.textContent = data.message;
        messageP.style.color = 'red';
      }
    } catch (error) {
      console.error('Erro no fetch:', error);
      messageP.textContent = 'Erro de conexão com o servidor.';
      messageP.style.color = 'red';
    }
  });
});
</file>

<file path="frontend/main.css">
/* arquivo: frontend/main.css */


body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: #f4f7f6;
    margin: 0;
    padding-top: 70px; 
}


.navbar {
    background-color: #ffffff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 0 2rem;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: fixed; 
    top: 0;
    left: 0;
    width: 100%;
    z-index: 1000;
    box-sizing: border-box;
}

.nav-brand {
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    text-decoration: none;
}

.nav-links {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    gap: 1.5rem;
}

.nav-links a {
    color: #555;
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s ease;
}

.nav-links a:hover {
    color: #007bff;
}

.nav-logout {
    color: #dc3545;
    text-decoration: none;
    font-weight: 500;
}
</file>

<file path="frontend/main.js">
// arquivo: frontend/main.js

document.addEventListener('DOMContentLoaded', () => {
    
    const navPlaceholder = document.getElementById('nav-placeholder');
    
    if (navPlaceholder) {
        
        fetch('nav.html')
            .then(response => response.text())
            .then(data => {
                
                navPlaceholder.innerHTML = data;
            })
            .catch(error => {
                console.error('Erro ao carregar a barra de navegação:', error);
                navPlaceholder.innerHTML = '<p>Erro ao carregar menu.</p>';
            });
    }
});
</file>

<file path="frontend/register.js">
// arquivo: frontend/register.js

const form = document.getElementById('register-form');
const messageP = document.getElementById('message');

form.addEventListener('submit', async (event) => {
  event.preventDefault();

  const email = document.getElementById('email').value;
  const password = document.getElementById('password').value;

  try {
    
    const response = await fetch('/api/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    

    const data = await response.json();

    if (response.ok) {
      messageP.textContent = data.message + " Você já pode fazer o login.";
      messageP.style.color = 'green';
      form.reset(); 
    } else {
      messageP.textContent = data.message;
      messageP.style.color = 'red';
    }
  } catch (error) {
    messageP.textContent = 'Erro de conexão com o servidor.';
    messageP.style.color = 'red';
  }
});
</file>

<file path="gitignore">
# Dependencies
node_modules/
/backend/node_modules/

# Database file
/backend/ecofinance.db
/repomix-output.xml

# Misc
.DS_Store
npm-debug.log*
</file>

<file path="frontend/admin.html">
<!-- arquivo: frontend/admin.html -->
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Administração - Ecofinance</title>
    
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="dashboard.css">
    
    <style>
        .custom-options-list { list-style: none; padding: 0; }
        .custom-options-list li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; }
        .custom-options-list button { background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
    </style>
</head>
<body>
    
    <div id="nav-placeholder"></div>

    <div class="container">
        <h1>Painel de Administração</h1>

        
        <div id="admin-content-area">
            <div class="form-container">
                <h2 style="font-size: 1.2rem; margin-bottom: 1rem;">Gerenciar Opções Customizáveis</h2>
                <p>Adicione ou remova opções para os campos de seleção que aparecerão nos formulários de cadastro de fontes e importação de dados.</p>
                <div class="form-row">
                    <div class="form-group">
                        <label for="custom-option-field-selector">Selecione o Campo para Customizar</label>
                        <select id="custom-option-field-selector">
                            <option value="">-- Selecione --</option>
                        </select>
                    </div>
                </div>
                
                <div id="custom-option-manager" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="new-custom-option-value">Nova Opção</label>
                            <input type="text" id="new-custom-option-value" placeholder="">
                        </div>
                        <div class="form-group" style="justify-content: flex-end;">
                             <button type="button" id="add-custom-option-btn" class="action-btn edit-btn" style="width: auto; padding: 0.75rem 1.5rem;">Adicionar</button>
                        </div>
                    </div>
                    <div id="custom-option-feedback" class="feedback-area" style="text-align: left; margin-top: 0;"></div>
                    
                    <h3>Opções Atuais:</h3>
                    <ul id="custom-options-list-container" class="custom-options-list"></ul>
                </div>
            </div>
        </div>
        
    </div>

    
    <script type="module" src="admin.js"></script>
</body>
</html>
</file>

<file path="frontend/dashboard.css">
/* arquivo: frontend/dashboard.css */

.container {
    max-width: 900px;
    margin: 2rem auto;
    padding: 2rem;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

h1, h2 {
    color: #333;
    text-align: center;
    margin-bottom: 1.5rem;
}


.form-container {
    background-color: #f9f9f9;
    padding: 2rem;
    border-radius: 8px;
    margin-bottom: 2rem;
    border: 1px solid #eee;
}

.form-row {
    display: flex;
    gap: 1.5rem;
    margin-bottom: 1rem;
}

.form-group {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.form-group label {
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: #555;
}

.form-group input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1rem;
    box-sizing: border-box;
}

.form-actions {
    display: flex;
    justify-content: flex-end;
    gap: 1rem;
    margin-top: 1.5rem;
}

button {
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: bold;
    transition: background-color 0.3s ease;
}

button[type="submit"] {
    background-color: #28a745;
    color: white;
}

button[type="submit"]:hover {
    background-color: #218838;
}

.cancel-btn {
    background-color: #6c757d;
    color: white;
}

.cancel-btn:hover {
    background-color: #5a6268;
}



.table-container {
    overflow-x: auto;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1rem;
}

th, td {
    padding: 1rem;
    border: 1px solid #ddd;
    text-align: left;
}

th {
    background-color: #f8f9fa;
}

tr:nth-child(even) {
    background-color: #f2f2f2;
}

.action-btn {
    padding: 0.5rem 1rem;
    margin-right: 0.5rem;
    font-size: 0.9rem;
    margin-bottom: 0.4rem;
}

.edit-btn {
    background-color: #007bff;
    color: white;
}
.edit-btn:hover {
    background-color: #0069d9;
}

.delete-btn {
    background-color: #dc3545;
    color: white;
}
.delete-btn:hover {
    background-color: #c82333;
}
</file>

<file path="frontend/admin.js">
// arquivo: frontend/admin.js

document.addEventListener('DOMContentLoaded', () => {
    
    
    
    const managedFieldsConfig = {
        // --- Globais ---
        periodo: { displayName: "Período de Reporte (Global)", fieldKey: "periodo" },

        // --- Combustíveis ---
        combustivel: { displayName: "Combustíveis (Móvel & Estacionária)", fieldKey: "combustivel" },

        // --- Combustão Móvel ---
        tipo_veiculo: { displayName: "Tipo de Veículo (Móvel)", fieldKey: "tipo_veiculo" },
        unidade_consumo: { displayName: "Unidade de Consumo (Móvel)", fieldKey: "unidade_consumo" },
        unidade_distancia: { displayName: "Unidade de Distância (Móvel)", fieldKey: "unidade_distancia" },
        
        // --- IPPU & Outros ---
        tipo_lubrificante: { displayName: "Tipo de Lubrificante (IPPU)", fieldKey: "tipo_lubrificante" },
        
        // --- Emissões Fugitivas ---
        tipo_gas: { displayName: "Tipo de Gás (Fugitivas)", fieldKey: "tipo_gas" },
        
        // --- Unidades Genéricas ---
        
        unidade: { displayName: "Unidades de Medida (Padrão)", fieldKey: "unidade" }
    };

    
    const navPlaceholder = document.getElementById('nav-placeholder');
    const customOptionFieldSelector = document.getElementById('custom-option-field-selector');
    const customOptionManager = document.getElementById('custom-option-manager');
    const newCustomOptionValueInput = document.getElementById('new-custom-option-value');
    const addCustomOptionBtn = document.getElementById('add-custom-option-btn');
    const customOptionsListContainer = document.getElementById('custom-options-list-container');
    const customOptionFeedback = document.getElementById('custom-option-feedback');
    
    let currentFieldKey = null;

    
    async function handleCustomFieldSelection() { const selectedManagerKey = customOptionFieldSelector.value; if (!selectedManagerKey) { customOptionManager.style.display = 'none'; currentFieldKey = null; return; } currentFieldKey = managedFieldsConfig[selectedManagerKey].fieldKey; await loadCustomOptions(currentFieldKey); customOptionManager.style.display = 'block'; }
    async function loadCustomOptions(fieldKey) { customOptionsListContainer.innerHTML = '<li>Carregando...</li>'; try { const response = await fetch(`/api/options?field_key=${fieldKey}`); if (!response.ok) throw new Error('Falha ao buscar opções.'); const options = await response.json(); customOptionsListContainer.innerHTML = ''; if (options.length === 0) { customOptionsListContainer.innerHTML = '<li>Nenhuma opção cadastrada para este campo.</li>'; } else { options.forEach(opt => { const li = document.createElement('li'); li.textContent = opt.value; const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'X'; deleteBtn.title = 'Deletar esta opção'; deleteBtn.dataset.id = opt.id; deleteBtn.onclick = () => handleDeleteCustomOption(opt.id); li.appendChild(deleteBtn); customOptionsListContainer.appendChild(li); }); } } catch (error) { console.error('Erro ao carregar opções:', error); customOptionsListContainer.innerHTML = '<li>Erro ao carregar opções. Verifique o console.</li>'; } }
    async function handleAddCustomOption() { const value = newCustomOptionValueInput.value.trim(); if (!currentFieldKey || !value) { customOptionFeedback.textContent = 'Por favor, selecione um campo e digite um valor para a nova opção.'; customOptionFeedback.style.color = 'red'; return; } try { const response = await fetch('/api/options', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ field_key: currentFieldKey, value: value }) }); if (!response.ok) { const errorData = await response.json(); if (response.status === 500 && errorData.error.includes('UNIQUE constraint failed')) { throw new Error(`A opção "${value}" já existe para este campo.`); } throw new Error(errorData.message || 'Erro desconhecido do servidor.'); } newCustomOptionValueInput.value = ''; customOptionFeedback.textContent = ''; await loadCustomOptions(currentFieldKey); } catch (error) { console.error('Erro ao adicionar opção:', error); customOptionFeedback.textContent = `Erro: ${error.message}`; customOptionFeedback.style.color = 'red'; } }
    async function handleDeleteCustomOption(optionId) { if (!confirm('Tem certeza que deseja deletar esta opção? Ela será removida de todos os lugares onde aparece.')) return; try { const response = await fetch(`/api/options/${optionId}`, { method: 'DELETE' }); if (!response.ok) throw new Error('Falha ao deletar opção.'); await loadCustomOptions(currentFieldKey); } catch (error) { console.error('Erro ao deletar opção:', error); alert('Ocorreu um erro ao deletar a opção. Verifique o console.'); } }

    
    function initializePage() {
        if (navPlaceholder) {
            fetch('nav.html')
                .then(response => response.ok ? response.text() : Promise.reject('nav.html não encontrado.'))
                .then(data => { navPlaceholder.innerHTML = data; })
                .catch(error => console.error('Erro ao carregar a barra de navegação:', error));
        }

        
        const selector = customOptionFieldSelector;
        selector.innerHTML = '<option value="">-- Selecione um Campo --</option>';
        
        
        const sortedKeys = Object.keys(managedFieldsConfig).sort((a, b) => 
            managedFieldsConfig[a].displayName.localeCompare(managedFieldsConfig[b].displayName)
        );

        sortedKeys.forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = managedFieldsConfig[key].displayName;
            selector.appendChild(option);
        });

        customOptionFieldSelector.addEventListener('change', handleCustomFieldSelection);
        addCustomOptionBtn.addEventListener('click', handleAddCustomOption);
    }

    
    initializePage();

});
</file>

<file path="frontend/import.css">
/* arquivo: frontend/import.css */

body { 
    font-family: sans-serif; 
    background-color: #f4f7f6; 
    margin: 20px;
    padding-bottom: 20px;
}

.container { 
    max-width: 100%; 
    width: 1200px;   
    margin: auto; 
    background: white; 
    padding: 20px; 
    border-radius: 8px; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
    display: flex;
    flex-direction: column;
}

h1 { 
    text-align: center; 
    color: #333; 
}

.form-group { 
    margin-bottom: 20px; 
}

form { 
    margin-bottom: 20px; 
    padding: 20px; 
    border: 1px solid #ddd; 
    border-radius: 5px; 
    display: flex; 
    align-items: center; 
    gap: 20px; 
    flex-wrap: wrap; 
}

input[type="file"] { 
    border: 1px solid #ccc; 
    padding: 10px; 
    border-radius: 4px; 
}

select { 
    padding: 10px; 
    border: 1px solid #ccc; 
    border-radius: 4px; 
    font-size: 16px; 
}

button { 
    padding: 12px 20px; 
    color: white; 
    border: none; 
    border-radius: 4px; 
    cursor: pointer; 
    font-size: 16px; 
}

#upload-form button { 
    background-color: #007bff; 
}

#save-data-btn { 
    background-color: #007bff; 
}

.add-btn { 
    background-color: #28a745; 
}
.add-btn:hover { 
    background-color: #218838; 
}

.export-btn { 
    background-color: #ff8c00; 
    color: white; 
}
.export-btn:hover { 
    background-color: #cc7000; 
}

.feedback-area { 
    margin: 20px 0; 
    font-weight: bold; 
}

/* --- ÁREA DA TABELA --- */

.table-container { 
    width: 100%;
    
    /* Define altura fixa para garantir que a barra de rolagem horizontal apareça na tela */
    height: calc(100vh - 280px); 
    min-height: 400px; 
    
    overflow: auto; 
    
    border: 1px solid #ddd;
    background-color: #fff;
    position: relative;
    display: block;
}

.table-container::-webkit-scrollbar {
    width: 12px;  
    height: 12px; 
}
.table-container::-webkit-scrollbar-track {
    background: #f1f1f1; 
}
.table-container::-webkit-scrollbar-thumb {
    background: #c1c1c1; 
    border-radius: 6px;
    border: 3px solid #f1f1f1; 
}
.table-container::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8; 
}

table { 
    width: max-content; 
    min-width: 100%; 
    border-collapse: separate; 
    border-spacing: 0;
    table-layout: fixed; 
}

th, td { 
    padding: 10px; 
    border-bottom: 1px solid #ddd; 
    border-right: 1px solid #ddd;
    text-align: left; 
    vertical-align: top;
    
    white-space: normal; 
    word-wrap: break-word;
    
    width: 150px; 
    min-width: 80px; 
    box-sizing: border-box;
    position: relative; 
}

/* CABEÇALHO FIXO */
thead th { 
    position: sticky; 
    top: 0; 
    background-color: #f8f9fa; 
    z-index: 100; /* Aumentado para garantir visibilidade */
    border-top: 1px solid #ddd;
    border-bottom: 2px solid #ddd;
    color: #333;
    /* Height removido para evitar corte de texto */
}

tr:nth-child(even) { 
    background-color: #f2f2f2; 
}

.invalid-cell { 
    background-color: #f8d7da !important; 
    color: #721c24; 
    outline: 1px solid #f5c6cb; 
}

td select { 
    width: 100%; 
    padding: 8px; 
    border: 1px solid #ccc; 
    border-radius: 4px; 
    background-color: white; 
    font-family: inherit; 
    font-size: inherit; 
}

.invalid-cell select { 
    border-color: #f5c6cb; 
    background-color: #f8d7da; 
}

.delete-row-btn {
    background-color: #dc3545;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
    font-weight: bold;
    line-height: 1;
}

.delete-row-btn:hover { 
    background-color: #c82333; 
}
.delete-row-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.saved-row {
    background-color: #e2e6ea !important;
    color: #6c757d;
}

/* REDIMENSIONAMENTO */
.resizer {
    position: absolute;
    top: 0;
    right: 0;
    width: 5px;
    cursor: col-resize;
    user-select: none;
    height: 100%;
    z-index: 101; 
}

.resizer:hover, .resizing {
    border-right: 2px solid #007bff; 
}
</file>

<file path="frontend/units.js">
// arquivo: frontend/units.js

document.addEventListener('DOMContentLoaded', () => {
    
    const navPlaceholder = document.getElementById('nav-placeholder');
    if (navPlaceholder) {
        fetch('nav.html').then(response => response.text()).then(data => {
            navPlaceholder.innerHTML = data;
        }).catch(error => console.error('Erro ao carregar navbar:', error));
    }

    const form = document.getElementById('unit-form');
    const unitIdInput = document.getElementById('unit-id');
    const unitsTbody = document.getElementById('units-tbody');
    const cancelBtn = document.getElementById('cancel-btn');
    const stateSelect = document.getElementById('estado');

    const API_URL = '/api/units';

    // --- ATENÇÃO: Lista de UFs do Brasil ---
    const ufs = [
        "AC", "AL", "AP", "AM", "BA", "CE", "DF", "ES", "GO", "MA", "MT", "MS", 
        "MG", "PA", "PB", "PR", "PE", "PI", "RJ", "RN", "RS", "RO", "RR", "SC", 
        "SP", "SE", "TO"
    ];

    // --- ATENÇÃO: Nova função para popular o dropdown de estados ---
    const populateStatesDropdown = () => {
        ufs.forEach(uf => {
            const option = document.createElement('option');
            option.value = uf;
            option.textContent = uf;
            stateSelect.appendChild(option);
        });
    };

    const fetchUnits = async () => {
        try {
            const response = await fetch(API_URL);
            if (!response.ok) {
                throw new Error(`Erro do servidor: ${response.status}`);
            }
            const units = await response.json();
            
            unitsTbody.innerHTML = '';
            
            if (Array.isArray(units)) {
                units.forEach(unit => {
                    const tr = document.createElement('tr');
                    
                    // Escapa as aspas nos nomes para evitar quebrar o HTML no onclick
                    const escapedName = unit.name ? unit.name.replace(/'/g, "\\'") : '';
                    const escapedCidade = unit.cidade ? unit.cidade.replace(/'/g, "\\'") : '';
                    const escapedPais = unit.pais ? unit.pais.replace(/'/g, "\\'") : '';
                    
                    tr.innerHTML = `
                        <td>${unit.name ?? ''}</td>
                        <td>${unit.cidade ?? ''}</td>
                        <td>${unit.estado ?? ''}</td>
                        <td>${unit.pais ?? ''}</td>
                        <td>${unit.numero_colaboradores ?? ''}</td>
                        <td>
                            <button class="action-btn edit-btn" onclick="editUnit(${unit.id}, '${escapedName}', '${escapedCidade}', '${unit.estado ?? ''}', '${escapedPais}', '${unit.numero_colaboradores ?? ''}')">Editar</button>
                            <button class="action-btn delete-btn" onclick="deleteUnit(${unit.id})">Deletar</button>
                        </td>
                    `;
                    
                    unitsTbody.appendChild(tr);
                });
            } else {
                 console.error("A resposta da API não é um array:", units);
            }
        } catch (err) {
            console.error("Falha ao buscar unidades", err);
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const id = unitIdInput.value;
        
        const unitData = {
            name: document.getElementById('name').value,
            cidade: document.getElementById('cidade').value,
            estado: document.getElementById('estado').value,
            pais: document.getElementById('pais').value,
            numero_colaboradores: document.getElementById('numero-colaboradores').value,
        };
        
        const method = id ? 'PUT' : 'POST';
        const url = id ? `${API_URL}/${id}` : API_URL;

        await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(unitData),
        });

        resetForm();
        fetchUnits();
    });
    
    cancelBtn.addEventListener('click', () => resetForm());
    
    
    window.editUnit = (id, name, cidade, estado, pais, numero_colaboradores) => {
        unitIdInput.value = id;
        document.getElementById('name').value = name;
        document.getElementById('cidade').value = cidade;
        document.getElementById('estado').value = estado;
        document.getElementById('pais').value = pais;
        document.getElementById('numero-colaboradores').value = numero_colaboradores;
        cancelBtn.style.display = 'inline-block';

        // --- ATENÇÃO: Rolagem automática para o topo ---
        window.scrollTo(0, 0);
    };
    

    window.deleteUnit = async (id) => {
        if (confirm('Tem certeza que deseja deletar esta unidade?')) {
            await fetch(`${API_URL}/${id}`, { method: 'DELETE' });
            fetchUnits();
        }
    };

    window.resetForm = () => {
        form.reset();
        unitIdInput.value = '';
        cancelBtn.style.display = 'none';
    };

    populateStatesDropdown();
    fetchUnits();
    
});
</file>

<file path="frontend/dashboard.js">
// arquivo: frontend/dashboard.js


import { validationSchemas } from '../shared/validators.js';

document.addEventListener('DOMContentLoaded', () => {
    
    const navPlaceholder = document.getElementById('nav-placeholder');
    const form = document.getElementById('contact-form');
    const contactIdInput = document.getElementById('contact-id');
    const contactsTbody = document.getElementById('contacts-tbody');
    const cancelBtn = document.getElementById('cancel-btn');
    const sourcesCheckboxContainer = document.getElementById('sources-checkbox-container');
    const phoneInput = document.getElementById('phone');
    const unitSelect = document.getElementById('unit');
    
    const selectAllSourcesCheckbox = document.getElementById('select-all-sources');
    const sourcesFeedback = document.getElementById('sources-feedback');
    
    
    const phoneMask = IMask(phoneInput, {
        mask: [
            { mask: '(00) 0000-0000' },
            { mask: '(00) 00000-0000' }
        ]
    });
    
    

    const fetchAndPopulateUnits = async () => {
        try {
            const response = await fetch('/api/units');
            if (!response.ok) throw new Error('Falha ao buscar unidades');
            const units = await response.json();
            
            unitSelect.innerHTML = '<option value="">-- Selecione uma unidade --</option>'; // Mensagem padrão
            units.forEach(unit => {
                const option = document.createElement('option');
                option.value = unit.id;
                option.textContent = unit.name;
                unitSelect.appendChild(option);
            });
        } catch (error) {
            console.error('Erro ao carregar unidades:', error);
            unitSelect.innerHTML = '<option value="">-- Erro ao carregar unidades --</option>';
        }
    };

    const initializePage = () => {
        if (navPlaceholder) {
            fetch('nav.html').then(response => response.text()).then(data => {
                navPlaceholder.innerHTML = data;
            }).catch(error => console.error('Erro ao carregar navbar:', error));
        }

        
        sourcesCheckboxContainer.innerHTML = '';
        const sourceKeys = Object.keys(validationSchemas);
        sourceKeys.forEach(key => {
            const schema = validationSchemas[key];
            const itemDiv = document.createElement('div');
            itemDiv.className = 'checkbox-item';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `source-${key}`;
            checkbox.value = key;
            checkbox.classList.add('source-checkbox'); 
            const label = document.createElement('label');
            label.htmlFor = `source-${key}`;
            label.textContent = schema.displayName;
            itemDiv.appendChild(checkbox);
            itemDiv.appendChild(label);
            sourcesCheckboxContainer.appendChild(itemDiv);
        });
        
        fetchAndPopulateUnits();
        fetchContacts();
    };

    const fetchContacts = async () => {
        try {
            const response = await fetch('/api/contacts');
            const contacts = await response.json();
            contactsTbody.innerHTML = '';
            contacts.forEach(contact => {
                const tr = document.createElement('tr');
                
                const sourceNames = (contact.sources || [])
                    .map(key => validationSchemas[key]?.displayName || key)
                    .join(', ');

                const formattedPhone = contact.phone ? IMask.pipe(contact.phone, phoneMask) : '';

                
                tr.innerHTML = `
                    <td>${contact.name || ''}</td>
                    <td>${contact.unit_name || 'N/A'}</td>
                    <td>${contact.email || ''}</td>
                    <td>${sourceNames}</td>
                    <td>${formattedPhone}</td>
                    <td>
                        <button class="action-btn edit-btn">Editar</button>
                        <button class="action-btn delete-btn">Deletar</button>
                    </td>
                `;

                tr.querySelector('.edit-btn').addEventListener('click', () => editContact(contact));
                tr.querySelector('.delete-btn').addEventListener('click', () => deleteContact(contact.id));
                
                contactsTbody.appendChild(tr);
            });
        } catch(err) {
            console.error("Falha ao buscar contatos", err);
        }
    };

    
    form.addEventListener('submit', async (e) => {
        e.preventDefault();

        
        const emailInput = document.getElementById('email');
        if (!emailInput.value.includes('@')) {
            alert('Por favor, insira um endereço de e-mail válido.');
            emailInput.focus();
            return;
        }

        const selectedSources = Array.from(sourcesCheckboxContainer.querySelectorAll('input.source-checkbox:checked'))
                                     .map(checkbox => checkbox.value);
        
        
        if (selectedSources.length === 0) {
            sourcesFeedback.style.display = 'block';
            return;
        } else {
            sourcesFeedback.style.display = 'none';
        }
        
        const id = contactIdInput.value;
        const contactData = {
            name: document.getElementById('name').value,
            unit_id: unitSelect.value,
            email: emailInput.value,
            phone: phoneMask.unmaskedValue,
            sources: selectedSources
            
        };

        const method = id ? 'PUT' : 'POST';
        const url = id ? `/api/contacts/${id}` : '/api/contacts';

        try {
            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(contactData),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Falha ao salvar o responsável.');
            }
            
            
            alert(`Responsável ${id ? 'atualizado' : 'salvo'} com sucesso!`);

            resetForm();
            fetchContacts();

        } catch (error) {
            console.error('Erro ao salvar:', error);
            alert(`Ocorreu um erro: ${error.message}`);
        }
    });
    
    cancelBtn.addEventListener('click', () => resetForm());

    
    function updateSelectAllCheckbox() {
        const allSourceCheckboxes = document.querySelectorAll('.source-checkbox');
        const checkedSourceCheckboxes = document.querySelectorAll('.source-checkbox:checked');
        selectAllSourcesCheckbox.checked = allSourceCheckboxes.length > 0 && allSourceCheckboxes.length === checkedSourceCheckboxes.length;
    }

    selectAllSourcesCheckbox.addEventListener('change', () => {
        const allSourceCheckboxes = document.querySelectorAll('.source-checkbox');
        allSourceCheckboxes.forEach(checkbox => {
            checkbox.checked = selectAllSourcesCheckbox.checked;
        });
    });

    sourcesCheckboxContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('source-checkbox')) {
            updateSelectAllCheckbox();
        }
    });
    

    

    window.editContact = (contact) => {
        contactIdInput.value = contact.id;
        document.getElementById('name').value = contact.name;
        unitSelect.value = contact.unit_id || '';
        document.getElementById('email').value = contact.email;
        phoneMask.value = contact.phone || '';
        
        
        sourcesCheckboxContainer.querySelectorAll('.source-checkbox').forEach(checkbox => {
            checkbox.checked = contact.sources && contact.sources.includes(checkbox.value);
        });

        updateSelectAllCheckbox(); 
        cancelBtn.style.display = 'inline-block';
        window.scrollTo(0, 0);
    };

    window.deleteContact = async (id) => {
        if (confirm('Tem certeza que deseja deletar este contato?')) {
            await fetch(`/api/contacts/${id}`, {
                method: 'DELETE',
            });
            fetchContacts();
        }
    };

    window.resetForm = () => {
        form.reset();
        contactIdInput.value = '';
        unitSelect.value = '';
        phoneMask.value = '';
        sourcesCheckboxContainer.querySelectorAll('.source-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
        selectAllSourcesCheckbox.checked = false; 
        sourcesFeedback.style.display = 'none'; 
        cancelBtn.style.display = 'none';
    };

    
    initializePage();
});
</file>

<file path="frontend/importer.html">
<!--Arquivo: importer.html-->

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Importar Dados - Ecofinance</title>
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="import.css">
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        <h1>Importar Base de Dados</h1>
        
        <div class="form-group">
            <label for="table-selector">Selecione o tipo de dados para importar:</label>
            <select id="table-selector"></select>
        </div>
        
        <div id="upload-section" style="display: none;">
            
            <div class="template-download-section">
                
                <div class="template-download-group">
                     <button type="button" id="download-intelligent-btn" class="intelligent-btn" style="display: none; background-color: #007BFF; color: white">Baixar Template</button>
                </div>
            </div>
            
            <p id="upload-instructions"></p>
            <form id="upload-form">
                <input type="file" id="file-input" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                <button type="submit">Enviar e Validar</button>
            </form>

        </div>
        
        <div id="table-actions" style="display: none; margin-top: 20px; margin-bottom: 20px; display: flex; gap: 10px;">
            <button type="button" id="export-btn" class="export-btn" style="display: none;">Baixar Dados da Tabela</button>
            <button type="button" id="save-data-btn" style="display: none;">Salvar Dados no Banco</button>
        </div>
        
        <div id="feedback" class="feedback-area"></div>
        <div id="table-container" class="table-container"></div>
    </div>

    <script src="https://unpkg.com/imask"></script>
    <script type="module" src="importer.js"></script>
</body>
</html>
</file>

<file path="frontend/units.html">
<!-- arquivo: frontend/units.html -->

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Cadastro de Unidades - Ecofinance</title>
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="dashboard.css"> 
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        
        <h1>Gestão de Unidades Empresariais</h1>

        <div class="form-container">
            <h2>Adicionar / Editar Unidade</h2>
            <form id="unit-form">
                <input type="hidden" id="unit-id">
                <div class="form-group">
                    <label for="name">Nome da Unidade</label>
                    <input type="text" id="name" placeholder="Ex: Sede SP, Fábrica MG" required>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="cidade">Cidade</label>
                        <input type="text" id="cidade" placeholder="Cidade" required>
                    </div>
                    <div class="form-group">
                        <label for="estado">Estado</label>
                        <!-- --- ATENÇÃO: Input trocado por Select --- -->
                        <select id="estado" required>
                            <option value="">-- Selecione o UF --</option>
                        </select>
                    </div>
                </div>
                 <div class="form-row">
                    <div class="form-group">
                        <label for="pais">País</label>
                        <input type="text" id="pais" placeholder="País" required>
                    </div>
                    <div class="form-group">
                        <label for="numero-colaboradores">Nº de Colaboradores</label>
                        <input type="number" id="numero-colaboradores" placeholder="Ex: 150" min="0" required>
                    </div>
                </div>
                <button type="submit">Salvar Unidade</button>
                <button type="button" id="cancel-btn" style="display: none;">Cancelar Edição</button>
            </form>
        </div>

        <div class="table-container">
            <h2>Lista de Unidades</h2>
            <table>
                <thead>
                    <tr>
                        <th>Nome da Unidade</th>
                        <th>Cidade</th>
                        <th>Estado</th>
                        <th>País</th>
                        <th>Nº de Colaboradores</th>
                        <th>Ações</th>
                    </tr>
                </thead>
                <tbody id="units-tbody">
                </tbody>
            </table>
        </div>
    </div>
    <script src="units.js"></script> 
</body>
</html>
</file>

<file path="frontend/dashboard.html">
<!-- arquivo: frontend/dashboard.html -->
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Gestão de Responsáveis - Ecofinance</title>
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="dashboard.css">
    <style>
        
        .sources-container {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #eee;
        }
        .sources-container h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1rem;
            color: #555;
            font-weight: 500;
        }
        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.75rem;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
        }
        .checkbox-item input {
            margin-right: 0.5rem;
            width: auto; 
        }
        .checkbox-item label {
            margin-bottom: 0; 
            font-weight: normal;
        }
        
        .select-all-container {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #eee;
        }
        
    </style>
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        <h1>Gestão de Responsáveis</h1>

        <div class="form-container">
            <h2>Adicionar / Editar Responsável</h2>
            <form id="contact-form">
                <input type="hidden" id="contact-id">
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="name">Nome</label>
                        <input type="text" id="name" placeholder="Nome do responsável" required>
                    </div>
                    <div class="form-group">
                        <label for="unit">Unidade Empresarial</label>
                        <select id="unit" required>
                            <option value="">-- Carregando unidades... --</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="email">E-mail</label>
                        <input type="email" id="email" placeholder="E-mail do responsável" required>
                    </div>
                     <div class="form-group">
                        <label for="phone">Telefone</label>
                        <input type="text" id="phone" placeholder="(00) 00000-0000">
                    </div>
                </div>
                
                <div class="sources-container">
                    
                    <h3>Fontes de Emissão sob sua Responsabilidade</h3>
                    
                    
                    <div class="select-all-container checkbox-item">
                        <input type="checkbox" id="select-all-sources">
                        <label for="select-all-sources">Selecionar Todas as Fontes</label>
                    </div>

                    <div id="sources-checkbox-container" class="checkbox-grid">
                        
                    </div>
                    <small id="sources-feedback" style="color: red; display: none; margin-top: 5px;">É obrigatório selecionar ao menos uma fonte de emissão.</small>
                </div>
                
                <div class="form-actions">
                    <button type="submit">Salvar Responsável</button>
                    <button type="button" id="cancel-btn" class="cancel-btn" style="display: none;">Cancelar Edição</button>
                </div>
            </form>
        </div>

        <div class="table-container">
            <h2>Lista de Responsáveis</h2>
            <table>
                <thead>
                    <tr>
                        
                        <th>Nome</th>
                        <th>Unidade</th>
                        <th>E-mail</th>
                        <th>Fontes Associadas</th>
                        <th>Telefone</th>
                        <th>Ações</th>
                    </tr>
                </thead>
                <tbody id="contacts-tbody">
                    
                </tbody>
            </table>
        </div>
    </div>

    
    <script src="https://unpkg.com/imask"></script>
    
    <script type="module" src="dashboard.js"></script>
</body>
</html>
</file>

<file path="frontend/nav.html">
<!-- arquivo: frontend/nav.html -->
<nav class="navbar">
    <a href="dashboard.html" class="nav-brand">Ecofinance</a>
    <ul class="nav-links">
        
        <li><a href="units.html">Unidades Empresariais</a></li>
        <li><a href="dashboard.html">Responsáveis</a></li>
        <li><a href="assets.html">Cadastro de Fontes</a></li>
        <li><a href="importer.html">Reportar Dados</a></li>
        
    </ul>
    <a href="login.html" class="nav-logout">Sair</a>
</nav>
</file>

<file path="frontend/assets.html">
<!-- arquivo: frontend/assets.html -->
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Cadastro de Fontes - Ecofinance</title>
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="dashboard.css">
    
    <style>
        .custom-options-list { list-style: none; padding: 0; }
        .custom-options-list li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; }
        .custom-options-list button { background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        <h1>Cadastro de Fontes de Emissão</h1> 

        <div class="form-group">
            <label for="source-selector">Selecione uma Fonte de Emissão para gerenciar:</label>
            <select id="source-selector">
                <option value="">-- Selecione --</option>
            </select>
        </div>

        <div id="asset-management-section" style="display: none;">
            
            

            <div class="form-container">
                <h2 id="form-title">Adicionar Nova Fonte</h2>
                <form id="asset-form">
                    <input type="hidden" id="asset-id">
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="asset-description">Descrição da Fonte</label>
                            <input type="text" id="asset-description" placeholder="" required>
                        </div>
                         <div class="form-group">
                            <label for="asset-unit">Unidade Empresarial</label>
                            <select id="asset-unit" required></select>
                        </div>
                    </div>
                    
                    <div id="specific-fields-container">
                        
                    </div>

                    <div class="form-actions">
                        <button type="submit">Salvar Fonte</button>
                        <button type="button" id="cancel-btn" class="cancel-btn" style="display: none;">Cancelar Edição</button>
                    </div>
                </form>
            </div>

            <div class="table-container">
                <h2 id="table-title">Fontes Cadastradas</h2>
                <table>
                    <thead id="assets-thead"></thead>
                    <tbody id="assets-tbody"></tbody>
                </table>
            </div>

        </div>

    </div>

    <script type="module" src="assets.js"></script>
</body>
</html>
</file>

<file path="frontend/importer.js">
// arquivo: frontend/importer.js

import { validationSchemas } from '../shared/validators.js';

document.addEventListener('DOMContentLoaded', () => {
    
    // --- ELEMENTOS DO DOM ---
    const tableSelector = document.getElementById('table-selector');
    const uploadSection = document.getElementById('upload-section');
    const uploadForm = document.getElementById('upload-form');
    const fileInput = document.getElementById('file-input');
    const feedbackDiv = document.getElementById('feedback');
    const tableContainer = document.getElementById('table-container');
    const tableActions = document.getElementById('table-actions');
    const saveButton = document.getElementById('save-data-btn');
    const exportButton = document.getElementById('export-btn');
    const downloadIntelligentBtn = document.getElementById('download-intelligent-btn');
    
    if(downloadIntelligentBtn) downloadIntelligentBtn.textContent = 'Baixar Template';

    // --- SPRINT 21: 'plantio' agora é texto, removido daqui ---
    const INTEGER_FIELDS = [ 'quantidade_vendida', 'num_trabalhadores', 'numero_viagens', 'num_funcionarios', 'dias_deslocados', 'idade_antepenultimo', 'idade_penultimo' ];
    
    // --- SPRINT 21: Adicionado 'area_inicio_ano', 'area_fim_ano' ---
    const DECIMAL_FIELDS = [ 'consumo', 'distancia_percorrida', 'quantidade_reposta', 'quantidade_kg', 'percentual_nitrogenio', 'percentual_carbonato', 'area_hectare', 'qtd_efluente_liquido_m3', 'qtd_componente_organico', 'qtd_nitrogenio_mg_l', 'componente_organico_removido_lodo', 'carga_horaria_media', 'quantidade_gerado', 'quantidade', 'valor_aquisicao', 'distancia_trecho', 'carga_transportada', 'distancia_km', 'total_geracao', 'area_antepenultimo', 'area_colhida_penultimo', 'area_atual', 'area_inicio_ano', 'area_fim_ano' ];

    let currentSchema = null;
    let unitsList = [];
    let managedOptionsCache = {}; 
    let maskInstances = {};
    let maskIdCounter = 0;
    let currentReportYear = null;

    // --- UTILS ---
    function loadNavbar() {
        const navPlaceholder = document.getElementById('nav-placeholder');
        if (navPlaceholder) { 
            fetch('nav.html')
                .then(response => response.ok ? response.text() : Promise.reject('nav.html não encontrado.'))
                .then(data => { 
                    navPlaceholder.innerHTML = data; 
                    document.title = 'Reporte de Dados - Ecofinance';
                    const h1 = document.querySelector('.container h1');
                    if(h1) h1.textContent = 'Reporte de Dados';
                })
                .catch(error => console.error('Erro ao carregar a barra de navegação:', error));
        }
    }

    async function fetchUnits() {
        try {
            const response = await fetch('/api/units');
            if (!response.ok) throw new Error('Falha ao buscar unidades');
            unitsList = await response.json();
        } catch (error) { console.error('Erro ao buscar unidades:', error); unitsList = []; }
    }
    
    async function fetchManagedOptions(schema) {
        managedOptionsCache = {};
        const optionKeysToFetch = new Set(); 
        if (schema && schema.validOptions) {
            for (const key in schema.validOptions) {
                managedOptionsCache[key] = schema.validOptions[key];
                if (schema.validOptions[key].length > 2) {
                     optionKeysToFetch.add(key);
                }
            }
        }
        if (optionKeysToFetch.size === 0) return;
        try {
            const fetchPromises = Array.from(optionKeysToFetch).map(key =>
                fetch(`/api/options?field_key=${key}`)
                    .then(res => res.ok ? res.json() : Promise.reject(`Falha ao buscar opções para ${key}`))
                    .then(options => ({ key, options: options.map(opt => opt.value) }))
            );
            const results = await Promise.all(fetchPromises);
            results.forEach(({ key, options }) => {
                 if(options.length > 0) {
                    managedOptionsCache[key] = [...new Set([...(managedOptionsCache[key] || []), ...options])];
                 }
            });
        } catch (error) {
            console.error("Erro ao carregar opções gerenciadas:", error);
            feedbackDiv.textContent = 'Erro ao carregar opções de seleção. A página pode não funcionar corretamente.';
            feedbackDiv.style.color = 'red';
        }
    }

    // --- HELPER: Substituição Dinâmica de Ano ---
    function resolveDynamicHeader(displayName, reportYear) {
        if (!reportYear) return displayName;
        const yearInt = parseInt(reportYear);
        if (isNaN(yearInt)) return displayName;

        return displayName
            .replace('{ANO}', yearInt)
            .replace('{ANO-1}', yearInt - 1)
            .replace('{ANO-2}', yearInt - 2);
    }

    // --- LÓGICA DE RASCUNHO (LOCALSTORAGE) ---
    function getDraftKey() {
        if (!currentSchema || !currentReportYear) return null;
        return `ecofinance_draft_${tableSelector.value}_${currentReportYear}`;
    }

    function saveDraft() {
        const key = getDraftKey();
        if (!key) return;
        
        const headers = Object.keys(currentSchema.headerDisplayNames);
        const activeRowsData = [];
        
        document.querySelectorAll('#table-container tbody tr').forEach(row => {
            const isLocked = row.querySelector('input:disabled, select:disabled');
            if (!isLocked) {
                activeRowsData.push(getRowDataFromDOM(row, headers));
            }
        });

        if (activeRowsData.length > 0) {
            localStorage.setItem(key, JSON.stringify(activeRowsData));
        } else {
            localStorage.removeItem(key); 
        }
    }

    function checkAndLoadDraft() {
        const key = getDraftKey();
        if (!key) return;

        const savedDraft = localStorage.getItem(key);
        if (savedDraft) {
            const draftData = JSON.parse(savedDraft);
            if (draftData.length > 0) {
                if (confirm(`Encontramos um rascunho não salvo com ${draftData.length} linhas para o ano ${currentReportYear}. Deseja restaurá-lo?`)) {
                    generateTable(draftData, false); 
                    feedbackDiv.textContent = 'Rascunho restaurado com sucesso. Não se esqueça de salvar!';
                    feedbackDiv.style.color = 'blue';
                } else {
                    localStorage.removeItem(key); 
                }
            }
        }
    }

    function clearDraft() {
        const key = getDraftKey();
        if (key) localStorage.removeItem(key);
    }

    // --- LÓGICA DE REDIMENSIONAMENTO DE COLUNA (EXCEL-LIKE) ---
    function createResizableHeaders(table) {
        const cols = table.querySelectorAll('th');
        [].forEach.call(cols, function (col) {
            const resizer = document.createElement('div');
            resizer.classList.add('resizer');
            resizer.style.height = `${table.offsetHeight}px`; 
            col.appendChild(resizer);
            
            createResizableColumn(col, resizer);
        });
    }

    function createResizableColumn(col, resizer) {
        let x = 0;
        let w = 0;

        const mouseDownHandler = function (e) {
            x = e.clientX;
            const styles = window.getComputedStyle(col);
            w = parseInt(styles.width, 10);

            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
            resizer.classList.add('resizing');
        };

        const mouseMoveHandler = function (e) {
            const dx = e.clientX - x;
            col.style.width = `${w + dx}px`;
        };

        const mouseUpHandler = function () {
            document.removeEventListener('mousemove', mouseMoveHandler);
            document.removeEventListener('mouseup', mouseUpHandler);
            resizer.classList.remove('resizing');
        };

        resizer.addEventListener('mousedown', mouseDownHandler);
    }

    function sanitizeAndPreprocessRow(rowData) {
        const sourceType = tableSelector.value;
        const cleanedRow = { ...rowData }; 

        if (sourceType === 'emissoes_fugitivas') {
            const gasValue = cleanedRow['tipo_gas'];
            if (gasValue) {
                const validGasOptions = managedOptionsCache['tipo_gas'] || [];
                const gasMap = new Map(validGasOptions.map(gas => [gas.toLowerCase(), gas]));
                const normalizedGas = gasMap.get(String(gasValue).toLowerCase());
                if (normalizedGas) {
                    cleanedRow['tipo_gas'] = normalizedGas;
                }
            }
        }

        if (sourceType === 'emissoes_fugitivas' || sourceType === 'fertilizantes') {
            cleanedRow['unidade'] = 'kg';
        }
        
        if (sourceType === 'combustao_movel' && cleanedRow.tipo_entrada) {
            if (cleanedRow.tipo_entrada === 'consumo') {
                ['distancia_percorrida', 'unidade_distancia', 'tipo_veiculo'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_entrada === 'distancia') {
                ['combustivel', 'consumo', 'unidade_consumo'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'efluentes_controlados' && cleanedRow.tratamento_ou_destino) {
            if (cleanedRow.tratamento_ou_destino === 'Tratamento') {
                cleanedRow.tipo_destino_final = '';
            } else if (cleanedRow.tratamento_ou_destino === 'Destino Final') {
                cleanedRow.tipo_tratamento = '';
            }
        } else if (sourceType === 'mudanca_uso_solo' && cleanedRow.uso_solo_anterior) {
            if (cleanedRow.uso_solo_anterior !== 'Vegetação natural') {
                ['bioma', 'fitofisionomia', 'tipo_area'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'purchased_goods_services' && cleanedRow.tipo_item) {
            if (cleanedRow.tipo_item === 'Serviço') {
                cleanedRow.quantidade = '';
                cleanedRow.unidade = '';
            }
        } else if (sourceType === 'capital_goods') {
            cleanedRow.unidade = 'Unidades';
        } else if (sourceType === 'upstream_transport' && cleanedRow.tipo_reporte) {
            if (cleanedRow.tipo_reporte === 'Consumo') {
                ['classificacao_veiculo', 'distancia_trecho', 'unidade_distancia', 'carga_transportada', 'numero_viagens'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Distância') {
                ['combustivel', 'consumo', 'unidade_consumo'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'business_travel_land' && cleanedRow.tipo_reporte) {
            if (cleanedRow.tipo_reporte === 'Consumo') {
                ['distancia_percorrida', 'unidade_distancia'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Distância') {
                ['combustivel', 'consumo', 'unidade_consumo'].forEach(k => cleanedRow[k] = '');
            }
        } else if ((sourceType === 'downstream_transport' || sourceType === 'waste_transport') && cleanedRow.tipo_reporte) {
            if (cleanedRow.tipo_reporte === 'Consumo') {
                ['classificacao_veiculo', 'distancia_trecho', 'unidade_distancia', 'carga_transportada', 'numero_viagens'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Distância') {
                ['combustivel', 'consumo', 'unidade_consumo'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'employee_commuting' && cleanedRow.tipo_reporte) {
            // --- SPRINT 20: Lógica para Transporte de Funcionários ---
            if (cleanedRow.tipo_reporte === 'Consumo') {
                ['distancia_km', 'endereco_funcionario', 'endereco_trabalho'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Distância') {
                ['tipo_combustivel', 'consumo', 'unidade_consumo', 'endereco_funcionario', 'endereco_trabalho'].forEach(k => cleanedRow[k] = '');
            } else if (cleanedRow.tipo_reporte === 'Endereço') {
                ['tipo_combustivel', 'consumo', 'unidade_consumo', 'distancia_km'].forEach(k => cleanedRow[k] = '');
            }
        } else if (sourceType === 'conservation_area') {
            // --- SPRINT 21: Lógica para Área de Conservação (Atualizado) ---
            if (cleanedRow.area_plantada === 'Não') {
                cleanedRow.plantio = ''; // Limpa o campo plantio (texto)
            }
        }
        
        return cleanedRow;
    }

    function generateTable(data, fromUpload = false) {
        if (!currentSchema) return;
        
        let tbody = tableContainer.querySelector('tbody');
        if (!tbody) {
             if (!fromUpload && data.length === 0) {
                tableContainer.innerHTML = `<p style="text-align: center; margin: 2rem 0;">Nenhuma fonte cadastrada para o ano de ${currentReportYear}. Cadastre na aba "Cadastro de Fontes".</p>`;
                return;
            }
            createEmptyTableAndHeaders();
            tbody = tableContainer.querySelector('tbody');
        }

        const headers = Object.keys(currentSchema.headerDisplayNames);

        data.forEach((originalRowData, index) => {
            const cleanedData = fromUpload ? sanitizeAndPreprocessRow(originalRowData) : originalRowData;
            const validationResult = currentSchema.validateRow(cleanedData, managedOptionsCache);
            const rowElement = buildTableRow(cleanedData, headers, index);
            tbody.appendChild(rowElement);

            for (const header in validationResult.errors) {
                const cell = rowElement.querySelector(`td[data-header="${header}"]`);
                if (cell) {
                    const el = cell.querySelector('input, select') || cell;
                    el.classList.add('invalid-cell');
                    el.setAttribute('title', validationResult.errors[header]);
                }
            }
            
            updateDisabledFields(rowElement, cleanedData);
        });
        
        const table = tableContainer.querySelector('table');
        if(table) createResizableHeaders(table);

        checkTableAndToggleSaveButton();
    }


    function createEmptyTableAndHeaders() {
        Object.values(maskInstances).forEach(mask => mask.destroy());
        maskInstances = {};
        maskIdCounter = 0;
        tableContainer.innerHTML = '';
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const tbody = document.createElement('tbody');
        const headerRow = document.createElement('tr');
        const headers = Object.keys(currentSchema.headerDisplayNames);
        
        headers.forEach(headerKey => {
            const th = document.createElement('th');
            // --- SPRINT 19: Lógica Dinâmica de Cabeçalho (ex: {ANO-1} -> 2023) ---
            const rawDisplayName = currentSchema.headerDisplayNames[headerKey] || headerKey;
            th.textContent = resolveDynamicHeader(rawDisplayName, currentReportYear);
            headerRow.appendChild(th);
        });
        
        const actionsTh = document.createElement('th');
        actionsTh.textContent = 'Ações';
        headerRow.appendChild(actionsTh);

        thead.appendChild(headerRow);
        table.appendChild(thead);
        table.appendChild(tbody);
        tableContainer.appendChild(table);
        
        tbody.addEventListener('click', handleTableClick);
        tbody.addEventListener('blur', (e) => handleTableChange(e, headers), true);
        tbody.addEventListener('change', (e) => handleTableChange(e, headers));
    }

    function buildTableRow(rowData, headers, rowIndex) {
        const row = document.createElement('tr');
        headers.forEach(header => {
            const cell = document.createElement('td');
            cell.dataset.header = header;
            const currentValue = rowData[header] || "";
            const isAutoFilledUnit = currentSchema.autoFillMap && Object.values(currentSchema.autoFillMap).some(rule => rule.targetColumn === header);
            
            // --- SPRINT 21: Lógica Dinâmica para Dropdowns (ex: Bioma -> Fitofisionomia) ---
            let options = managedOptionsCache[header];
            if (currentSchema.dependencyMap && currentSchema.dependencyMap.targetField === header) {
                // Se este campo é um alvo de dependência, busque as opções baseadas no gatilho
                const triggerHeader = currentSchema.dependencyMap.triggerField;
                const triggerValue = rowData[triggerHeader];
                if (triggerValue && currentSchema.dependencyMap.data[triggerValue]) {
                    options = currentSchema.dependencyMap.data[triggerValue];
                } else {
                    // Se não houver gatilho selecionado, mostra lista vazia ou todas (vamos mostrar vazio para forçar seleção)
                    options = []; 
                }
            }

            if (header === 'informar_cidade_uf') {
                cell.textContent = currentValue;
                cell.setAttribute('contenteditable', 'false');
                cell.style.backgroundColor = '#e9ecef';
                cell.style.color = '#495057';
            }
            else if (isAutoFilledUnit || (options && options.length === 1)) {
                cell.textContent = (options && options.length === 1) ? options[0] : currentValue;
                cell.setAttribute('contenteditable', 'false');
                cell.style.backgroundColor = '#e9ecef';
                cell.style.color = '#495057';
            } else if (options) {
                const select = document.createElement('select');
                select.innerHTML = '<option value="">-- Selecione --</option>';
                const displayMap = currentSchema.displayValueMap?.[header];
                options.forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = (displayMap && displayMap[optionValue]) ? displayMap[optionValue] : optionValue;
                    select.appendChild(option);
                });
                cell.appendChild(select);
                select.value = currentValue;
            } else if (DECIMAL_FIELDS.includes(header) || INTEGER_FIELDS.includes(header)) {
                const input = document.createElement('input');
                input.type = 'text';
                let safeValue = currentValue;
                if (typeof safeValue === 'string') {
                    const testValue = safeValue.replace(',', '.').trim();
                    if (testValue === '' || isNaN(parseFloat(testValue))) {
                        safeValue = '';
                    }
                }
                input.value = (safeValue !== '' && safeValue !== null && safeValue !== undefined) ? String(safeValue).replace('.', ',') : '';
                const maskId = `mask-${maskIdCounter++}`;
                input.id = maskId;
                cell.appendChild(input);
                let maskOptions;
                if (INTEGER_FIELDS.includes(header)) {
                    maskOptions = { mask: Number, scale: 0, thousandsSeparator: '.', lazy: false };
                } else { 
                    maskOptions = { mask: Number, scale: 10, thousandsSeparator: '.', radix: ',', mapToRadix: ['.', ','], lazy: false };
                }
                maskInstances[maskId] = IMask(input, maskOptions);
            } else if (header === 'unidade_empresarial' && currentSchema.hasUnits) {
                const select = document.createElement('select');
                select.innerHTML = '<option value="">-- Selecione --</option>';
                unitsList.forEach(unit => { const option = document.createElement('option'); option.value = unit.name; option.textContent = unit.name; select.appendChild(option); });
                cell.appendChild(select);
                select.value = currentValue;
            } else {
                cell.setAttribute('contenteditable', 'true');
                cell.textContent = currentValue;
            }
            row.appendChild(cell);
        });
        const actionsCell = document.createElement('td');
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'X';
        deleteBtn.className = 'delete-row-btn';
        deleteBtn.title = 'Deletar esta linha';
        actionsCell.appendChild(deleteBtn);
        row.appendChild(actionsCell);
        return row;
    }
    
    function getCellValue(cell) {
        const maskedInput = cell.querySelector('input[id^="mask-"]');
        if (maskedInput && maskInstances[maskedInput.id]) return maskInstances[maskedInput.id].unmaskedValue;
        const input = cell.querySelector('select, input');
        return input ? input.value : cell.textContent;
    }
    
    function getRowDataFromDOM(rowElement, headers) {
        const rowData = {};
        headers.forEach((header) => {
            const cell = rowElement.querySelector(`td[data-header="${header}"]`);
            if(cell) rowData[header] = getCellValue(cell);
        });
        return rowData;
    }
    
    function updateDisabledFields(rowElement, sanitizedData) {
        const sourceType = tableSelector.value;
        if (sourceType === 'combustao_movel') {
            const consumoFields = ['combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['distancia_percorrida', 'unidade_distancia', 'tipo_veiculo'];
            if (sanitizedData.tipo_entrada === 'consumo') {
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, consumoFields, false, false);
            } else if (sanitizedData.tipo_entrada === 'distancia') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, false, false);
            } else {
                setFieldsState(rowElement, distanciaFields, true, false);
                setFieldsState(rowElement, consumoFields, true, false);
            }
        } else if (sourceType === 'efluentes_controlados') {
            const tratamentoField = ['tipo_tratamento'];
            const destinoFinalField = ['tipo_destino_final'];
            if (sanitizedData.tratamento_ou_destino === 'Tratamento') {
                setFieldsState(rowElement, destinoFinalField, true, true);
                setFieldsState(rowElement, tratamentoField, false, false);
            } else if (sanitizedData.tratamento_ou_destino === 'Destino Final') {
                setFieldsState(rowElement, tratamentoField, true, true);
                setFieldsState(rowElement, destinoFinalField, false, false);
            } else {
                setFieldsState(rowElement, destinoFinalField, true, false);
                setFieldsState(rowElement, tratamentoField, true, false);
            }
        } else if (sourceType === 'mudanca_uso_solo') {
             const vegNaturalFields = ['bioma', 'fitofisionomia', 'tipo_area'];
             if (sanitizedData.uso_solo_anterior !== 'Vegetação natural') {
                setFieldsState(rowElement, vegNaturalFields, true, true);
             } else {
                setFieldsState(rowElement, vegNaturalFields, false, false);
             }
        } else if (sourceType === 'electricity_purchase') {
            const especificarFonteField = ['especificar_fonte'];
            const isSIN = sanitizedData.fonte_energia === 'Sistema Interligado Nacional';
            setFieldsState(rowElement, especificarFonteField, isSIN, isSIN);
        } else if (sourceType === 'purchased_goods_services') {
            const qtdUnidFields = ['quantidade', 'unidade'];
            if (sanitizedData.tipo_item === 'Serviço') {
                setFieldsState(rowElement, qtdUnidFields, true, true);
            } else {
                setFieldsState(rowElement, qtdUnidFields, false, false);
            }
        } else if (sourceType === 'upstream_transport') {
            const consumoFields = ['combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['classificacao_veiculo', 'distancia_trecho', 'unidade_distancia', 'carga_transportada', 'numero_viagens'];
            
            if (sanitizedData.tipo_reporte === 'Consumo') {
                setFieldsState(rowElement, distanciaFields, true, true); 
                setFieldsState(rowElement, consumoFields, false, false); 
            } else if (sanitizedData.tipo_reporte === 'Distância') {
                setFieldsState(rowElement, consumoFields, true, true); 
                setFieldsState(rowElement, distanciaFields, false, false); 
            } else {
                setFieldsState(rowElement, consumoFields, true, false);
                setFieldsState(rowElement, distanciaFields, true, false);
            }
        } else if (sourceType === 'business_travel_land') {
            const consumoFields = ['combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['distancia_percorrida', 'unidade_distancia'];
            // modal_viagem e km_reembolsado não entram aqui pois são sempre habilitados
            
            if (sanitizedData.tipo_reporte === 'Consumo') {
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, consumoFields, false, false);
            } else if (sanitizedData.tipo_reporte === 'Distância') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, false, false);
            } else {
                setFieldsState(rowElement, consumoFields, true, false);
                setFieldsState(rowElement, distanciaFields, true, false);
            }
        } else if (sourceType === 'downstream_transport' || sourceType === 'waste_transport') {
            const consumoFields = ['combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['classificacao_veiculo', 'distancia_trecho', 'unidade_distancia', 'carga_transportada', 'numero_viagens'];
            
            if (sanitizedData.tipo_reporte === 'Consumo') {
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, consumoFields, false, false);
            } else if (sanitizedData.tipo_reporte === 'Distância') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, false, false);
            } else {
                setFieldsState(rowElement, consumoFields, true, false);
                setFieldsState(rowElement, distanciaFields, true, false);
            }
        } else if (sourceType === 'employee_commuting') {
            // --- SPRINT 20: Lógica Visual para Transporte de Funcionários ---
            const consumoFields = ['tipo_combustivel', 'consumo', 'unidade_consumo'];
            const distanciaFields = ['distancia_km'];
            const enderecoFields = ['endereco_funcionario', 'endereco_trabalho'];

            if (sanitizedData.tipo_reporte === 'Consumo') {
                setFieldsState(rowElement, consumoFields, false, false);
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, enderecoFields, true, true);
            } else if (sanitizedData.tipo_reporte === 'Distância') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, false, false);
                setFieldsState(rowElement, enderecoFields, true, true);
            } else if (sanitizedData.tipo_reporte === 'Endereço') {
                setFieldsState(rowElement, consumoFields, true, true);
                setFieldsState(rowElement, distanciaFields, true, true);
                setFieldsState(rowElement, enderecoFields, false, false);
            } else {
                setFieldsState(rowElement, consumoFields, true, false);
                setFieldsState(rowElement, distanciaFields, true, false);
                setFieldsState(rowElement, enderecoFields, true, false);
            }
        } else if (sourceType === 'conservation_area') {
            // --- SPRINT 21: Lógica para Área de Conservação (Atualizado) ---
            const plantioField = ['plantio'];
            if (sanitizedData.area_plantada === 'Sim') {
                setFieldsState(rowElement, plantioField, false, false);
            } else {
                setFieldsState(rowElement, plantioField, true, true);
            }
        }
    }

    function updateValidationAppearance(rowElement) {
        const headers = Object.keys(currentSchema.headerDisplayNames);
        const rowData = getRowDataFromDOM(rowElement, headers);
        const validationResult = currentSchema.validateRow(rowData, managedOptionsCache);
        
        headers.forEach(header => {
            const cell = rowElement.querySelector(`td[data-header="${header}"]`);
            if (!cell) return;
            const el = cell.querySelector('input, select') || cell;
            el.classList.remove('invalid-cell');
            el.removeAttribute('title');
            if (validationResult.errors[header]) {
                el.classList.add('invalid-cell');
                el.setAttribute('title', validationResult.errors[header]);
            }
        });
    }

    function checkTableAndToggleSaveButton() {
        const hasAnyErrors = tableContainer.querySelector('.invalid-cell');
        const activeRows = Array.from(tableContainer.querySelectorAll('tbody tr')).filter(row => {
            return !row.querySelector('input:disabled, select:disabled');
        });
        
        const hasActiveRows = activeRows.length > 0;
        const areDataValid = !hasAnyErrors && hasActiveRows;

        saveButton.style.display = areDataValid ? 'inline-block' : 'none';
        
        const hasAnyRows = tableContainer.querySelector('tbody tr');
        exportButton.style.display = hasAnyRows ? 'inline-block' : 'none';

        if (hasAnyErrors && hasActiveRows) {
            feedbackDiv.textContent = "Dados inválidos. Corrija as células em vermelho.";
            feedbackDiv.style.color = 'red';
        } else if (areDataValid) {
            feedbackDiv.textContent = 'Todos os dados são válidos! Você pode salvar.';
            feedbackDiv.style.color = 'green';
        } else if (!hasActiveRows && hasAnyRows) {
            feedbackDiv.textContent = "Todos os dados exibidos já foram salvos.";
            feedbackDiv.style.color = 'green';
        } else {
            feedbackDiv.textContent = "";
        }
    }
    
    function handleTableClick(event) {
        if (event.target.classList.contains('delete-row-btn')) {
            const rowToDelete = event.target.closest('tr');
            if (confirm('Tem certeza que deseja remover esta linha da visualização?')) {
                rowToDelete.querySelectorAll('input[id^="mask-"]').forEach(input => {
                    if (maskInstances[input.id]) {
                        maskInstances[input.id].destroy();
                        delete maskInstances[input.id];
                    }
                });
                rowToDelete.remove();
                checkTableAndToggleSaveButton();
                saveDraft(); 
            }
        }
    }

    const setFieldsState = (row, fields, disable, clear) => {
        fields.forEach(fieldName => {
            const cell = row.querySelector(`td[data-header="${fieldName}"]`);
            if (cell) {
                const input = cell.querySelector('select, input');
                if (disable) {
                    if (clear) {
                        if (input) {
                            if (input.id && maskInstances[input.id]) {
                                maskInstances[input.id].unmaskedValue = '';
                            } else {
                                input.value = '';
                            }
                        } else {
                            // Limpa texto puro se não houver input (ex: unidades auto-preenchidas)
                            cell.textContent = '';
                        }
                    }
                    cell.style.backgroundColor = '#e9ecef';
                    if (input) input.disabled = true;
                } else {
                    const isAutoFilledUnit = currentSchema.autoFillMap && Object.values(currentSchema.autoFillMap).some(rule => rule.targetColumn === fieldName);
                    if(!isAutoFilledUnit) {
                        cell.style.backgroundColor = '';
                        const rowIsLocked = row.querySelector('.delete-row-btn').disabled === true;
                        if (input && !rowIsLocked) input.disabled = false;
                    }
                }
            }
        });
    };

    function handleTableChange(event, headers) {
        const element = event.target;
        const cell = element.closest('td');
        if (!cell) return;
        
        const editedRow = cell.parentElement;
        let rowData = getRowDataFromDOM(editedRow, headers);

        const headerOfEditedCell = cell.dataset.header;
        
        // 1. AutoFill Logic
        if (currentSchema.autoFillMap && currentSchema.autoFillMap[headerOfEditedCell]) {
            const rule = currentSchema.autoFillMap[headerOfEditedCell];
            const triggerValue = getCellValue(cell);
            const targetHeader = rule.targetColumn;
            const targetCell = editedRow.querySelector(`td[data-header="${targetHeader}"]`);
            if (targetCell) {
                targetCell.textContent = triggerValue ? (rule.map[triggerValue] || '') : '';
            }
            rowData = getRowDataFromDOM(editedRow, headers);
        }

        // 2. --- NOVO: Dependency Logic (Dropdowns Dinâmicos na Tabela) ---
        if (currentSchema.dependencyMap && currentSchema.dependencyMap.triggerField === headerOfEditedCell) {
            const triggerValue = getCellValue(cell);
            const targetHeader = currentSchema.dependencyMap.targetField;
            const targetCell = editedRow.querySelector(`td[data-header="${targetHeader}"]`);
            
            if (targetCell) {
                const targetSelect = targetCell.querySelector('select');
                if (targetSelect) {
                    targetSelect.innerHTML = '<option value="">-- Selecione --</option>';
                    
                    if (triggerValue && currentSchema.dependencyMap.data[triggerValue]) {
                        const newOptions = currentSchema.dependencyMap.data[triggerValue];
                        newOptions.forEach(opt => {
                            const option = document.createElement('option');
                            option.value = opt;
                            option.textContent = opt;
                            targetSelect.appendChild(option);
                        });
                    }
                    // Limpa o valor antigo, pois provavelmente é inválido para a nova lista
                    targetSelect.value = "";
                }
            }
            // Atualiza rowData com a nova informação (valor limpo)
            rowData = getRowDataFromDOM(editedRow, headers);
        }
        
        updateDisabledFields(editedRow, rowData);
        updateValidationAppearance(editedRow);
        checkTableAndToggleSaveButton();
        
        saveDraft();
    }

    tableSelector.addEventListener('change', async () => {
        const selectedKey = tableSelector.value;
        currentSchema = validationSchemas[selectedKey];
        
        uploadForm.reset(); 
        tableContainer.innerHTML = '';
        tableActions.style.display = 'none'; 
        feedbackDiv.textContent = '';
        saveButton.style.display = 'none';
        exportButton.style.display = 'none';
        currentReportYear = null;

        if (currentSchema) {
            const year = prompt("Por favor, digite o ano de reporte (ex: 2024):", new Date().getFullYear());
            if (!year || isNaN(parseInt(year)) || year.length !== 4) {
                alert("Ano inválido. Por favor, selecione a fonte novamente e digite um ano com 4 dígitos.");
                tableSelector.value = ""; 
                uploadSection.style.display = 'none';
                return;
            }
            currentReportYear = year; 

            uploadSection.style.display = 'block';
            tableActions.style.display = 'flex';
            downloadIntelligentBtn.style.display = 'inline-block';
            feedbackDiv.textContent = 'Carregando...';
            feedbackDiv.style.color = 'blue';

            try {
                await Promise.all([
                    currentSchema.hasUnits ? fetchUnits() : Promise.resolve(),
                    fetchManagedOptions(currentSchema) 
                ]);
                feedbackDiv.textContent = `Carregando fontes cadastradas para o ano de ${currentReportYear}...`;
                
                const response = await fetch(`/api/intelligent-template/${selectedKey}?format=json&year=${currentReportYear}`);
                if (!response.ok) throw new Error('Falha ao carregar template de dados.');
                
                const data = await response.json();
                feedbackDiv.textContent = '';
                generateTable(data, false);
                
                checkAndLoadDraft();
                
                // --- FORÇA SCROLL PARA BAIXO ---
                setTimeout(() => {
                    uploadSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);

            } catch (error) {
                console.error("Erro ao carregar dados da fonte:", error);
                feedbackDiv.textContent = `Erro: ${error.message}`;
                feedbackDiv.style.color = 'red';
            }
        } else {
            uploadSection.style.display = 'none';
        }
    });
    
    uploadForm.addEventListener('submit', async (e) => { 
        e.preventDefault(); 
        feedbackDiv.textContent = 'Enviando e validando arquivo...'; 
        const file = fileInput.files[0]; 
        if (!file) { feedbackDiv.textContent = 'Por favor, selecione um arquivo.'; return; } 
        const formData = new FormData(); 
        formData.append('file', file); 
        formData.append('source_type', tableSelector.value); 
        try { 
            const response = await fetch('/api/upload', { method: 'POST', body: formData }); 
            if (!response.ok) throw new Error(`Erro: ${response.statusText}`); 
            const data = await response.json(); 
            generateTable(data, true); 
            saveDraft();
        } catch (error) { 
            feedbackDiv.textContent = `Falha no upload: ${error.message}`; 
            feedbackDiv.style.color = 'red'; 
        } 
    });
    
    exportButton.addEventListener('click', async () => {
        if (!currentSchema || !tableSelector.value) return;
        
        const headers = Object.keys(currentSchema.headerDisplayNames);
        const dataToExport = [];
        
        document.querySelectorAll('#table-container tbody tr').forEach(row => {
            dataToExport.push(getRowDataFromDOM(row, headers));
        });

        if (dataToExport.length === 0) {
            alert("Não há dados na tabela para exportar.");
            return;
        }

        const friendlyData = dataToExport.map(row => {
            const newRow = {};
            for (const key in row) {
                let displayName = currentSchema.headerDisplayNames[key] || key;
                // --- SPRINT 19: Lógica Dinâmica na Exportação ---
                displayName = resolveDynamicHeader(displayName, currentReportYear);
                newRow[displayName] = row[key];
            }
            return newRow;
        });

        try {
            const response = await fetch('/api/export', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: friendlyData, tableName: tableSelector.value })
            });
            
            if (!response.ok) throw new Error("Erro ao gerar arquivo de exportação.");
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `${tableSelector.value}_dados_${currentReportYear}.xlsx`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            feedbackDiv.textContent = 'Dados exportados com sucesso! Você pode editar no Excel e fazer upload novamente.';
            feedbackDiv.style.color = 'green';
        } catch (error) {
            console.error("Erro na exportação:", error);
            feedbackDiv.textContent = 'Erro ao exportar dados.';
            feedbackDiv.style.color = 'red';
        }
    });

    downloadIntelligentBtn.addEventListener('click', async () => { 
        const sourceType = tableSelector.value; 
        if (!sourceType || !currentReportYear) {
            alert("Por favor, selecione uma fonte e um ano primeiro.");
            return;
        }

        feedbackDiv.textContent = 'Gerando template...'; 
        feedbackDiv.style.color = 'blue'; 
        try { 
            const response = await fetch(`/api/intelligent-template/${sourceType}?year=${currentReportYear}`); 
            if (!response.ok) { 
                const error = await response.json(); 
                throw new Error(error.message || 'Falha ao gerar o arquivo no servidor.'); 
            } 
            const blob = await response.blob(); 
            const url = window.URL.createObjectURL(blob); 
            const a = document.createElement('a'); 
            a.style.display = 'none'; 
            a.href = url; 
            const disposition = response.headers.get('Content-Disposition'); 
            let filename = `${sourceType}_template.xlsx`; 
            if (disposition && disposition.indexOf('attachment') !== -1) { 
                const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                const matches = filenameRegex.exec(disposition); 
                if (matches != null && matches[1]) { 
                    filename = matches[1].replace(/['"]/g, ''); 
                } 
            } 
            a.download = filename; 
            document.body.appendChild(a); 
            a.click(); 
            window.URL.revokeObjectURL(url); 
            a.remove(); 
            feedbackDiv.textContent = 'Template gerado com sucesso!'; 
            feedbackDiv.style.color = 'green'; 
        } catch (error) { 
            feedbackDiv.textContent = `Erro ao gerar template: ${error.message}`; 
            feedbackDiv.style.color = 'red'; 
        } 
    });

    function lockSavedRows() {
        const tbody = tableContainer.querySelector('tbody');
        if (!tbody) return;
        
        tbody.querySelectorAll('tr').forEach(row => {
            if (!row.classList.contains('saved-row')) {
                row.classList.add('saved-row');
                row.style.backgroundColor = '#d4edda'; 
                
                row.querySelectorAll('input, select').forEach(el => {
                    el.disabled = true;
                });
                
                const deleteBtn = row.querySelector('.delete-row-btn');
                if (deleteBtn) {
                    deleteBtn.disabled = true;
                    deleteBtn.style.opacity = '0.5';
                    deleteBtn.title = 'Item já salvo no banco de dados.';
                }
            }
        });
    }

    saveButton.addEventListener('click', async () => { 
        if (!currentSchema || !tableSelector.value) return; 
        
        const headers = Object.keys(currentSchema.headerDisplayNames); 
        const dataToSave = []; 
        
        document.querySelectorAll('#table-container tbody tr').forEach(row => { 
            const isLocked = row.querySelector('input:disabled, select:disabled');
            if (!isLocked) {
                dataToSave.push(getRowDataFromDOM(row, headers)); 
            }
        }); 
        
        if (dataToSave.length === 0) {
            feedbackDiv.textContent = "Não há novos dados para salvar.";
            return;
        }

        try { 
            const response = await fetch(`/api/save-data/${tableSelector.value}`, { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify(dataToSave), 
            }); 
            const result = await response.json(); 
            if (!response.ok) throw new Error(result.message); 
            
            const friendlyTableName = currentSchema.displayName; 
            feedbackDiv.textContent = `Dados de "${friendlyTableName}" salvos com sucesso!`; 
            feedbackDiv.style.color = 'green'; 
            
            lockSavedRows();
            
            clearDraft();
            
            checkTableAndToggleSaveButton(); 
            
        } catch (error) { 
            feedbackDiv.textContent = `Erro ao salvar: ${error.message}`; 
            feedbackDiv.style.color = 'red'; 
        } 
    });
    
    function populateSelector() { tableSelector.innerHTML = '<option value="">-- Selecione uma tabela --</option>';
    const sortedKeys = Object.keys(validationSchemas).sort((a, b) => validationSchemas[a].displayName.localeCompare(validationSchemas[b].displayName)); sortedKeys.forEach(key => { tableSelector.innerHTML += `<option value="${key}">${validationSchemas[key].displayName}</option>`; }); }

    loadNavbar();
    populateSelector();
});
</file>

<file path="shared/validators.js">
// arquivo: shared/validators.js

const normalizeString = (value) => {
    if (typeof value !== 'string') return '';
    return value
        .toLowerCase()
        .normalize('NFD').replace(/[\u0000-\u036f]/g, '')
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') 
        .trim();
};

// --- Listas de Fitofisionomias por Bioma (Constantes Auxiliares) ---
const BIOME_DATA = {
    "Amazônia": [
        "Floresta Ombrófila Aberta Aluvial", "Floresta Ombrófila Aberta Terras Baixas", "Floresta Ombrófila Aberta Submontana",
        "Floresta Estacional Decidual Terras Baixas", "Floresta Estacional Decidual Submontana", "Floresta Ombrófila Densa Aluvial",
        "Floresta Ombrófila Densa de Terras Baixas", "Floresta Ombrófila Densa Montana", "Floresta Ombrófila Densa Submontana",
        "Floresta Estacional Semidecidual aluvial", "Floresta Estacional Semidecidual de terras baixas", "Floresta Estacional Semidecidual montana",
        "Floresta Estacional Semidecidual Submontana", "Campinarana Arborizada", "Campinarana Arbustiva", "Campinarana Florestada",
        "Campinarana gramíneo lenhosa", "Vegetação com influência fluvial e/ou lacustre", "Pioneiras com influência fluviomarinha (mangue)",
        "Pioneiras com influência Marinha (restinga)", "Refúgio montano", "Savana Arborizada", "Savana Florestada", "Savana Gramíneo- Lenhosa",
        "Savana Parque", "Savana Estépica Arborizada", "Savana Estépica Florestada", "Savana Estépica Gramíneo Lenhosa", "Savana Estépica Parque",
        "Floresta Ombrófila Aberta Montana", "Floresta Estacional Decidual Aluvial", "Refúgio Alto-Montano", "Refúgio Submontano",
        "Contato Savana/Formações Pioneiras - Específico para Formação Pioneira com Influência Marinha (Restinga)", "Contato Savana/Floresta Estacional SN",
        "Contato Savana/Floresta Ombrófila SO", "Contato Savana/Savana-Estépica ST", "Contato Savana- Estépica/Floresta Estacional TN",
        "Contato Campinarana/Floresta Ombrófila LO", "Contato Floresta Ombrófila/Floresta Estacional ON", "Savana-Estépica", "Savana",
        "Áreas das Formações Pioneira", "Campinarana"
    ],
    "Cerrado": [
        "Floresta Ombrófila Aberta Aluvial", "Floresta Ombrófila Aberta das Terras Baixas", "Floresta Ombrófila Aberta Submontana",
        "Floresta Estacional Decidual Aluvial", "Floresta Estacional Decidual das Terras Baixas", "Floresta Estacional Decidual Montana/BA",
        "Floresta Estacional Decidual Montana/GO", "Floresta Estacional Decidual Montana/MG", "Floresta Estacional Decidual Montana/PI",
        "Floresta Estacional Decidual Montana/MS", "Floresta Estacional Decidual Montana/TO", "Floresta Estacional Decidual Submontana/BA",
        "Floresta Estacional Decidual Submontana/GO", "Floresta Estacional Decidual Submontana/MA", "Floresta Estacional Decidual Submontana/MG",
        "Floresta Estacional Decidual Submontana/PI", "Floresta Estacional Decidual Submontana/TO", "Floresta Estacional Decidual Submontana/MS",
        "Floresta Estacional Decidual Submontana/MT", "Floresta Estacional Decidual Submontana/SP", "Floresta Ombrófila Densa Aluvial",
        "Floresta Ombrófila Densa de Terras Baixas", "Floresta Ombrófila Densa Submontana", "Estepe Gramíneo-Lenhosa",
        "Floresta Estacional Semidecidual Aluvial/MA", "Floresta Estacional Semidecidual Aluvial/PA", "Floresta Estacional Semidecidual Aluvial/TO",
        "Floresta Estacional Semidecidual Aluvial/BA", "Floresta Estacional Semidecidual Aluvial/GO", "Floresta Estacional Semidecidual Aluvial/MG",
        "Floresta Estacional Semidecidual Aluvial/PI", "Floresta Estacional Semidecidual Aluvial/PR", "Floresta Estacional Semidecidual Aluvial/SP",
        "Floresta Estacional Semidecidual Aluvial/MS", "Floresta Estacional Semidecidual Aluvial/MT", "Floresta Estacional Semidecidual das Terras Baixas/MA",
        "Floresta Estacional Semidecidual das Terras Baixas/MT", "Floresta Estacional Semidecidual das Terras Baixas/GO", "Floresta Estacional Semidecidual das Terras Baixas/PI",
        "Floresta Estacional Semidecidual Montana/BA", "Floresta Estacional Semidecidual Montana/PI", "Floresta Estacional Semidecidual Montana/GO",
        "Floresta Estacional Semidecidual Montana/MG", "Floresta Estacional Semidecidual Montana/MS", "Floresta Estacional Semidecidual Montana/PR",
        "Floresta Estacional Semidecidual Montana/SP", "Floresta Estacional Semidecidual Montana/TO", "Floresta Estacional Semidecidual Submontana/BA",
        "Floresta Estacional Semidecidual Submontana/MA", "Floresta Estacional Semidecidual Submontana/PI", "Floresta Estacional Semidecidual Submontana/GO/MG/MS/MT/SP/TO",
        "Floresta Estacional Semidecidual Submontana/MG", "Floresta Estacional Semidecidual Submontana/MS", "Floresta Estacional Semidecidual Submontana/MT",
        "Floresta Estacional Semidecidual Submontana/SP", "Floresta Estacional Semidecidual Submontana/TO", "Floresta Ombrófila Mista Aluvial",
        "Floresta Ombrófila Mista Alto-montana", "Floresta Ombrófila Mista Montana", "Contato Floresta Ombrófila/Floresta Estacional", "Formação Pioneira",
        "Formação Pioneira com influência fluvial e/", "Formação Pioneira com influência fluvio- marinha (mangue)", "Formação Pioneira com influência marinha (restinga)",
        "Refúgio Montano", "Savana", "Savana Arborizada", "Savana Florestada/PR", "Savana Florestada/SP", "Savana Florestada/BA", "Savana Florestada/DF",
        "Savana Florestada/GO", "Savana Florestada/MG", "Savana Florestada/MS", "Savana Florestada/MT", "Savana Florestada/MA", "Savana Florestada/PI",
        "Savana Florestada/TO", "Savana Gramíneo-lenhosa", "Contato Savana/Floresta Ombrófila Mista", "Contato Savana/Floresta Estacional",
        "Contato Savana/Floresta Ombrófila", "Savana Parque", "Contato Savana/Savana- Estépica", "Contato Savana/Savana- Estépica/Floresta Estacional",
        "Savana-Estépica", "Savana Estépica Arborizada", "Savana Estépica Florestada", "Savana Estépica Gramíneo-lenhosa",
        "Contato Savana- Estépica/Floresta Estacional", "Savana Estépica Parque"
    ],
    "Mata_Atlântica": [
        "Floresta Ombrófila Aberta Aluvial", "Floresta Ombrófila Aberta Terras baixas", "Floresta Ombrófila Aberta Montana",
        "Floresta Ombrófila Aberta Submontana", "Floresta Estacional Decidual Aluvial", "Floresta Estacional Decidual Terras baixas",
        "Floresta Estacional Decidual Montana", "Floresta Estacional Decidual Submontana", "Floresta Ombrófila Densa (Floresta Tropical Pluvial)",
        "Floresta Ombrófila Densa Aluvial", "Floresta Ombrófila Densa Terras baixas", "Floresta Ombrófila Densa Alto-Montana",
        "Floresta Ombrófila Densa Montana", "Floresta Ombrófila Densa Submontana", "Estepe", "Estepe Gramíneo-Lenhosa",
        "Contato EstepeFloresta Ombrófila Mista", "Contato Estepe/Floresta Estacional", "Floresta Estacional Semidecidual",
        "Floresta Estacional Semidecidual Aluvial", "Floresta Estacional Semidecidual Terras baixas", "Floresta Estacional Semidecidual Montana",
        "Floresta Estacional Semidecidual Submontana", "Campinarana", "Campinarana arborizada", "Campinarana Gramíneo-Lenhosa",
        "Floresta Ombrófila Mista", "Floresta Ombrófila Mista Aluvial", "Floresta Ombrófila Mista Alto-Montana", "Floresta Ombrófila Mista Montana",
        "Floresta Ombrófila Mista Submontana", "Contato Floresta Estacional/Floresta Ombrófila Mista", "Contato Floresta Estacional/Formações Pioneiras Específico para Formação Pioneira com Influência Marinha (Restinga)",
        "Contato Floresta Ombrófila Densa/Floresta Ombrófila Mista", "Contato Floresta Ombrófila/Floresta Estacional",
        "Contato Floresta Ombrófila/Formações Pioneiras Específico para Formação Pioneira com Influência Marinha (Restinga)", "Áreas das Formações Pioneiras",
        "Vegetação com influência fluvial e/ou lacustre", "Vegetação com influência marinha (Restinga)", "Vegetação com influência marinha (Restinga)",
        "Refúgios Alto Montanos", "Refúgios montanos", "Savana", "Savana arborizada", "Savana florestada", "Savana Gramíneo-Lenhosa",
        "Contato Savana/Floresta Ombrófila Mista", "Contato Savana/Floresta Estacional", "Contato Savana/Floresta Ombrófila",
        "Contato Savana/Formações Pioneiras", "Savana parque", "Contato Savana/Formações pioneiras Específico para Formação Pioneira com Influência Marinha (Restinga)",
        "Contato Savana/Savana-Estépica", "Savana- Estépica arborizada", "Savana- Estépica florestada", "Savana- Estépica Gramíneo-Lenhosa",
        "Contato Savana-Estépica/Floresta Estacional"
    ],
    "Caatinga": [
        "Floresta Ombrófila Aberta Aluvial", "Floresta Ombrófila Aberta Terras Baixas", "Floresta Ombrófila Aberta Montana",
        "Afloramento Rochoso", "Floresta Ombrófila Aberta Submontana", "Floresta Estacional Decidual Aluvial",
        "Floresta Estacional Decidual Terras Baixas", "Floresta Estacional Decidual Montana", "Floresta Estacional Decidual Submontana",
        "Floresta Ombrófila Densa Aluvial", "Floresta Ombrófila Densa Montana", "Dunas", "Floresta Ombrófila Densa Submontana",
        "Floresta Estacional Semidecidual aluvial", "Floresta Estacional Semidecidual de terras baixas", "Floresta Estacional Semidecidual Montana",
        "Floresta Estacional Semidecidual Submontana", "Vegetação com influência fluvial e/ou lacustre", "Pioneiras com influência fluviomarinha (mangue)",
        "Pioneiras com influência Marinha (restinga)", "Refúgio Montano", "Savana Arborizada", "Savana Florestada", "Savana Gramíneo- Lenhosa",
        "Contato Savana/Floresta", "Savana Parque", "Contato Savana/Formações pioneiras Específico para Formação Pioneira com Influência Marinha (Restinga)",
        "Savana Estépica Arborizada (caatinga aberta)", "Savana Estépica Florestada (caatinga densa)", "Savana Estépica Gramíneo Lenhosa",
        "Contato Savana/Floresta Estacional", "Savana Estépica Parque"
    ],
    "Pampa": [
        "Floresta Estacional Decidual Aluvial", "Floresta Estacional Decidual Terras baixas", "Floresta Estacional Decidual Montana",
        "Floresta Estacional Decidual Submontana", "Floresta Ombrófla Densa Aluvial", "Floresta Ombrófla Densa Terras baixas",
        "Floresta Ombrófla Densa Montana", "Dunas", "Floresta Ombrófla Densa Submontana", "Estepe", "Estepe Arborizada",
        "Estepe Gramíneo Lenhosa", "Estepe Parque", "Contato Estepe- Floresta Ombrófila Mista", "Contato Estepe- Floresta Estacional",
        "Contato Estepe- Formações", "Floresta Estacional Semidecidual Aluvial", "Floresta Estacional Semidecidual Terras baixas",
        "Floresta Estacional Semidecidual Montana", "Floresta Estacional Semidecidual Submontana", "Floresta Ombrófla Mista Aluvial",
        "Floresta Ombrófla Mista Submontana", "Contato Floresta Estacional- Floresta Ombrófila Mista",
        "Contato Floresta Estacional- Formações Pioneiras com Influência Marinha (Restinga)", "Contato Floresta Ombrófila Densa-Floresta Ombrófila Mista",
        "Contato Floresta Ombrófila- Formações Pioneiras com Influência Marinha (Restinga)", "Áreas das Formações Pioneiras",
        "Vegetação com influência Fluvial e/ou lacustre", "Vegetação com influência Fluviomarinha", "Vegetação com influência Marinha (Restinga)",
        "Savana Estépica", "Savana Estépica Gramíneo-Lenhosa", "Savana Estépica Parque"
    ],
    "Pantanal": [
        "Floresta Estacional Decidual Aluvial", "Floresta Estacional Decidual Terras baixas", "Floresta Estacional Decidual Submontana",
        "Floresta Estacional Semidecidual Aluvial", "Floresta Estacional Semidecidual Terras baixas", "Floresta Estacional Semidecidual Submontana",
        "Contato Savana/Floresta Estacional", "Contato Savana- Estépica/Floresta Estacional", "Savana", "Savana arborizada", "Savana florestada",
        "Contato Savana/Savana- Estépica", "Savana-Estépica", "Savana- Estépica arborizada", "Savana- Estépica florestada", "Savana",
        "Savana Estépica Gramíneo- Lenhosa", "Savana parque", "Savana-Estépica parque"
    ]
};

// Flatten para valid options no importer inicial
const ALL_FITOFISIONOMIAS = [...new Set(Object.values(BIOME_DATA).flat())].sort();

export const validationSchemas = {
    // --- SPRINT 21: ÁREA DE CONSERVAÇÃO ---
    conservation_area: {
        displayName: "Área de Conservação",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            // DESCRIÇÃO REMOVIDA DAQUI - Outros campos identificam a fonte
            bioma: "Bioma",
            fitofisionomia: "Fitofisionomia",
            area_plantada: "Área de conservação plantada?",
            plantio: "Plantio",
            area_inicio_ano: "Área (hectare) - 01/01/{ANO}",
            area_fim_ano: "Área (hectare) - 31/12/{ANO}",
            motivo_alteracao: "Motivo Aumento/Redução",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            bioma: ["Amazônia", "Cerrado", "Mata_Atlântica", "Caatinga", "Pampa", "Pantanal"],
            fitofisionomia: ALL_FITOFISIONOMIAS,
            area_plantada: ["Sim", "Não"]
        },
        autoFillMap: {},
        dependencyMap: {
            triggerField: "bioma",
            targetField: "fitofisionomia",
            data: BIOME_DATA
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            // 1. Campos Padrão
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            
            // 3. Bioma e Fitofisionomia (Dependência)
            if (!this.validOptions.bioma.includes(rowData.bioma)) {
                errors.bioma = "Selecione um bioma válido.";
            }
            
            // Valida se a fitofisionomia existe e se pertence ao bioma selecionado
            if (rowData.bioma) {
                const validFitosForBiome = BIOME_DATA[rowData.bioma];
                if (!validFitosForBiome) {
                    errors.bioma = "Bioma desconhecido na base de dados.";
                } else {
                    if (!rowData.fitofisionomia) {
                        errors.fitofisionomia = "Obrigatório.";
                    } else if (!validFitosForBiome.includes(rowData.fitofisionomia)) {
                        errors.fitofisionomia = `Esta fitofisionomia não pertence ao bioma ${rowData.bioma}.`;
                    }
                }
            } else if (!rowData.fitofisionomia) {
                errors.fitofisionomia = "Obrigatório.";
            }

            // 4. Área Plantada e Plantio (Texto)
            const normalizedPlantada = normalizeString(rowData.area_plantada);
            if (['sim', 's'].includes(normalizedPlantada)) rowData.area_plantada = 'Sim';
            else if (['nao', 'n'].includes(normalizedPlantada)) rowData.area_plantada = 'Não';

            if (!this.validOptions.area_plantada.includes(rowData.area_plantada)) {
                errors.area_plantada = "Deve ser 'Sim' ou 'Não'.";
            }

            if (rowData.area_plantada === 'Sim') {
                if (!isFilled(rowData.plantio)) {
                    errors.plantio = "Obrigatório se a área for plantada.";
                }
            } else {
                if (isFilled(rowData.plantio)) {
                    errors.plantio = "Deve estar vazio se a área não for plantada.";
                }
            }

            // 5. Áreas (Floats)
            const areaInicioVal = rowData.area_inicio_ano;
            if (!isFilled(areaInicioVal) || isNaN(parseFloat(areaInicioVal)) || parseFloat(areaInicioVal) < 0) {
                errors.area_inicio_ano = "Deve ser um número positivo ou zero.";
            }

            const areaFimVal = rowData.area_fim_ano;
            if (!isFilled(areaFimVal) || isNaN(parseFloat(areaFimVal)) || parseFloat(areaFimVal) < 0) {
                errors.area_fim_ano = "Deve ser um número positivo ou zero.";
            }

            // 6. Motivo da Alteração
            if (isFilled(areaInicioVal) && isFilled(areaFimVal)) {
                const areaInicio = parseFloat(areaInicioVal);
                const areaFim = parseFloat(areaFimVal);
                // Validar motivo se necessário no futuro
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    electricity_purchase: {
        displayName: "Compra de Eletricidade",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            fonte_energia: "Fonte de Energia",
            especificar_fonte: "Especificar Fonte",
            consumo: "Consumo",
            unidade_medida: "Unidade de Medida",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            fonte_energia: ["Sistema Interligado Nacional", "Mercado Livre Convencional", "Mercado Livre Incentivado", "Fonte Energética Específica"],
            especificar_fonte: ["Solar", "Eólica", "Biomassa"],
            unidade_medida: ["kWh", "MWh"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = `Período inválido.`;
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";

            if (!this.validOptions.fonte_energia.includes(rowData.fonte_energia)) {
                errors.fonte_energia = "Selecione uma fonte de energia válida.";
            }

            const consumoVal = rowData.consumo;
            if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) {
                errors.consumo = `Entrada inválida ('${consumoVal}'). Insira um número decimal e positivo.`;
            }

            if (!this.validOptions.unidade_medida.includes(rowData.unidade_medida)) {
                errors.unidade_medida = "Selecione 'kWh' ou 'MWh'.";
            }

            const isSIN = rowData.fonte_energia === 'Sistema Interligado Nacional';
            if (!isSIN) {
                if (!this.validOptions.especificar_fonte.includes(rowData.especificar_fonte)) {
                    errors.especificar_fonte = "Obrigatório selecionar uma especificação para esta fonte de energia.";
                }
            } else {
                if (isFilled(rowData.especificar_fonte)) {
                    errors.especificar_fonte = "Este campo só deve ser preenchido se a fonte não for SIN.";
                }
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    solid_waste: {
        displayName: "Resíduos Sólidos",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            destinacao_final: "Destinação Final",
            tipo_residuo: "Tipo de Resíduo",
            quantidade_gerado: "Quantidade Gerado",
            unidade: "Unidade",
            informar_cidade_uf: "Cidade/UF de Destino",
            local_controlado_empresa: "O local de disposição é controlado pela empresa?",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            destinacao_final: ["Aterro", "Compostagem", "Incineração", "Cogeração", "Reciclagem"],
            tipo_residuo: [
                "A - Papéis/papelão",
                "C - Resíduos alimentares",
                "D - Madeira",
                "E - Resíduos de jardim e parque",
                "F - Fraldas",
                "G - Borracha e couro",
                "H - Lodo de esgoto",
                "I - Outros materiais inertes",
                "J - Outros Resíduos Orgânicos"
            ],
            unidade: ["Toneladas", "Quilogramas"],
            informar_cidade_uf: ["Sim", "Não"],
            local_controlado_empresa: ["Sim", "Não"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = `Período inválido.`;
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";

            if (!this.validOptions.destinacao_final.includes(rowData.destinacao_final)) {
                errors.destinacao_final = "Selecione uma destinação válida.";
            }

            if (!this.validOptions.tipo_residuo.includes(rowData.tipo_residuo)) {
                errors.tipo_residuo = "Selecione um tipo de resíduo válido.";
            }

            const quantidadeVal = rowData.quantidade_gerado;
            if (!isFilled(quantidadeVal) || isNaN(parseFloat(quantidadeVal)) || parseFloat(quantidadeVal) <= 0) {
                errors.quantidade_gerado = `Entrada inválida ('${quantidadeVal}'). Insira um número decimal e positivo.`;
            }

            if (!this.validOptions.unidade.includes(rowData.unidade)) {
                errors.unidade = "Selecione 'Toneladas' ou 'Quilogramas'.";
            }
            
            if (rowData.destinacao_final === 'Aterro') {
                // Validação removida pois o campo agora é texto livre preenchido pelo cadastro
            } else {
                if (isFilled(rowData.informar_cidade_uf)) {
                    errors.informar_cidade_uf = "Este campo só deve ser preenchido se a destinação for 'Aterro'.";
                }
            }
            
            const normalizedControlado = normalizeString(rowData.local_controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.local_controlado_empresa = 'Sim'; } 
            else if (['nao', 'n'].includes(normalizedControlado)) { rowData.local_controlado_empresa = 'Não'; }
            if (!this.validOptions.local_controlado_empresa.includes(rowData.local_controlado_empresa)) {
                errors.local_controlado_empresa = "Deve ser 'Sim' ou 'Não'.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    combustao_movel: {
        displayName: "Combustão Móvel",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            descricao_fonte: "Descrição da Fonte",
            tipo_entrada: "Tipo de Entrada",
            combustivel: "Combustível",
            consumo: "Consumo",
            unidade_consumo: "Unidade de Consumo",
            distancia_percorrida: "Distância Percorrida",
            unidade_distancia: "Unidade da Distância",
            tipo_veiculo: "Tipo de Veículo",
            controlado_empresa: "Controlado pela Empresa?",
            comentarios: "Comentários"
        },
        displayValueMap: {
            tipo_entrada: {
                consumo: "Por Consumo",
                distancia: "Por Distância"
            }
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            controlado_empresa: ["Sim", "Não"],
            tipo_entrada: ["consumo", "distancia"],
            combustivel: [
                "Gasolina Automotiva", "Óleo Diesel", "Gás Natural Veicular (GNV)", "Gás Natural Liquefeito (GNL)", "Gás Liquefeito de Petróleo (GLP)", "Querosene de Aviação", "Gasolina de Aviação", "Lubrificantes", "Metanol", "Óleo Combustível", "Etanol Hidratado", "Biodiesel (B100)", "Biometano", "Bioquerosene (SAF)", "HVO (diesel verde)", "Biometanol", "Etanol Anidro"
            ],
            unidade_consumo: ["Litros", "m³", "kg"],
            unidade_distancia: ["Km", "Milhas"],
            tipo_veiculo: [
                "Automóvel a gasolina", "Automóvel a etanol", "Automóvel flex a gasolina", "Automóvel flex a etanol", "Motocicleta a gasolina", "Motocicleta flex a gasolina", "Motocicleta flex a etanol", "Veículo comercial leve a gasolina", "Veículo comercial leve a etanol", "Veículo comercial leve flex a gasolina", "Veículo comercial leve flex a etanol", "Veículo comercial leve a diesel", "Micro-ônibus a diesel", "Ônibus rodoviário a diesel", "Ônibus urbano a diesel", "Caminhão - rígido (3,5 a 7,5 toneladas)", "Caminhão - rígido (7,5 a 17 toneladas)", "Caminhão - rígido (acima de 17 toneladas)", "Caminhão - rígido (média)", "Caminhão - articulado (3,5 a 33 toneladas)", "Caminhão - articulado (acima de 33 toneladas)", "Caminhão - articulado (média)", "Caminhão - caminhão (média)", "Caminhão refrigerado - rígido (3,5 a 7,5 toneladas)", "Caminhão refrigerado - rígido (7,5 a 17 toneladas)", "Caminhão refrigerado - rígido (acima de 17 toneladas)", "Caminhão refrigerado - rígido (média)", "Caminhão refrigerado - articulado (3,5 a 33 toneladas)", "Caminhão refrigerado - articulado (acima de 33 toneladas)", "Caminhão refrigerado - articulado (média)", "Caminhão refrigerado - caminhão (média)", "Automóvel a GNV"
            ]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Gasolina Automotiva": "Litros", "Óleo Diesel": "Litros", "Gás Natural Veicular (GNV)": "m³", "Gás Natural Liquefeito (GNL)": "Litros", "Gás Liquefeito de Petróleo (GLP)": "kg", "Querosene de Aviação": "Litros", "Gasolina de Aviação": "Litros", "Lubrificantes": "Litros", "Metanol": "Litros", "Óleo Combustível": "Litros", "Etanol Hidratado": "Litros", "Biodiesel (B100)": "Litros", "Biometano": "m³", "Bioquerosene (SAF)": "Litros", "HVO (diesel verde)": "Litros", "Biometanol": "Litros", "Etanol Anidro": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';
            
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = `Período inválido.`;
            if (!rowData.descricao_fonte) errors.descricao_fonte = "Obrigatório.";
            
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Não'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'Não'."; }

            if (!this.validOptions.tipo_entrada.includes(rowData.tipo_entrada)) {
                errors.tipo_entrada = "Deve ser 'consumo' ou 'distancia'.";
            } else {
                if (rowData.tipo_entrada === 'consumo') {
                    if (!this.validOptions.combustivel.includes(rowData.combustivel)) { errors.combustivel = "Selecione um combustível válido."; }
                    const consumoVal = rowData.consumo;
                    if (consumoVal === '' || isNaN(parseFloat(consumoVal))) { errors.consumo = `Entrada inválida ('${consumoVal}'). Insira um número.`; }
                    if (this.autoFillMap.combustivel.map[rowData.combustivel] !== rowData.unidade_consumo) { errors.unidade_consumo = `Unidade incorreta para o combustível.`; }
                    if (isFilled(rowData.distancia_percorrida)) errors.distancia_percorrida = "Deve estar vazio para entrada por consumo.";
                    if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve estar vazio para entrada por consumo.";
                    if (isFilled(rowData.tipo_veiculo)) errors.tipo_veiculo = "Deve estar vazio para entrada por consumo.";
                } else if (rowData.tipo_entrada === 'distancia') {
                    const distanciaVal = rowData.distancia_percorrida;
                    if (distanciaVal === '' || isNaN(parseFloat(distanciaVal))) { errors.distancia_percorrida = `Entrada inválida ('${distanciaVal}'). Insira um número.`; }
                    if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) { errors.unidade_distancia = "Selecione 'Km' ou 'Milhas'."; }
                    if (!this.validOptions.tipo_veiculo.includes(rowData.tipo_veiculo)) { errors.tipo_veiculo = "Selecione um tipo de veículo válido."; }
                    if (isFilled(rowData.combustivel)) errors.combustivel = "Deve estar vazio para entrada por distância.";
                    if (isFilled(rowData.consumo)) errors.consumo = "Deve estar vazio para entrada por distância.";
                    if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve estar vazio para entrada por distância.";
                }
            }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    combustao_estacionaria: {
        displayName: "Combustão Estacionária",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano", periodo: "Período", unidade_empresarial: "Unidade Empresarial", descricao_da_fonte: "Descrição da Fonte", combustivel_estacionario: "Combustível", consumo: "Consumo", unidade: "Unidade", controlado_empresa: "Controlado pela Empresa?", comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            combustivel_estacionario: [
                "Acetileno", "Alcatrão", "Asfaltos", "Bagaço de Cana", "Biodiesel (B100)", 
                "Biogás (outros)", "Biogás de aterro", "Biometano", "Caldo de Cana", "Carvão Metalúrgico Importado", 
                "Carvão Metalúrgico Nacional", "Carvão Vapor 3100 kcal / kg", "Carvão Vapor 3300 kcal / kg", 
                "Carvão Vapor 3700 kcal / kg", "Carvão Vapor 4200 kcal / kg", "Carvão Vapor 4500 kcal / kg", 
                "Carvão Vapor 4700 kcal / kg", "Carvão Vapor 5200 kcal / kg", "Carvão Vapor 5900 kcal / kg", 
                "Carvão Vapor 6000 kcal / kg", "Carvão Vapor sem Especificação", "Carvão Vegetal", 
                "Coque de Carvão Mineral", "Coque de Petróleo", "Etano", "Etanol Anidro", "Etanol Hidratado", 
                "Gás de Coqueria", "Gás de Refinaria", "Gás Liquefeito de Petróleo (GLP)", "Gás Natural Seco", 
                "Gás Natural Úmido", "Gasolina Automotiva (pura)", "Gasolina de Aviação", "Lenha Comercial", 
                "Licor Negro (Lixívia)", "Líquidos de Gás Natural (LGN)", "Lubrificantes", "Melaço", "Nafta", 
                "Óleo Combustível", "Óleo de Xisto", "Óleo Diesel (puro)", "Óleos Residuais", 
                "Outros Produtos de Petróleo", "Parafina", "Petróleo Bruto", "Querosene de Aviação", 
                "Querosene Iluminante", "Resíduos Industriais", "Resíduos Municipais (fração biomassa)", 
                "Resíduos Municipais (fração não-biomassa)", "Resíduos Vegetais", "Solventes", "Turfa", 
                "Xisto Betuminoso e Areias Betuminosas"
            ],
            unidade: ["kg", "m³", "Toneladas", "Litros", "TJ"],
            controlado_empresa: ["Sim", "Não"],
        },
        autoFillMap: {
            combustivel_estacionario: {
                targetColumn: "unidade",
                map: {
                    "Acetileno": "kg", "Alcatrão": "m³", "Asfaltos": "m³", "Bagaço de Cana": "Toneladas", 
                    "Biodiesel (B100)": "Litros", "Biogás (outros)": "Toneladas", "Biogás de aterro": "Toneladas", 
                    "Biometano": "Toneladas", "Caldo de Cana": "Toneladas", "Carvão Metalúrgico Importado": "Toneladas", 
                    "Carvão Metalúrgico Nacional": "Toneladas", "Carvão Vapor 3100 kcal / kg": "Toneladas", 
                    "Carvão Vapor 3300 kcal / kg": "Toneladas", "Carvão Vapor 3700 kcal / kg": "Toneladas", 
                    "Carvão Vapor 4200 kcal / kg": "Toneladas", "Carvão Vapor 4500 kcal / kg": "Toneladas", 
                    "Carvão Vapor 4700 kcal / kg": "Toneladas", "Carvão Vapor 5200 kcal / kg": "Toneladas", 
                    "Carvão Vapor 5900 kcal / kg": "Toneladas", "Carvão Vapor 6000 kcal / kg": "Toneladas", 
                    "Carvão Vapor sem Especificação": "Toneladas", "Carvão Vegetal": "Toneladas", 
                    "Coque de Carvão Mineral": "Toneladas", "Coque de Petróleo": "m³", "Etano": "Toneladas", 
                    "Etanol Anidro": "Litros", "Etanol Hidratado": "Litros", "Gás de Coqueria": "Toneladas", 
                    "Gás de Refinaria": "Toneladas", "Gás Liquefeito de Petróleo (GLP)": "Toneladas", 
                    "Gás Natural Seco": "m³", "Gás Natural Úmido": "m³", "Gasolina Automotiva (pura)": "Litros", 
                    "Gasolina de Aviação": "Litros", "Lenha Comercial": "Toneladas", "Licor Negro (Lixívia)": "Toneladas", 
                    "Líquidos de Gás Natural (LGN)": "Toneladas", "Lubrificantes": "Litros", "Melaço": "Toneladas", 
                    "Nafta": "m³", "Óleo Combustível": "Litros", "Óleo de Xisto": "Toneladas", 
                    "Óleo Diesel (puro)": "Litros", "Óleos Residuais": "Toneladas", "Outros Produtos de Petróleo": "Toneladas", 
                    "Parafina": "Toneladas", "Petróleo Bruto": "m³", "Querosene de Aviação": "Toneladas", 
                    "Querosene Iluminante": "Toneladas", "Resíduos Industriais": "TJ", 
                    "Resíduos Municipais (fração biomassa)": "Toneladas", "Resíduos Municipais (fração não-biomassa)": "Toneladas", 
                    "Resíduos Vegetais": "Toneladas", "Solventes": "Litros", "Turfa": "Toneladas", 
                    "Xisto Betuminoso e Areias Betuminosas": "Toneladas"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.descricao_da_fonte) errors.descricao_da_fonte = "Obrigatório.";
            if (!this.validOptions.combustivel_estacionario.includes(rowData.combustivel_estacionario)) errors.combustivel_estacionario = "Combustível inválido.";
            const consumoVal = rowData.consumo;
            if (consumoVal === '' || isNaN(parseFloat(consumoVal))) { errors.consumo = `Entrada inválida ('${consumoVal}'). Insira um número.`; }
            if (this.autoFillMap.combustivel_estacionario.map[rowData.combustivel_estacionario] !== rowData.unidade) errors.unidade = `Unidade incorreta para o combustível.`;
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Não'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'Não'."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    dados_producao_venda: {
        displayName: "Dados de Produção e Venda",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Período", unidade_empresarial: "Unidade Empresarial", produto: "Produto", quantidade_vendida: "Quantidade Vendida", unidade_medida: "Unidade de Medida", comentarios: "Comentários" },
        validOptions: { periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"] },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.produto) errors.produto = "Obrigatório.";
            if (!rowData.unidade_medida) errors.unidade_medida = "Obrigatório.";
            const quantidadeVal = rowData.quantidade_vendida;
            const quantidadeNum = parseInt(quantidadeVal, 10);
            if (isNaN(quantidadeNum) || quantidadeNum <= 0 || String(quantidadeVal).includes('.') || String(quantidadeVal).includes(',')) { errors.quantidade_vendida = `Entrada inválida ('${quantidadeVal}'). Insira um número inteiro e positivo.`; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    ippu_lubrificantes: {
        displayName: "IPPU - Lubrificantes",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Período", unidade_empresarial: "Unidade Empresarial", fonte_emissao: "Fonte de Emissão / Equipamento", tipo_lubrificante: "Tipo de Lubrificante", consumo: "Consumo", unidade: "Unidade", controlado_empresa: "Controlado pela Empresa?", comentarios: "Comentários" },
        validOptions: { periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], tipo_lubrificante: ["Lubrificante", "Graxa"], unidade: ["Litros", "kg"], controlado_empresa: ["Sim", "Não"] },
        autoFillMap: { tipo_lubrificante: { targetColumn: "unidade", map: { "Lubrificante": "Litros", "Graxa": "kg" } } },
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.fonte_emissao) errors.fonte_emissao = "Obrigatório.";
            if (!this.validOptions.tipo_lubrificante.includes(rowData.tipo_lubrificante)) errors.tipo_lubrificante = "Tipo inválido.";
            const consumoVal = rowData.consumo;
            const consumoNum = parseFloat(consumoVal);
            if (isNaN(consumoNum) || consumoNum <= 0) { errors.consumo = `Entrada inválida ('${consumoVal}'). Insira um número positivo.`; }
            if (this.autoFillMap.tipo_lubrificante.map[rowData.tipo_lubrificante] !== rowData.unidade) { errors.unidade = `Unidade incorreta para o tipo de lubrificante.`; }
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Não'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'Não'."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    emissoes_fugitivas: {
        displayName: "Emissões Fugitivas",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Período", unidade_empresarial: "Unidade Empresarial", fonte_emissao: "Fonte de Emissão / Equipamento", tipo_gas: "Tipo de Gás", quantidade_reposta: "Quantidade Reposta", unidade: "Unidade", controlado_empresa: "Controlado pela Empresa?", comentarios: "Comentários" },
        
        gasList: ["Dióxido de carbono (CO2)", "Metano (CH4)", "Óxido nitroso (N2O)", "HFC-23", "HFC-32", "HFC-41", "HFC-125", "HFC-134", "HFC-134a", "HFC-143", "HFC-143a", "HFC-152", "HFC-152a", "HFC-161", "HFC-227ea", "HFC-236cb", "HFC-236ea", "HFC-236fa", "HFC-245ca", "HFC-245fa", "HFC-365mfc", "HFC-43-10mee", "Hexafluoreto de enxofre (SF6)", "Trifluoreto de nitrogênio (NF3)", "PFC-14", "PFC-116", "PFC-218", "PFC-318", "PFC-3-1-10", "PFC-4-1-12", "PFC-5-1-14", "PFC-9-1-18", "Trifluorometil pentafluoreto de enxofre (SF5CF3)", "Perfluorociclopropano (c-C3F6)", "R-400", "R-401A", "R-401B", "R-401C", "R-402A", "R-402B", "R-403A", "R-403B", "R-404A", "R-405A", "R-406A", "R-407A", "R-407B", "R-407C", "R-407D", "R-407E", "R-407F", "R-407G", "R-407H", "R-407I", "R-408A", "R-409A", "R-409B", "R-410A", "R-410B", "R-411A", "R-411B", "R-412A", "R-413A", "R-414A", "R-414B", "R-415A", "R-415B", "R-416A", "R-417A", "R-417B", "R-417C", "R-418A", "R-419A", "R-419B", "R-420A", "R-421A", "R-421B", "R-422A", "R-422B", "R-422C", "R-422D", "R-422E", "R-423A", "R-424A", "R-425A", "R-426A", "R-427A", "R-428A", "R-429A", "R-430A", "R-431A", "R-432A", "R-433A", "R-433B", "R-433C", "R-434A", "R-435A", "R-436A", "R-436B", "R-436C", "R-437A", "R-438A", "R-439A", "R-440A", "R-441A", "R-442A", "R-443A", "R-444B", "R-445A", "R-446A", "R-447A", "R-447B", "R-448A", "R-449A", "R-449B", "R-449C", "R-450A", "R-451A", "R-451B", "R-452A", "R-452B", "R-452C", "R-453A", "R-454A", "R-454B", "R-454C", "R-455A", "R-456A", "R-457A", "R-458A", "R-459A", "R-459B", "R-460A", "R-460B", "R-460C", "R-461A", "R-462A", "R-463A", "R-464A", "R-465A", "R-500", "R-501", "R-502", "R-503", "R-504", "R-505", "R-506", "R-507 ou R-507A", "R-508A", "R-508B", "R-509 ou R-509A", "R-510A", "R-511A", "R-512A", "R-513A", "R-513B", "R-514A", "R-515A", "R-516A", "CFC-11", "CFC-12", "CFC-13", "CFC-113", "CFC-114", "CFC-115", "Halon-1301", "Halon-1211", "Halon-2402", "Tetracloreto de carbono (CCl4)", "Bromometano (CH3Br)", "Methyl chloroform (CH3CCl3)", "HCFC-21", "HCFC-22 (R22)", "HCFC-123", "HCFC-124", "HCFC-141b", "HCFC-142b", "HCFC-225ca", "HCFC-225cb"],
        
        get validOptions() { return { periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], tipo_gas: this.gasList, unidade: ["kg"], controlado_empresa: ["Sim", "Não"] }; },
        autoFillMap: {},
        validateRow: function(rowData, optionsCache) {
            const errors = {};
            const validGasOptions = optionsCache?.tipo_gas || this.validOptions.tipo_gas;
            const validGasOptionsNormalized = validGasOptions.map(g => g.toLowerCase());
            const gasInputNormalized = (rowData.tipo_gas || '').toLowerCase();
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.fonte_emissao) errors.fonte_emissao = "Obrigatório.";
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Não'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'Não'."; }
            const quantidadeVal = rowData.quantidade_reposta;
            const quantidadeNum = parseFloat(quantidadeVal);
            if (isNaN(quantidadeNum) || quantidadeNum <= 0) { errors.quantidade_reposta = `Entrada inválida ('${quantidadeVal}'). Insira um número positivo.`; }
            if (rowData.unidade !== 'kg') errors.unidade = "Unidade deve ser 'kg'.";
            if (!gasInputNormalized || !validGasOptionsNormalized.includes(gasInputNormalized)) { errors.tipo_gas = "Obrigatório selecionar um gás da lista."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    fertilizantes: {
        displayName: "Fertilizantes",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Período", unidade_empresarial: "Unidade Empresarial", tipo_fertilizante: "Tipo de Fertilizante", quantidade_kg: "Quantidade de Fertilizante", unidade: "Unidade", percentual_nitrogenio: "Percentual de Nitrogênio (%)", percentual_carbonato: "Percentual de Carbonato (%)", controlado_empresa: "Controlado pela Empresa?", comentarios: "Comentários" },
        validOptions: { periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], unidade: ["kg"], controlado_empresa: ["Sim", "Não"] },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.tipo_fertilizante) errors.tipo_fertilizante = "Obrigatório.";
            const quantidadeVal = rowData.quantidade_kg;
            const quantidadeNum = parseFloat(quantidadeVal);
            if (isNaN(quantidadeNum) || quantidadeNum <= 0) { errors.quantidade_kg = `Entrada inválida ('${quantidadeVal}'). Insira um número positivo.`; }
            const percNVal = rowData.percentual_nitrogenio;
            const percCVal = rowData.percentual_carbonato;
            const percN = parseFloat(percNVal);
            const percC = parseFloat(percCVal);
            if (isNaN(percN) || percN < 0 || percN > 100) { errors.percentual_nitrogenio = `Entrada inválida ('${percNVal}'). Insira um número de 0 a 100.`; }
            if (isNaN(percC) || percC < 0 || percC > 100) { errors.percentual_carbonato = `Entrada inválida ('${percCVal}'). Insira um número de 0 a 100.`; }
            if (rowData.unidade !== 'kg') errors.unidade = "Unidade deve ser 'kg'.";
            if (!isNaN(percN) && !isNaN(percC) && (percN + percC > 100)) {
                errors.percentual_nitrogenio = "A soma das porcentagens não pode exceder 100%.";
                errors.percentual_carbonato = "A soma das porcentagens não pode exceder 100%.";
            }
            const normalizedControlado = normalizeString(rowData.controlado_empresa);
            if (['sim', 's'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Sim'; } else if (['nao', 'n'].includes(normalizedControlado)) { rowData.controlado_empresa = 'Não'; }
            if (!this.validOptions.controlado_empresa.includes(rowData.controlado_empresa)) { errors.controlado_empresa = "Deve ser 'Sim' ou 'Não'."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    efluentes_controlados: {
        displayName: "Efluentes Controlados",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Período", unidade_empresarial: "Unidade Empresarial", tratamento_ou_destino: "Tratamento ou Destino Final?", tipo_tratamento: "Tipo de Tratamento", tipo_destino_final: "Tipo de Destino Final", qtd_efluente_liquido_m3: "Quantidade de Efluente Líquido Gerado", unidade_efluente_liquido: "Unidade do Efluente Líquido", qtd_componente_organico: "Quantidade de Componente Orgânico Degradável do Efluente", unidade_componente_organico: "Unidade do Componente Orgânico", qtd_nitrogenio_mg_l: "Quantidade de Nitrogênio no Efluente Gerado", unidade_nitrogenio: "Unidade do Nitrogênio", componente_organico_removido_lodo: "Componente Orgânico do Efluente Removido com o Lodo", unidade_comp_organico_removido_lodo: "Unidade do Componente Orgânico Removido", comentarios: "Comentários" },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tratamento_ou_destino: ["Tratamento", "Destino Final"],
            tipo_tratamento: [ "Tratamento aeróbio (lodo ativado, lagoa aerada, etc)", "Fossa séptica", "Reator anaeróbio", "Lagoa anaeróbia profunda (profundidade > 2 metros)", "Lagoa anaeróbia rasa (profundidade < 2 metros)", "Lagoa facultativa (profundidade < 2 metros)", "Lagoa de maturação (profundidade < 2 metros)", "Fossas secas" ],
            tipo_destino_final: [ "Lançamento em corpos d'água (não especificado)", "Lançamento em corpos d'água (que não reservatórios, lagos e estuários)", "Lançamento em reservatórios, lagos e estuários", "Efluente parado a céu aberto", "Lançamento em reservatórios. lagos e estuários" ],
            unidade_componente_organico: [ "mgDQO/L (Demanda química de oxigênio)", "mgDBO/L (Demanda biológica de oxigênio)" ],
            unidade_comp_organico_removido_lodo: [ "mgDQO/L (Demanda química de oxigênio)", "mgDBO/L (Demanda biológica de oxigênio)" ],
            unidade_efluente_liquido: ["m3/ano", "m3/mês"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            const qtdEfluenteVal = rowData.qtd_efluente_liquido_m3;
            if (isNaN(parseFloat(qtdEfluenteVal)) || parseFloat(qtdEfluenteVal) <= 0) { errors.qtd_efluente_liquido_m3 = `Entrada inválida ('${qtdEfluenteVal}'). Insira um número positivo.`; }
            const qtdCompOrgVal = rowData.qtd_componente_organico;
            if (isNaN(parseFloat(qtdCompOrgVal)) || parseFloat(qtdCompOrgVal) <= 0) { errors.qtd_componente_organico = `Entrada inválida ('${qtdCompOrgVal}'). Insira um número positivo.`; }
            const qtdNitroVal = rowData.qtd_nitrogenio_mg_l;
            if (isNaN(parseFloat(qtdNitroVal)) || parseFloat(qtdNitroVal) < 0) { errors.qtd_nitrogenio_mg_l = `Entrada inválida ('${qtdNitroVal}'). Insira um número positivo ou zero.`; }
            const compOrgRemovidoVal = rowData.componente_organico_removido_lodo;
            if (isFilled(compOrgRemovidoVal) && (isNaN(parseFloat(compOrgRemovidoVal)) || parseFloat(compOrgRemovidoVal) < 0)) { errors.componente_organico_removido_lodo = `Entrada inválida ('${compOrgRemovidoVal}'). Insira um número positivo ou zero.`; }
            if (!this.validOptions.unidade_efluente_liquido.includes(rowData.unidade_efluente_liquido)) { errors.unidade_efluente_liquido = "Unidade deve ser 'm3/ano' ou 'm3/mês'."; }
            if (!this.validOptions.unidade_componente_organico.includes(rowData.unidade_componente_organico)) errors.unidade_componente_organico = "Unidade do componente inválida.";
            if (rowData.unidade_nitrogenio !== 'kgN/m3') errors.unidade_nitrogenio = "Unidade deve ser 'kgN/m3'.";
            if (isFilled(compOrgRemovidoVal)) { if (!this.validOptions.unidade_comp_organico_removido_lodo.includes(rowData.unidade_comp_organico_removido_lodo)) errors.unidade_comp_organico_removido_lodo = "Unidade do componente removido inválida."; }
            if (rowData.unidade_comp_organico_removido_lodo && !isFilled(compOrgRemovidoVal)) { errors.componente_organico_removido_lodo = "Quantidade é obrigatória se a unidade for selecionada."; }
            if (!this.validOptions.tratamento_ou_destino.includes(rowData.tratamento_ou_destino)) { errors.tratamento_ou_destino = "Escolha entre 'Tratamento' e 'Destino Final'."; } else if (rowData.tratamento_ou_destino === 'Tratamento') {
                if (!this.validOptions.tipo_tratamento.includes(rowData.tipo_tratamento)) { errors.tipo_tratamento = "Selecione um tipo de tratamento válido."; }
                if (isFilled(rowData.tipo_destino_final)) { errors.tipo_destino_final = "Deve estar vazio quando 'Tratamento' é selecionado."; }
            } else if (rowData.tratamento_ou_destino === 'Destino Final') {
                if (!this.validOptions.tipo_destino_final.includes(rowData.tipo_destino_final)) { errors.tipo_destino_final = "Selecione um tipo de destino final válido."; }
                if (isFilled(rowData.tipo_tratamento)) { errors.tipo_tratamento = "Deve estar vazio quando 'Destino Final' é selecionado."; }
            }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    efluentes_domesticos: {
        displayName: "Efluentes Domésticos",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Período", unidade_empresarial: "Unidade Empresarial", tipo_trabalhador: "Tipo de Trabalhador", num_trabalhadores: "Nº de Trabalhadores", carga_horaria_media: "Carga Horária Média (h/dia)", fossa_septica_propriedade: "Fossa séptica na propriedade?", comentarios: "Comentários" },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tipo_trabalhador: ["Interno", "Terceiro"],
            fossa_septica_propriedade: ["Sim", "Não"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!this.validOptions.tipo_trabalhador.includes(rowData.tipo_trabalhador)) { errors.tipo_trabalhador = "Selecione 'Interno' ou 'Terceiro'."; }
            const numTrabalhadoresVal = rowData.num_trabalhadores;
            const numTrabalhadores = parseInt(numTrabalhadoresVal, 10);
            if (isNaN(numTrabalhadores) || numTrabalhadores <= 0 || String(numTrabalhadoresVal).includes('.') || String(numTrabalhadoresVal).includes(',')) { 
                errors.num_trabalhadores = `Entrada inválida ('${numTrabalhadoresVal}'). Insira um número inteiro e positivo.`;
            }
            const cargaHorariaVal = rowData.carga_horaria_media;
            const cargaHoraria = parseFloat(cargaHorariaVal);
            if (isNaN(cargaHoraria) || cargaHoraria <= 0) { errors.carga_horaria_media = `Entrada inválida ('${cargaHorariaVal}'). Insira um número maior que zero.`; }
            const normalizedFossa = normalizeString(rowData.fossa_septica_propriedade);
            if (['sim', 's'].includes(normalizedFossa)) { rowData.fossa_septica_propriedade = 'Sim'; } else if (['nao', 'n'].includes(normalizedFossa)) { rowData.fossa_septica_propriedade = 'Não'; }
            if (!this.validOptions.fossa_septica_propriedade.includes(rowData.fossa_septica_propriedade)) { errors.fossa_septica_propriedade = "Deve ser 'Sim' ou 'Não'."; }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    mudanca_uso_solo: {
        displayName: "Mudança do Uso do Solo",
        hasUnits: true,
        headerDisplayNames: { ano: "Ano", periodo: "Período", unidade_empresarial: "Unidade Organizacional", uso_solo_anterior: "Uso do Solo Anterior", bioma: "Bioma", fitofisionomia: "Fitofisionomia", tipo_area: "Tipo de Área", area_hectare: "Área (hectare)", comentarios: "Comentários" },
        validOptions: { periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], uso_solo_anterior: ["Cultura anual", "Cultura de cana", "Cultura perene", "Pastagem", "Silvicultura", "Vegetação natural", "Assentamentos", "Outros usos"], bioma: ["Amazônia", "Cerrado", "Mata Atlântica", "Caatinga", "Pampa", "Pantanal"], tipo_area: ["Área de vegetação primária manejada", "Área de vegetação primária não manejada", "Área de vegetação secundária"] },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            
            const areaVal = rowData.area_hectare;
            const area = parseFloat(areaVal);
            if (isNaN(area) || area <= 0) { errors.area_hectare = `Entrada inválida ('${areaVal}'). Insira um número positivo.`; }

            if (!this.validOptions.uso_solo_anterior.includes(rowData.uso_solo_anterior)) { errors.uso_solo_anterior = "Selecione uma opção válida."; }
            
            if (rowData.uso_solo_anterior === 'Vegetação natural') {
                if (!this.validOptions.bioma.includes(rowData.bioma)) { errors.bioma = "Bioma é obrigatório para Vegetação Natural."; }
                if (!rowData.fitofisionomia) { errors.fitofisionomia = "Fitofisionomia é obrigatório para Vegetação Natural."; }
                if (!this.validOptions.tipo_area.includes(rowData.tipo_area)) { errors.tipo_area = "Tipo de Área é obrigatório para Vegetação Natural."; }
            } else {
                if (isFilled(rowData.bioma)) { errors.bioma = "Deve estar vazio se o uso do solo não for 'Vegetação natural'."; }
                if (isFilled(rowData.fitofisionomia)) { errors.fitofisionomia = "Deve estar vazio se o uso do solo não for 'Vegetação natural'."; }
                if (isFilled(rowData.tipo_area)) { errors.tipo_area = "Deve estar vazio se o uso do solo não for 'Vegetação natural'."; }
            }
            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    purchased_goods_services: {
        displayName: "Bens e Serviços Comprados",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            descricao_item: "Descrição do Item",
            tipo_item: "Tipo de Item",
            quantidade: "Quantidade Adquirida",
            unidade: "Unidade de Medida",
            valor_aquisicao: "Valor da Aquisição (R$)",
            bens_terceiros: "Bens de Terceiros?",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tipo_item: ["Produto", "Serviço"],
            unidade: ["Tonelada", "Quilo", "Unidade", "M³", "Litro"],
            bens_terceiros: ["Sim", "Não"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            // Validações Básicas
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.descricao_item) errors.descricao_item = "Obrigatório.";
            
            // Validação de Tipo
            if (!this.validOptions.tipo_item.includes(rowData.tipo_item)) {
                errors.tipo_item = "Selecione 'Produto' ou 'Serviço'.";
            }

            // Lógica Condicional: Produto vs Serviço
            if (rowData.tipo_item === 'Produto') {
                const qtdVal = rowData.quantidade;
                if (!isFilled(qtdVal) || isNaN(parseFloat(qtdVal)) || parseFloat(qtdVal) <= 0) {
                    errors.quantidade = "Quantidade obrigatória para Produtos (número positivo).";
                }
                if (!this.validOptions.unidade.includes(rowData.unidade)) {
                    errors.unidade = "Selecione uma unidade válida para Produtos.";
                }
            } else if (rowData.tipo_item === 'Serviço') {
                if (isFilled(rowData.quantidade)) {
                    errors.quantidade = "Deve estar vazio para Serviços.";
                }
                if (isFilled(rowData.unidade)) {
                    errors.unidade = "Deve estar vazio para Serviços.";
                }
            }

            // Valor da Aquisição (Sempre Obrigatório)
            const valorVal = rowData.valor_aquisicao;
            if (!isFilled(valorVal) || isNaN(parseFloat(valorVal)) || parseFloat(valorVal) <= 0) {
                errors.valor_aquisicao = "Valor obrigatório e positivo.";
            }

            // Bens de Terceiros
            const normalizedTerceiros = normalizeString(rowData.bens_terceiros);
            if (['sim', 's'].includes(normalizedTerceiros)) { rowData.bens_terceiros = 'Sim'; } 
            else if (['nao', 'n'].includes(normalizedTerceiros)) { rowData.bens_terceiros = 'Não'; }
            if (!this.validOptions.bens_terceiros.includes(rowData.bens_terceiros)) {
                errors.bens_terceiros = "Deve ser 'Sim' ou 'Não'.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    capital_goods: {
        displayName: "Bens de Capital",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            bem_capital: "Bem de Capital Adquirido",
            quantidade: "Quantidade Adquirida",
            unidade: "Unidade",
            valor_aquisicao: "Valor da Aquisição (R$)",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.bem_capital) errors.bem_capital = "Obrigatório.";

            // Inteiro e Positivo
            const qtdVal = rowData.quantidade;
            if (!isFilled(qtdVal) || isNaN(parseInt(qtdVal)) || parseInt(qtdVal) <= 0 || String(qtdVal).includes('.') || String(qtdVal).includes(',')) {
                errors.quantidade = "Quantidade deve ser um número inteiro positivo.";
            }

            // Unidade Fixa
            if (rowData.unidade !== 'Unidades') {
                errors.unidade = "A unidade deve ser 'Unidades'.";
            }

            // Float Positivo
            const valorVal = rowData.valor_aquisicao;
            if (!isFilled(valorVal) || isNaN(parseFloat(valorVal)) || parseFloat(valorVal) <= 0) {
                errors.valor_aquisicao = "Valor obrigatório e positivo.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    upstream_transport: {
        displayName: "Logística de Insumo",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            insumo_transportado: "Insumo Transportado",
            modal_transporte: "Modal de Transporte",
            tipo_reporte: "Tipo de Reporte (Consumo ou Distância)",
            combustivel: "Combustível",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustível)",
            classificacao_veiculo: "Classificação do Veículo",
            distancia_trecho: "Distância do Trecho",
            unidade_distancia: "Unidade (Distância)",
            carga_transportada: "Carga Transportada (t)",
            numero_viagens: "Número de Viagens",
            local_embarque: "Local de Embarque",
            local_destino: "Local de Destino",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            modal_transporte: ["Transporte Marítimo", "Transporte Ferroviário", "Transporte Rodoviário"],
            tipo_reporte: ["Consumo", "Distância"],
            combustivel: [
                "Gasolina Automotiva", "Óleo Diesel", "Gás Natural Veicular (GNV)", "Gás Natural Liquefeito (GNL)", 
                "Gás Liquefeito de Petróleo (GLP)", "Querosene de Aviação", "Gasolina de Aviação", "Lubrificantes", 
                "Metanol", "Óleo Combustível", "Etanol Hidratado", "Biodiesel (B100)", "Biometano", 
                "Bioquerosene (SAF)", "HVO (diesel verde)", "Biometanol", "Etanol Anidro"
            ],
            classificacao_veiculo: [
                "Caminhão - rígido (3,5 a 7,5 toneladas)", "Caminhão - rígido (7,5 a 17 toneladas)", 
                "Caminhão - rígido (acima de 17 toneladas)", "Caminhão - rígido (média)", 
                "Caminhão - articulado (3,5 a 33 toneladas)", "Caminhão - articulado (acima de 33 toneladas)", 
                "Caminhão - articulado (média)", "Caminhão - caminhão (média)", 
                "Caminhão refrigerado - rígido (3,5 a 7,5 toneladas)", "Caminhão refrigerado - rígido (7,5 a 17 toneladas)", 
                "Caminhão refrigerado - rígido (acima de 17 toneladas)", "Caminhão refrigerado - rígido (média)", 
                "Caminhão refrigerado - articulado (3,5 a 33 toneladas)", "Caminhão refrigerado - articulado (acima de 33 toneladas)", 
                "Caminhão refrigerado - articulado (média)", "Caminhão refrigerado - caminhão (média)"
            ],
            unidade_distancia: ["km", "Milhas"]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Gasolina Automotiva": "Litros", "Óleo Diesel": "Litros", "Gás Natural Veicular (GNV)": "m³", 
                    "Gás Natural Liquefeito (GNL)": "Litros", "Gás Liquefeito de Petróleo (GLP)": "kg", 
                    "Querosene de Aviação": "Litros", "Gasolina de Aviação": "Litros", "Lubrificantes": "Litros", 
                    "Metanol": "Litros", "Óleo Combustível": "Litros", "Etanol Hidratado": "Litros", 
                    "Biodiesel (B100)": "Litros", "Biometano": "m³", "Bioquerosene (SAF)": "Litros", 
                    "HVO (diesel verde)": "Litros", "Biometanol": "Litros", "Etanol Anidro": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            // Validações Básicas
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.insumo_transportado) errors.insumo_transportado = "Obrigatório.";
            
            if (!this.validOptions.modal_transporte.includes(rowData.modal_transporte)) errors.modal_transporte = "Modal inválido.";
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo' ou 'Distância'.";

            // Lógica Condicional
            if (rowData.tipo_reporte === 'Consumo') {
                // Campos de Consumo Obrigatórios
                if (!this.validOptions.combustivel.includes(rowData.combustivel)) errors.combustivel = "Selecione um combustível válido.";
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatório e positivo.";
                
                // Validação de Unidade Automática
                const expectedUnit = this.autoFillMap.combustivel.map[rowData.combustivel];
                if (rowData.combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Campos de Distância devem ser vazios
                if (isFilled(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.distancia_trecho)) errors.distancia_trecho = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.carga_transportada)) errors.carga_transportada = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.numero_viagens)) errors.numero_viagens = "Deve ser vazio para reporte por Consumo.";
            
            } else if (rowData.tipo_reporte === 'Distância') {
                // Campos de Distância Obrigatórios
                if (!this.validOptions.classificacao_veiculo.includes(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Classificação de veículo inválida.";
                
                const distVal = rowData.distancia_trecho;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_trecho = "Distância obrigatória e positiva.";
                
                if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) errors.unidade_distancia = "Selecione 'km' ou 'Milhas'.";
                
                const cargaVal = rowData.carga_transportada;
                if (!isFilled(cargaVal) || isNaN(parseFloat(cargaVal)) || parseFloat(cargaVal) <= 0) errors.carga_transportada = "Carga obrigatória e positiva (toneladas).";
                
                const viagensVal = rowData.numero_viagens;
                if (!isFilled(viagensVal) || isNaN(parseInt(viagensVal)) || parseInt(viagensVal) <= 0) errors.numero_viagens = "Número de viagens obrigatório (inteiro).";

                // Campos de Consumo devem ser vazios
                if (isFilled(rowData.combustivel)) errors.combustivel = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distância.";
            }

            if (!rowData.local_embarque) errors.local_embarque = "Local de embarque obrigatório.";
            if (!rowData.local_destino) errors.local_destino = "Local de destino obrigatório.";

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    business_travel_land: {
        displayName: "Viagens a Negócios Terrestres",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            descricao_viagem: "Descrição da Viagem",
            modal_viagem: "Modal de Viagem",
            tipo_reporte: "Tipo de Reporte (Consumo ou Distância)",
            combustivel: "Combustível",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustível)",
            distancia_percorrida: "Distância Percorrida",
            unidade_distancia: "Unidade (Distância)",
            km_reembolsado: "Km Reembolsado?",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tipo_reporte: ["Consumo", "Distância"],
            modal_viagem: [
                "Automóvel a gasolina", "Automóvel a etanol", "Automóvel flex a gasolina", "Automóvel flex a etanol", 
                "Motocicleta a gasolina", "Motocicleta flex a gasolina", "Motocicleta flex a etanol", 
                "Veículo comercial leve a gasolina", "Veículo comercial leve a etanol", "Veículo comercial leve flex a gasolina", 
                "Veículo comercial leve flex a etanol", "Veículo comercial leve a diesel", 
                "Micro-ônibus a diesel", "Ônibus rodoviário a diesel", "Ônibus urbano a diesel", "Trem", "Metrô"
            ],
            combustivel: [
                "Gasolina Automotiva", "Óleo Diesel", "Gás Natural Veicular (GNV)", "Gás Natural Liquefeito (GNL)", 
                "Gás Liquefeito de Petróleo (GLP)", "Querosene de Aviação", "Gasolina de Aviação", "Lubrificantes", 
                "Metanol", "Óleo Combustível", "Etanol Hidratado", "Biodiesel (B100)", "Biometano", 
                "Bioquerosene (SAF)", "HVO (diesel verde)", "Biometanol", "Etanol Anidro"
            ],
            unidade_distancia: ["Km", "Milha"],
            km_reembolsado: ["Sim", "Não"]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Gasolina Automotiva": "Litros", "Óleo Diesel": "Litros", "Gás Natural Veicular (GNV)": "m³", 
                    "Gás Natural Liquefeito (GNL)": "Litros", "Gás Liquefeito de Petróleo (GLP)": "kg", 
                    "Querosene de Aviação": "Litros", "Gasolina de Aviação": "Litros", "Lubrificantes": "Litros", 
                    "Metanol": "Litros", "Óleo Combustível": "Litros", "Etanol Hidratado": "Litros", 
                    "Biodiesel (B100)": "Litros", "Biometano": "m³", "Bioquerosene (SAF)": "Litros", 
                    "HVO (diesel verde)": "Litros", "Biometanol": "Litros", "Etanol Anidro": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            // Validações Básicas
            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.descricao_viagem) errors.descricao_viagem = "Obrigatório.";
            
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo' ou 'Distância'.";

            // CAMPOS GLOBAIS (Obrigatórios para AMBOS os tipos)
            if (!this.validOptions.modal_viagem.includes(rowData.modal_viagem)) errors.modal_viagem = "Modal de viagem inválido.";
            
            const normalizedKm = normalizeString(rowData.km_reembolsado);
            if (['sim', 's'].includes(normalizedKm)) { rowData.km_reembolsado = 'Sim'; } 
            else if (['nao', 'n'].includes(normalizedKm)) { rowData.km_reembolsado = 'Não'; }
            if (!this.validOptions.km_reembolsado.includes(rowData.km_reembolsado)) errors.km_reembolsado = "Deve ser 'Sim' ou 'Não'.";

            // Lógica Condicional (Específica)
            if (rowData.tipo_reporte === 'Consumo') {
                // Consumo
                if (!this.validOptions.combustivel.includes(rowData.combustivel)) errors.combustivel = "Selecione um combustível válido.";
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatório e positivo.";
                
                const expectedUnit = this.autoFillMap.combustivel.map[rowData.combustivel];
                if (rowData.combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Distância deve ser vazio
                if (isFilled(rowData.distancia_percorrida)) errors.distancia_percorrida = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve ser vazio para reporte por Consumo.";
            
            } else if (rowData.tipo_reporte === 'Distância') {
                // Distância
                const distVal = rowData.distancia_percorrida;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_percorrida = "Distância obrigatória e positiva.";
                
                if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) errors.unidade_distancia = "Selecione 'Km' ou 'Milha'.";

                // Consumo deve ser vazio
                if (isFilled(rowData.combustivel)) errors.combustivel = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distância.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    downstream_transport: {
        displayName: "Logística de Produto Final",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            insumo_transportado: "Insumo Transportado",
            modal_transporte: "Modal de Transporte",
            tipo_reporte: "Tipo de Reporte (Consumo ou Distância)",
            combustivel: "Combustível",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustível)",
            classificacao_veiculo: "Classificação do Veículo",
            distancia_trecho: "Distância do Trecho",
            unidade_distancia: "Unidade (Distância)",
            carga_transportada: "Carga Transportada (t)",
            numero_viagens: "Número de Viagens",
            local_embarque: "Local de Embarque",
            local_destino: "Local de Destino",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            modal_transporte: ["Transporte Marítimo", "Transporte Ferroviário", "Transporte Rodoviário"],
            tipo_reporte: ["Consumo", "Distância"],
            combustivel: [
                "Óleo Diesel", "Gasolina", "Gás Natural Veicular", "Gás Liquefeito de Petróleo", 
                "Querosene de Aviação", "Gasolina de Aviação", "Lubrificantes", 
                "Óleo combustível residual", "Etanol", "Biodiesel"
            ],
            classificacao_veiculo: [
                "Caminhão - rígido (3,5 a 7,5 toneladas)", "Caminhão - rígido (7,5 a 17 toneladas)", 
                "Caminhão - rígido (acima de 17 toneladas)", "Caminhão - rígido (média)", 
                "Caminhão - articulado (3,5 a 33 toneladas)", "Caminhão - articulado (acima de 33 toneladas)", 
                "Caminhão - articulado (média)", "Caminhão - caminhão (média)", 
                "Caminhão refrigerado - rígido (3,5 a 7,5 toneladas)", "Caminhão refrigerado - rígido (7,5 a 17 toneladas)", 
                "Caminhão refrigerado - rígido (acima de 17 toneladas)", "Caminhão refrigerado - rígido (média)", 
                "Caminhão refrigerado - articulado (3,5 a 33 toneladas)", "Caminhão refrigerado - articulado (acima de 33 toneladas)", 
                "Caminhão refrigerado - articulado (média)", "Caminhão refrigerado - caminhão (média)"
            ],
            unidade_distancia: ["Km", "Milhas"]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Óleo Diesel": "Litros", "Gasolina": "Litros", "Gás Natural Veicular": "m³", 
                    "Gás Liquefeito de Petróleo": "kg", "Querosene de Aviação": "Litros", 
                    "Gasolina de Aviação": "Litros", "Lubrificantes": "Litros", 
                    "Óleo combustível residual": "Litros", "Etanol": "Litros", "Biodiesel": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.insumo_transportado) errors.insumo_transportado = "Obrigatório.";
            
            if (!this.validOptions.modal_transporte.includes(rowData.modal_transporte)) errors.modal_transporte = "Modal inválido.";
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo' ou 'Distância'.";

            // Lógica Condicional
            if (rowData.tipo_reporte === 'Consumo') {
                // Campos de Consumo Obrigatórios
                if (!this.validOptions.combustivel.includes(rowData.combustivel)) errors.combustivel = "Selecione um combustível válido.";
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatório e positivo.";
                
                // Validação de Unidade Automática
                const expectedUnit = this.autoFillMap.combustivel.map[rowData.combustivel];
                if (rowData.combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Campos de Distância devem ser vazios
                if (isFilled(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.distancia_trecho)) errors.distancia_trecho = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.carga_transportada)) errors.carga_transportada = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.numero_viagens)) errors.numero_viagens = "Deve ser vazio para reporte por Consumo.";
            
            } else if (rowData.tipo_reporte === 'Distância') {
                // Campos de Distância Obrigatórios
                if (!this.validOptions.classificacao_veiculo.includes(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Classificação de veículo inválida.";
                
                const distVal = rowData.distancia_trecho;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_trecho = "Distância obrigatória e positiva.";
                
                if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) errors.unidade_distancia = "Selecione 'Km' ou 'Milhas'.";
                
                const cargaVal = rowData.carga_transportada;
                if (!isFilled(cargaVal) || isNaN(parseFloat(cargaVal)) || parseFloat(cargaVal) <= 0) errors.carga_transportada = "Carga obrigatória e positiva (toneladas).";
                
                const viagensVal = rowData.numero_viagens;
                if (!isFilled(viagensVal) || isNaN(parseInt(viagensVal)) || parseInt(viagensVal) <= 0) errors.numero_viagens = "Número de viagens obrigatório (inteiro).";

                // Campos de Consumo devem ser vazios
                if (isFilled(rowData.combustivel)) errors.combustivel = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distância.";
            }

            if (!rowData.local_embarque) errors.local_embarque = "Local de embarque obrigatório.";
            if (!rowData.local_destino) errors.local_destino = "Local de destino obrigatório.";

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    waste_transport: {
        displayName: "Logística de Resíduos",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            insumo_transportado: "Resíduo Transportado",
            tipo_reporte: "Tipo de Reporte",
            combustivel: "Combustível",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustível)",
            classificacao_veiculo: "Classificação do Veículo",
            distancia_trecho: "Distância do Trecho",
            unidade_distancia: "Unidade (Distância)",
            carga_transportada: "Carga Transportada (t)",
            numero_viagens: "Número de Viagens",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            tipo_reporte: ["Consumo", "Distância"],
            combustivel: [
                "Óleo Diesel", "Gasolina", "Gás Natural Veicular", "Gás Liquefeito de Petróleo", 
                "Querosene de Aviação", "Gasolina de Aviação", "Lubrificantes", 
                "Óleo combustível residual", "Etanol", "Biodiesel"
            ],
            classificacao_veiculo: [
                "Caminhão - rígido (3,5 a 7,5 toneladas)", "Caminhão - rígido (7,5 a 17 toneladas)", 
                "Caminhão - rígido (acima de 17 toneladas)", "Caminhão - rígido (média)", 
                "Caminhão - articulado (3,5 a 33 toneladas)", "Caminhão - articulado (acima de 33 toneladas)", 
                "Caminhão - articulado (média)", "Caminhão - caminhão (média)", 
                "Caminhão refrigerado - rígido (3,5 a 7,5 toneladas)", "Caminhão refrigerado - rígido (7,5 a 17 toneladas)", 
                "Caminhão refrigerado - rígido (acima de 17 toneladas)", "Caminhão refrigerado - rígido (média)", 
                "Caminhão refrigerado - articulado (3,5 a 33 toneladas)", "Caminhão refrigerado - articulado (acima de 33 toneladas)", 
                "Caminhão refrigerado - articulado (média)", "Caminhão refrigerado - caminhão (média)"
            ],
            unidade_distancia: ["Km", "Milhas"]
        },
        autoFillMap: {
            combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Óleo Diesel": "Litros", "Gasolina": "Litros", "Gás Natural Veicular": "m³", 
                    "Gás Liquefeito de Petróleo": "kg", "Querosene de Aviação": "Litros", 
                    "Gasolina de Aviação": "Litros", "Lubrificantes": "Litros", 
                    "Óleo combustível residual": "Litros", "Etanol": "Litros", "Biodiesel": "Litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.insumo_transportado) errors.insumo_transportado = "Obrigatório.";
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo' ou 'Distância'.";

            // Lógica Condicional
            if (rowData.tipo_reporte === 'Consumo') {
                if (!this.validOptions.combustivel.includes(rowData.combustivel)) errors.combustivel = "Selecione um combustível válido.";
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatório e positivo.";
                
                // Validação de Unidade Automática
                const expectedUnit = this.autoFillMap.combustivel.map[rowData.combustivel];
                if (rowData.combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Campos de Distância devem ser vazios
                if (isFilled(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.distancia_trecho)) errors.distancia_trecho = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.unidade_distancia)) errors.unidade_distancia = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.carga_transportada)) errors.carga_transportada = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.numero_viagens)) errors.numero_viagens = "Deve ser vazio para reporte por Consumo.";
            
            } else if (rowData.tipo_reporte === 'Distância') {
                if (!this.validOptions.classificacao_veiculo.includes(rowData.classificacao_veiculo)) errors.classificacao_veiculo = "Classificação de veículo inválida.";
                
                const distVal = rowData.distancia_trecho;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_trecho = "Distância obrigatória e positiva.";
                
                if (!this.validOptions.unidade_distancia.includes(rowData.unidade_distancia)) errors.unidade_distancia = "Selecione 'Km' ou 'Milhas'.";
                
                const cargaVal = rowData.carga_transportada;
                if (!isFilled(cargaVal) || isNaN(parseFloat(cargaVal)) || parseFloat(cargaVal) <= 0) errors.carga_transportada = "Carga obrigatória e positiva (toneladas).";
                
                const viagensVal = rowData.numero_viagens;
                if (!isFilled(viagensVal) || isNaN(parseInt(viagensVal)) || parseInt(viagensVal) <= 0) errors.numero_viagens = "Número de viagens obrigatório (inteiro).";

                // Campos de Consumo devem ser vazios
                if (isFilled(rowData.combustivel)) errors.combustivel = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distância.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    home_office: {
        displayName: "Home Office",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            regime_trabalho: "Regime de Trabalho (Dias)",
            num_funcionarios: "Número de Funcionários",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            
            // Regime de Trabalho vem da descrição da fonte, então é obrigatório
            if (!rowData.regime_trabalho) errors.regime_trabalho = "Obrigatório.";

            const numFuncVal = rowData.num_funcionarios;
            if (!isFilled(numFuncVal) || isNaN(parseInt(numFuncVal)) || parseInt(numFuncVal) <= 0 || String(numFuncVal).includes('.') || String(numFuncVal).includes(',')) {
                errors.num_funcionarios = "Deve ser um número inteiro e positivo.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    air_travel: {
        displayName: "Viagens Aéreas",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            descricao_viagem: "Descrição da Viagem",
            codigo_aeroporto_partida: "Código do Aeroporto de Partida",
            codigo_aeroporto_chegada: "Código do Aeroporto de Chegada",
            numero_viagens: "Número de Viagens",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.descricao_viagem) errors.descricao_viagem = "Obrigatório.";

            if (!rowData.codigo_aeroporto_partida) errors.codigo_aeroporto_partida = "Obrigatório.";
            if (!rowData.codigo_aeroporto_chegada) errors.codigo_aeroporto_chegada = "Obrigatório.";

            const numViagensVal = rowData.numero_viagens;
            if (!isFilled(numViagensVal) || isNaN(parseInt(numViagensVal)) || parseInt(numViagensVal) <= 0 || String(numViagensVal).includes('.') || String(numViagensVal).includes(',')) {
                errors.numero_viagens = "Deve ser um número inteiro e positivo.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    employee_commuting: {
        displayName: "Transporte de Funcionários",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            descricao_identificadora: "Identificação do Grupo",
            meio_utilizado: "Meio Utilizado",
            tipo_reporte: "Tipo de Reporte",
            tipo_combustivel: "Tipo de Combustível",
            consumo: "Consumo",
            unidade_consumo: "Unidade (Combustível)",
            distancia_km: "Distância (km)",
            endereco_funcionario: "Endereço Funcionário",
            endereco_trabalho: "Endereço Trabalho",
            dias_deslocados: "Dias Deslocados (Opcional)",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            meio_utilizado: [
                "Transporte fretado - Van", "Transporte fretado - ônibus de viagem", "Tranporte fretado - Automóvel pequeno",
                "Transporte público - Metrô", "Transporte público - ônibus", "Transporte público - trem urbano",
                "Veículo próprio - automóvel", "Veículo próprio - motocicleta", "Veículo próprio - bicicleta",
                "Uber", "Sem informação"
            ],
            tipo_reporte: ["Consumo", "Distância", "Endereço"],
            tipo_combustivel: [
                "Gasolina Automotiva", "Óleo Diesel", "Gás Natural Veicular (GNV)", "Gás Natural Liquefeito (GNL)",
                "Gás Liquefeito de Petróleo (GLP)", "Querosene de Aviação", "Gasolina de Aviação", "Lubrificantes",
                "Metanol", "Óleo Combustível", "Etanol Hidratado", "Biodiesel (B100)", "Biometano",
                "Bioquerosene (SAF)", "HVO (diesel verde)", "Biometanol", "Etanol Anidro"
            ]
        },
        autoFillMap: {
            tipo_combustivel: {
                targetColumn: "unidade_consumo",
                map: {
                    "Gasolina Automotiva": "litros", "Óleo Diesel": "litros", "Gás Natural Veicular (GNV)": "m³",
                    "Gás Natural Liquefeito (GNL)": "litros", "Gás Liquefeito de Petróleo (GLP)": "kg",
                    "Querosene de Aviação": "litros", "Gasolina de Aviação": "litros", "Lubrificantes": "litros",
                    "Metanol": "litros", "Óleo Combustível": "litros", "Etanol Hidratado": "litros",
                    "Biodiesel (B100)": "litros", "Biometano": "m³", "Bioquerosene (SAF)": "litros",
                    "HVO (diesel verde)": "litros", "Biometanol": "litros", "Etanol Anidro": "litros"
                }
            }
        },
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.descricao_identificadora) errors.descricao_identificadora = "Obrigatório.";
            
            if (!this.validOptions.meio_utilizado.includes(rowData.meio_utilizado)) errors.meio_utilizado = "Meio utilizado inválido.";
            if (!this.validOptions.tipo_reporte.includes(rowData.tipo_reporte)) errors.tipo_reporte = "Selecione 'Consumo', 'Distância' ou 'Endereço'.";

            // Lógica Condicional
            if (rowData.tipo_reporte === 'Consumo') {
                if (!this.validOptions.tipo_combustivel.includes(rowData.tipo_combustivel)) errors.tipo_combustivel = "Combustível inválido.";
                
                const consumoVal = rowData.consumo;
                if (!isFilled(consumoVal) || isNaN(parseFloat(consumoVal)) || parseFloat(consumoVal) <= 0) errors.consumo = "Consumo obrigatório e positivo.";
                
                const expectedUnit = this.autoFillMap.tipo_combustivel.map[rowData.tipo_combustivel];
                if (rowData.tipo_combustivel && rowData.unidade_consumo !== expectedUnit) errors.unidade_consumo = `Unidade incorreta (deve ser ${expectedUnit}).`;

                // Limpar outros campos
                if (isFilled(rowData.distancia_km)) errors.distancia_km = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.endereco_funcionario)) errors.endereco_funcionario = "Deve ser vazio para reporte por Consumo.";
                if (isFilled(rowData.endereco_trabalho)) errors.endereco_trabalho = "Deve ser vazio para reporte por Consumo.";

            } else if (rowData.tipo_reporte === 'Distância') {
                const distVal = rowData.distancia_km;
                if (!isFilled(distVal) || isNaN(parseFloat(distVal)) || parseFloat(distVal) <= 0) errors.distancia_km = "Distância obrigatória e positiva.";

                // Limpar outros campos
                if (isFilled(rowData.tipo_combustivel)) errors.tipo_combustivel = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.endereco_funcionario)) errors.endereco_funcionario = "Deve ser vazio para reporte por Distância.";
                if (isFilled(rowData.endereco_trabalho)) errors.endereco_trabalho = "Deve ser vazio para reporte por Distância.";

            } else if (rowData.tipo_reporte === 'Endereço') {
                if (!rowData.endereco_funcionario) errors.endereco_funcionario = "Endereço do funcionário obrigatório.";
                if (!rowData.endereco_trabalho) errors.endereco_trabalho = "Endereço do trabalho obrigatório.";

                // Limpar outros campos
                if (isFilled(rowData.tipo_combustivel)) errors.tipo_combustivel = "Deve ser vazio para reporte por Endereço.";
                if (isFilled(rowData.consumo)) errors.consumo = "Deve ser vazio para reporte por Endereço.";
                if (isFilled(rowData.unidade_consumo)) errors.unidade_consumo = "Deve ser vazio para reporte por Endereço.";
                if (isFilled(rowData.distancia_km)) errors.distancia_km = "Deve ser vazio para reporte por Endereço.";
            }

            // Dias Deslocados (Opcional, mas se preenchido deve ser inteiro positivo)
            const diasVal = rowData.dias_deslocados;
            if (isFilled(diasVal)) {
                if (isNaN(parseInt(diasVal)) || parseInt(diasVal) <= 0 || String(diasVal).includes('.') || String(diasVal).includes(',')) {
                    errors.dias_deslocados = "Deve ser um número inteiro positivo.";
                }
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    energy_generation: {
        displayName: "Geração de Energia",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            // descricao_fonte REMOVIDO, pois o "fonte_geracao" atuará como identificador
            fonte_geracao: "Fonte de Geração",
            total_geracao: "Total de Geração",
            unidade_medida: "Unidade de Medida",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            fonte_geracao: ["Eólica", "Solar", "Hidro", "Biomassa", "Carvão"],
            unidade_medida: ["KWh", "MWh"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            
            if (!this.validOptions.fonte_geracao.includes(rowData.fonte_geracao)) {
                errors.fonte_geracao = "Selecione uma fonte válida.";
            }

            const totalVal = rowData.total_geracao;
            if (!isFilled(totalVal) || isNaN(parseFloat(totalVal)) || parseFloat(totalVal) < 0) {
                errors.total_geracao = `Entrada inválida ('${totalVal}'). Insira um número positivo ou zero.`;
            }

            if (!this.validOptions.unidade_medida.includes(rowData.unidade_medida)) {
                errors.unidade_medida = "Selecione 'KWh' ou 'MWh'.";
            }

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    },
    planted_forest: {
        displayName: "Área de Floresta Plantada",
        hasUnits: true,
        headerDisplayNames: {
            ano: "Ano",
            periodo: "Período",
            unidade_empresarial: "Unidade Empresarial",
            identificacao_area: "Identificação da Área",
            nome_especie: "Nome da Espécie",
            area_antepenultimo: "Área no final de {ANO-2} (ha)",
            idade_antepenultimo: "Faixa de idade em {ANO-2} (anos)",
            idade_penultimo: "Faixa de idade em {ANO-1} (anos)",
            area_colhida_penultimo: "Área Colhida/Desmatada em {ANO-1} (ha)",
            area_atual: "Área no final de {ANO} (ha)",
            comentarios: "Comentários"
        },
        validOptions: {
            periodo: ["Anual", "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            nome_especie: ["Amazônia", "Cerrado", "Mata Atlântica", "Caatinga", "Pampa", "Pantanal"]
        },
        autoFillMap: {},
        validateRow: function(rowData) {
            const errors = {};
            const isFilled = (value) => value !== null && value !== undefined && value !== '';

            if (!rowData.ano || isNaN(parseInt(rowData.ano)) || String(rowData.ano).length !== 4) errors.ano = "Deve ser um ano com 4 dígitos.";
            if (!this.validOptions.periodo.includes(rowData.periodo)) errors.periodo = "Período inválido.";
            if (!rowData.unidade_empresarial) errors.unidade_empresarial = "Obrigatório.";
            if (!rowData.identificacao_area) errors.identificacao_area = "Obrigatório.";

            if (!this.validOptions.nome_especie.includes(rowData.nome_especie)) {
                errors.nome_especie = "Selecione uma espécie válida.";
            }

            // Validação de Floats
            const floatFields = ['area_antepenultimo', 'area_colhida_penultimo', 'area_atual'];
            floatFields.forEach(field => {
                const val = rowData[field];
                if (isFilled(val)) {
                    if (isNaN(parseFloat(val)) || parseFloat(val) < 0) {
                        errors[field] = "Deve ser um número positivo.";
                    }
                }
            });

            // Validação de Inteiros
            const intFields = ['idade_antepenultimo', 'idade_penultimo'];
            intFields.forEach(field => {
                const val = rowData[field];
                if (isFilled(val)) {
                    if (isNaN(parseInt(val)) || parseInt(val) < 0 || String(val).includes('.') || String(val).includes(',')) {
                        errors[field] = "Deve ser um número inteiro positivo.";
                    }
                }
            });

            return { isValid: Object.keys(errors).length === 0, errors: errors, sanitizedData: rowData };
        }
    }
};
</file>

<file path="backend/database.js">
// arquivo: backend/database.js

const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const { validationSchemas } = require('../shared/validators.js');

const dbPath = path.resolve(__dirname, 'ecofinance.db');

const db = new sqlite3.Database(dbPath, (err) => {
  if (err) {
    console.error('Erro ao abrir o banco de dados', err.message);
  } else {
    console.log('Conectado ao banco de dados SQLite em:', dbPath);
    
    db.serialize(() => {
        db.run(`CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, email TEXT UNIQUE, password TEXT)`, (err) => { if (err) console.error('Erro tabela users:', err); else console.log('Tabela "users" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS contacts (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, unit_id INTEGER, email TEXT, phone TEXT, FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE SET NULL)`, (err) => { if (err) console.error('Erro tabela contacts:', err); else console.log('Tabela "contacts" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS units (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, cidade TEXT, estado TEXT, pais TEXT, numero_colaboradores INTEGER)`, (err) => { if (err) console.error('Erro tabela units:', err); else console.log('Tabela "units" pronta.'); });
        db.run(`CREATE TABLE IF NOT EXISTS mobile_combustion_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, descricao_fonte TEXT, controlado_empresa BOOLEAN, tipo_entrada TEXT, combustivel TEXT, consumo REAL, unidade_consumo TEXT, distancia_percorrida REAL, unidade_distancia TEXT, tipo_veiculo TEXT)`, (err) => { if (err) console.error('Erro tabela mobile_combustion_data:', err); else console.log('Tabela "mobile_combustion_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS stationary_combustion_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, descricao_da_fonte TEXT, combustivel_estacionario TEXT, consumo REAL, unidade TEXT, controlado_empresa BOOLEAN)`, (err) => { if (err) console.error('Erro tabela stationary_combustion_data:', err); else console.log('Tabela "stationary_combustion_data" pronta.'); });

        db.run(`CREATE TABLE IF NOT EXISTS production_sales_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER NOT NULL, periodo TEXT, unidade_empresarial TEXT NOT NULL, produto TEXT NOT NULL, quantidade_vendida INTEGER CHECK(quantidade_vendida > 0), unidade_medida TEXT NOT NULL, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela production_sales_data:', err); else console.log('Tabela "production_sales_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS lubricants_ippu_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, fonte_emissao TEXT, tipo_lubrificante TEXT, consumo REAL, unidade TEXT, controlado_empresa BOOLEAN)`, (err) => { if (err) console.error('Erro tabela lubricants_ippu_data:', err); else console.log('Tabela "lubricants_ippu_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS fugitive_emissions_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, fonte_emissao TEXT, tipo_gas TEXT, quantidade_reposta REAL, unidade TEXT, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela fugitive_emissions_data:', err); else console.log('Tabela "fugitive_emissions_data" pronta.'); });

        db.run(`CREATE TABLE IF NOT EXISTS fertilizers_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, tipo_fertilizante TEXT, quantidade_kg REAL, unidade TEXT, percentual_nitrogenio REAL, percentual_carbonato REAL, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela fertilizers_data:', err); else console.log('Tabela "fertilizers_data" pronta.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS effluents_controlled_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                tratamento_ou_destino TEXT NOT NULL,
                tipo_tratamento TEXT,
                tipo_destino_final TEXT,
                qtd_efluente_liquido_m3 REAL NOT NULL,
                unidade_efluente_liquido TEXT NOT NULL,
                qtd_componente_organico REAL NOT NULL,
                unidade_componente_organico TEXT NOT NULL,
                qtd_nitrogenio_mg_l REAL NOT NULL,
                unidade_nitrogenio TEXT NOT NULL,
                componente_organico_removido_lodo REAL,
                unidade_comp_organico_removido_lodo TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela effluents_controlled_data:', err); else console.log('Tabela "effluents_controlled_data" pronta.'); });
        
        db.run(`DROP TABLE IF EXISTS domestic_effluents_data`);
        
        db.run(`
            CREATE TABLE IF NOT EXISTS domestic_effluents_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                tipo_trabalhador TEXT NOT NULL,
                num_trabalhadores INTEGER NOT NULL,
                carga_horaria_media REAL NOT NULL,
                fossa_septica_propriedade TEXT NOT NULL,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela domestic_effluents_data:', err); else console.log('Tabela "domestic_effluents_data" recriada com a nova estrutura.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS land_use_change_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                uso_solo_anterior TEXT NOT NULL,
                bioma TEXT,
                fitofisionomia TEXT,
                tipo_area TEXT,
                area_hectare REAL NOT NULL,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela land_use_change_data:', err); else console.log('Tabela "land_use_change_data" pronta.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS solid_waste_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                destinacao_final TEXT,
                tipo_residuo TEXT,
                quantidade_gerado REAL,
                unidade TEXT,
                informar_cidade_uf TEXT,
                local_controlado_empresa TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                rastreabilidade_interna TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela solid_waste_data:', err); else console.log('Tabela "solid_waste_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS electricity_purchase_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                fonte_energia TEXT,
                especificar_fonte TEXT,
                consumo REAL,
                unidade_medida TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                rastreabilidade TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela electricity_purchase_data:', err); else console.log('Tabela "electricity_purchase_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS purchased_goods_services_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_item TEXT,
                tipo_item TEXT,
                quantidade REAL,
                unidade TEXT,
                valor_aquisicao REAL,
                bens_terceiros TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela purchased_goods_services_data:', err); else console.log('Tabela "purchased_goods_services_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS capital_goods_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                bem_capital TEXT,
                quantidade INTEGER,
                unidade TEXT,
                valor_aquisicao REAL,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela capital_goods_data:', err); else console.log('Tabela "capital_goods_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS upstream_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                modal_transporte TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                local_embarque TEXT,
                local_destino TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela upstream_transport_data:', err); else console.log('Tabela "upstream_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS business_travel_land_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_viagem TEXT,
                modal_viagem TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                distancia_percorrida REAL,
                unidade_distancia TEXT,
                km_reembolsado TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela business_travel_land_data:', err); else console.log('Tabela "business_travel_land_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS downstream_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                modal_transporte TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                local_embarque TEXT,
                local_destino TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela downstream_transport_data:', err); else console.log('Tabela "downstream_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS waste_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela waste_transport_data:', err); else console.log('Tabela "waste_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS home_office_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                regime_trabalho TEXT,
                num_funcionarios INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela home_office_data:', err); else console.log('Tabela "home_office_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS air_travel_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_viagem TEXT,
                codigo_aeroporto_partida TEXT,
                codigo_aeroporto_chegada TEXT,
                numero_viagens INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela air_travel_data:', err); else console.log('Tabela "air_travel_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS employee_commuting_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_identificadora TEXT,
                meio_utilizado TEXT,
                tipo_reporte TEXT,
                tipo_combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                distancia_km REAL,
                endereco_funcionario TEXT,
                endereco_trabalho TEXT,
                dias_deslocados INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela employee_commuting_data:', err); else console.log('Tabela "employee_commuting_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS energy_generation_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_fonte TEXT,
                fonte_geracao TEXT,
                total_geracao REAL,
                unidade_medida TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela energy_generation_data:', err); else console.log('Tabela "energy_generation_data" pronta.'); });

        // --- SPRINT 19: TABELA - Floresta Plantada ---
        db.run(`
            CREATE TABLE IF NOT EXISTS planted_forest_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                identificacao_area TEXT,
                nome_especie TEXT,
                area_antepenultimo REAL,
                idade_antepenultimo INTEGER,
                idade_penultimo INTEGER,
                area_colhida_penultimo REAL,
                area_atual REAL,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela planted_forest_data:', err); else console.log('Tabela "planted_forest_data" pronta.'); });

        // --- SPRINT 21: TABELA - Área de Conservação (ATUALIZADA) ---
        db.run(`DROP TABLE IF EXISTS conservation_area_data`, (err) => {
             // Drop para garantir a recriação correta com os novos campos
             if(!err) {
                db.run(`
                    CREATE TABLE IF NOT EXISTS conservation_area_data (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        ano INTEGER,
                        periodo TEXT,
                        unidade_empresarial TEXT,
                        descricao TEXT,
                        bioma TEXT,
                        fitofisionomia TEXT,
                        area_plantada TEXT,
                        plantio TEXT,
                        area_inicio_ano REAL,
                        area_fim_ano REAL,
                        motivo_alteracao TEXT,
                        responsavel TEXT,
                        area_responsavel TEXT,
                        email TEXT,
                        telefone TEXT,
                        comentarios TEXT
                    )
                `, (err) => { if (err) console.error('Erro tabela conservation_area_data:', err); else console.log('Tabela "conservation_area_data" atualizada e pronta.'); });
             }
        });


        db.run(`CREATE TABLE IF NOT EXISTS asset_typologies (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, unit_id INTEGER NOT NULL, source_type TEXT NOT NULL, description TEXT NOT NULL, asset_fields TEXT, is_active BOOLEAN DEFAULT TRUE)`, (err) => { if (err) console.error('Erro tabela asset_typologies:', err); else console.log('Tabela "asset_typologies" pronta.'); });
        
        db.all("PRAGMA table_info(asset_typologies)", (err, columns) => {
            if (err) {
                console.error("Erro ao ler colunas de asset_typologies:", err);
                return;
            }

            const hasResponsibleId = columns.some(col => col.name === 'responsible_contact_id');
            if (!hasResponsibleId) {
                db.run("ALTER TABLE asset_typologies ADD COLUMN responsible_contact_id INTEGER REFERENCES contacts(id) ON DELETE SET NULL", (err) => {
                    if (err) console.error("Erro ao adicionar coluna 'responsible_contact_id':", err);
                    else console.log("Coluna 'responsible_contact_id' adicionada a 'asset_typologies'.");
                });
            }

            const hasFrequency = columns.some(col => col.name === 'reporting_frequency');
            if (!hasFrequency) {
                db.run("ALTER TABLE asset_typologies ADD COLUMN reporting_frequency TEXT DEFAULT 'anual' NOT NULL", (err) => {
                    if (err) console.error("Erro ao adicionar coluna 'reporting_frequency':", err);
                    else console.log("Coluna 'reporting_frequency' adicionada a 'asset_typologies'.");
                });
            }
        });

        db.run(`DROP TABLE IF EXISTS source_configurations`, (err) => { 
            if (err) console.error('Erro ao remover tabela obsoleta source_configurations:', err); 
            else console.log('Tabela obsoleta "source_configurations" verificada/removida.'); 
        });

        db.run(`CREATE TABLE IF NOT EXISTS managed_options (id INTEGER PRIMARY KEY AUTOINCREMENT, field_key TEXT NOT NULL, value TEXT NOT NULL, UNIQUE(field_key, value))`, (err) => { if (err) console.error('Erro tabela managed_options:', err); else console.log('Tabela "managed_options" pronta.'); });
        db.run(`DROP TABLE IF EXISTS custom_options`, (err) => { if (err) console.error('Erro ao remover tabela antiga custom_options:', err); });
        
        db.run(`CREATE TABLE IF NOT EXISTS contact_source_associations (contact_id INTEGER NOT NULL, source_type TEXT NOT NULL, PRIMARY KEY (contact_id, source_type), FOREIGN KEY (contact_id) REFERENCES contacts (id) ON DELETE CASCADE)`, (err) => { if (err) console.error('Erro tabela contact_source_associations:', err); else console.log('Tabela "contact_source_associations" pronta.'); });

        
        console.log('Iniciando o seeding de opções padrão...');
        const sql = `INSERT OR IGNORE INTO managed_options (field_key, value) VALUES (?, ?)`;
        let totalOptions = 0;
        
        
        for (const schemaKey in validationSchemas) {
            const schema = validationSchemas[schemaKey];
            const options = schema.validOptions || {};
            
            for (const fieldKey in options) {
                const optionValues = Array.isArray(options[fieldKey]) ? options[fieldKey] : [];
                optionValues.forEach(value => {
                    db.run(sql, [fieldKey, value]);
                    totalOptions++;
                });
            }
        }
        console.log(`Seeding de opções padrão concluído. ${totalOptions} opções verificadas.`);
        
    });
  }
});

module.exports = db;
</file>

<file path="frontend/assets.js">
// arquivo: frontend/assets.js


import { validationSchemas } from '../shared/validators.js';

document.addEventListener('DOMContentLoaded', () => {
    
    
    const assetSchemas = {
        electricity_purchase: {
            displayName: "Compra de Eletricidade",
            fields: {
                fonte_energia: { label: "Fonte de Energia (Descrição)", type: "select" },
                especificar_fonte: { label: "Especificar Fonte Padrão", type: "select", showIf: { field: "fonte_energia", value: ["Mercado Livre Convencional", "Mercado Livre Incentivado", "Fonte Energética Específica"] } },
                unidade_medida: { label: "Unidade de Medida Padrão", type: "select" }
            }
        },
        solid_waste: {
            displayName: "Resíduos Sólidos",
            fields: {
                destinacao_final: { label: "Destinação Final (Descrição)", type: "select" },
                tipo_residuo: { label: "Tipo de Resíduo Padrão", type: "select" },
                unidade: { label: "Unidade Padrão", type: "select" },
                cidade_uf_destino: { label: "Cidade/UF de Destino", type: "text", placeholder: "Ex: Porto Alegre/RS", showIf: { field: "destinacao_final", value: "Aterro" } },
                local_controlado_empresa: { label: "Local Controlado pela Empresa?", type: "select" },
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        purchased_goods_services: {
            displayName: "Bens e Serviços Comprados",
            fields: {
                tipo_item: { label: "Tipo (Produto ou Serviço) Padrão", type: "select" },
                unidade: { label: "Unidade de Medida Padrão", type: "select", showIf: { field: "tipo_item", value: "Produto" } },
                bens_terceiros: { label: "Bens comprados por terceiros? (Padrão)", type: "select" },
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        capital_goods: {
            displayName: "Bens de Capital",
            fields: {
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        upstream_transport: {
            displayName: "Logística de Insumo",
            fields: {
                modal_transporte: { label: "Modal de Transporte Padrão", type: "select" },
                tipo_reporte: { label: "Forma de Reporte Padrão", type: "select" },
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        downstream_transport: {
            displayName: "Logística de Produto Final",
            fields: {
                insumo_transportado: { label: "Produto Transportado (Descrição)", type: "text" },
                modal_transporte: { label: "Modal de Transporte Padrão", type: "select" },
                tipo_reporte: { label: "Forma de Reporte Padrão", type: "select" },
                
                // Consumo
                combustivel: { label: "Combustível Padrão", type: "select", showIf: { field: "tipo_reporte", value: "Consumo" } },
                unidade_consumo: { label: "Unidade (Preenchimento Automático)", type: "text", showIf: { field: "tipo_reporte", value: "Consumo" }, disabled: true },
                
                // Distância
                classificacao_veiculo: { label: "Classificação do Veículo Padrão", type: "select", showIf: { field: "tipo_reporte", value: "Distância" } },
                unidade_distancia: { label: "Unidade de Distância Padrão", type: "select", showIf: { field: "tipo_reporte", value: "Distância" } },

                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        waste_transport: {
            displayName: "Logística de Resíduos",
            fields: {
                insumo_transportado: { label: "Resíduo Transportado (Descrição)", type: "text" },
                tipo_reporte: { label: "Forma de Reporte Padrão", type: "select" },
                
                // Consumo
                combustivel: { label: "Combustível Padrão", type: "select", showIf: { field: "tipo_reporte", value: "Consumo" } },
                unidade_consumo: { label: "Unidade (Preenchimento Automático)", type: "text", showIf: { field: "tipo_reporte", value: "Consumo" }, disabled: true },
                
                // Distância
                classificacao_veiculo: { label: "Classificação do Veículo Padrão", type: "select", showIf: { field: "tipo_reporte", value: "Distância" } },
                unidade_distancia: { label: "Unidade de Distância Padrão", type: "select", showIf: { field: "tipo_reporte", value: "Distância" } },

                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        home_office: {
            displayName: "Home Office",
            fields: {
                regime_trabalho: { 
                    label: "Dias da semana em Home Office (Regime)", 
                    type: "checkbox-group", 
                    options: ["Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado", "Domingo"]
                },
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        air_travel: {
            displayName: "Viagens Aéreas",
            fields: {
                descricao_viagem: { label: "Descrição da Viagem (Grupo/Categoria)", type: "text", placeholder: "Ex: Viagens Comerciais, Diretoria..." },
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        employee_commuting: {
            displayName: "Transporte de Funcionários",
            fields: {
                meio_utilizado: { label: "Meio Utilizado (Descrição)", type: "select" },
                tipo_reporte: { label: "Forma de Reporte Padrão", type: "select" },
                
                // Consumo
                tipo_combustivel: { label: "Combustível Padrão", type: "select", showIf: { field: "tipo_reporte", value: "Consumo" } },
                unidade_consumo: { label: "Unidade (Preenchimento Automático)", type: "text", showIf: { field: "tipo_reporte", value: "Consumo" }, disabled: true },

                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        energy_generation: {
            displayName: "Geração de Energia",
            fields: {
                fonte_geracao: { label: "Tipo de Fonte Padrão", type: "select" },
                unidade_medida: { label: "Unidade de Medida Padrão", type: "select" },
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        // --- SPRINT 19: Floresta Plantada ---
        planted_forest: {
            displayName: "Área de Floresta Plantada",
            fields: {
                identificacao_area: { label: "Identificação da Área (Descrição)", type: "text", placeholder: "Ex: Talhão A - Fazenda Norte" },
                nome_especie: { label: "Espécie Padrão", type: "select" },
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        // --- SPRINT 21: Área de Conservação (SEM DESCRIÇÃO MANUAL) ---
        conservation_area: {
            displayName: "Área de Conservação",
            fields: {
                // Bioma agora atua como "Descrição" na lista
                bioma: { label: "Bioma (Descrição)", type: "select" },
                fitofisionomia: { label: "Fitofisionomia", type: "select" }, 
                area_plantada: { label: "Área de conservação plantada?", type: "select" },
                plantio: { label: "Plantio", type: "text", placeholder: "Ex: 2010 ou 'Nativo'", showIf: { field: "area_plantada", value: "Sim" } },
                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        business_travel_land: {
            displayName: "Viagens a Negócios Terrestres",
            fields: {
                tipo_reporte: { label: "Forma de Reporte Padrão", type: "select" },
                
                // Campos GLOBAIS
                modal_viagem: { label: "Modal de Viagem Padrão", type: "select" },
                km_reembolsado: { label: "Reembolso de Km (Padrão)?", type: "select" },
                
                // Campos Específicos para Consumo
                combustivel: { label: "Combustível Padrão", type: "select", showIf: { field: "tipo_reporte", value: "Consumo" } }, 
                unidade_consumo: { label: "Unidade (Preenchimento Automático)", type: "text", showIf: { field: "tipo_reporte", value: "Consumo" }, disabled: true }, 

                responsible_contact_id: { label: "Responsável pela Informação", type: "select", isContact: true }
            }
        },
        combustao_estacionaria: { 
            displayName: "Combustão Estacionária", 
            fields: { 
                combustivel_estacionario: { label: "Combustível Padrão", type: "select" },
                unidade: { label: "Unidade de Consumo", type: "text", disabled: true } 
            } 
        },
        combustao_movel: { 
            displayName: "Combustão Móvel", 
            fields: { 
                tipo_entrada: { label: "Como os dados serão reportados?", type: "select" }, 
                combustivel: { label: "Combustível Padrão", type: "select", showIf: { field: "tipo_entrada", value: "consumo" } }, 
                unidade_consumo: { label: "Unidade de Consumo", type: "text", showIf: { field: "tipo_entrada", value: "consumo" }, disabled: true }, 
                tipo_veiculo: { label: "Tipo de Veículo Padrão", type: "select", showIf: { field: "tipo_entrada", value: "distancia" } }
            } 
        },
        dados_producao_venda: { 
            displayName: "Dados de Produção e Venda", 
            fields: { 
                unidade_medida: { label: "Unidade de Medida Padrão", type: "text" } 
            } 
        },
        ippu_lubrificantes: { 
            displayName: "IPPU - Lubrificantes", 
            fields: { 
                tipo_lubrificante: { label: "Tipo de Lubrificante Padrão", type: "select" }, 
                unidade: { label: "Unidade de Consumo Padrão", type: "select" } 
            } 
        },
        emissoes_fugitivas: { 
            displayName: "Emissões Fugitivas", 
            fields: { 
                tipo_gas: { label: "Gás Padrão", type: "select" }
            } 
        },
        fertilizantes: { 
            displayName: "Fertilizantes", 
            fields: { 
                percentual_nitrogenio: { label: "Percentual de Nitrogênio Padrão (%)", type: "number", min: 0, max: 100, step: 0.01 }, 
                percentual_carbonato: { label: "Percentual de Carbonato Padrão (%)", type: "number", min: 0, max: 100, step: 0.01 }
            } 
        },
        efluentes_controlados: {
            displayName: "Efluentes Controlados",
            fields: {
                tratamento_ou_destino: { label: "Tratamento ou Destino Final (Padrão)?", type: "select" },
                tipo_tratamento: { label: "Tipo de Tratamento Padrão", type: "select", showIf: { field: "tratamento_ou_destino", value: "Tratamento" } },
                tipo_destino_final: { label: "Tipo de Destino Final Padrão", type: "select", showIf: { field: "tratamento_ou_destino", value: "Destino Final" } },
                unidade_componente_organico: { label: "Unidade Padrão (Componente Orgânico)", type: "select" }
            }
        },
        efluentes_domesticos: {
            displayName: "Efluentes Domésticos",
            fields: {
                fossa_septica_propriedade: { label: "Fossa Séptica na Propriedade (Padrão)?", type: "select" }
            }
        },
        mudanca_uso_solo: {
            displayName: "Mudança do Uso do Solo",
            fields: {
                uso_solo_anterior: { label: "Uso do Solo Anterior (Padrão)", type: "select" },
                bioma: { label: "Bioma Padrão", type: "select", showIf: { field: "uso_solo_anterior", value: "Vegetação natural" } },
                fitofisionomia: { label: "Fitofisionomia Padrão", type: "text", showIf: { field: "uso_solo_anterior", value: "Vegetação natural" } },
                tipo_area: { label: "Tipo de Área Padrão", type: "select", showIf: { field: "uso_solo_anterior", value: "Vegetação natural" } }
            }
        }
    };
    
    const navPlaceholder = document.getElementById('nav-placeholder');
    const sourceSelector = document.getElementById('source-selector');
    const assetManagementSection = document.getElementById('asset-management-section');
    const form = document.getElementById('asset-form');
    const assetIdInput = document.getElementById('asset-id');
    const specificFieldsContainer = document.getElementById('specific-fields-container');
    const assetsThead = document.getElementById('assets-thead');
    const assetsTbody = document.getElementById('assets-tbody');
    const formTitle = document.getElementById('form-title');
    const tableTitle = document.getElementById('table-title');
    const cancelBtn = document.getElementById('cancel-btn');
    const unitSelect = document.getElementById('asset-unit');
    let currentSourceType = null;
    let contactsList = [];

    async function initializePage() { 
        if (navPlaceholder) { 
            fetch('nav.html').then(response => response.text()).then(data => { navPlaceholder.innerHTML = data; }); 
        } 
        const sortedSourceTypes = Object.keys(assetSchemas).sort((a, b) => 
            assetSchemas[a].displayName.localeCompare(assetSchemas[b].displayName)
        );
        sortedSourceTypes.forEach(sourceType => {
            const option = document.createElement('option');
            option.value = sourceType;
            option.textContent = assetSchemas[sourceType].displayName;
            sourceSelector.appendChild(option);
        });
        
        try { 
            const [unitsResponse, contactsResponse] = await Promise.all([ 
                fetch('/api/units'), 
                fetch('/api/contacts') 
            ]); 
            const unitsList = await unitsResponse.json(); 
            contactsList = await contactsResponse.json();
            
            unitSelect.innerHTML = '<option value="">-- Selecione --</option>'; 
            if (unitsList.length > 1) { 
                const allUnitsOption = document.createElement('option'); 
                allUnitsOption.value = 'all'; 
                allUnitsOption.textContent = '*** TODAS AS UNIDADES ***'; 
                unitSelect.appendChild(allUnitsOption); 
            } 
            unitsList.forEach(unit => { 
                const option = document.createElement('option'); 
                option.value = unit.id; 
                option.textContent = unit.name; 
                unitSelect.appendChild(option); 
            }); 
        } catch (error) { 
            console.error("Erro na inicialização da página:", error); 
        } 
    }
    
    async function handleSourceSelection() { 
        currentSourceType = sourceSelector.value; 
        resetForm(); 
        if (!currentSourceType) { 
            assetManagementSection.style.display = 'none'; 
            return; 
        } 
        const schema = assetSchemas[currentSourceType]; 
        formTitle.textContent = `Adicionar Nova Fonte`; 
        tableTitle.textContent = `Fontes de ${schema.displayName} Cadastradas`; 
        await buildDynamicForm(schema); 
        buildDynamicTableHeaders(schema); 
        loadAssetTypologies(); 
        assetManagementSection.style.display = 'block'; 
    }
    
    function buildDynamicTableHeaders(schema) { 
        assetsThead.innerHTML = ''; 
        const headerRow = document.createElement('tr'); 
        
        // --- Lista de Schemas que usam Descrição Customizada ---
        // Adicionado 'conservation_area'
        const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area'].includes(currentSourceType);
        const mainDescriptionKey = usesCustomDescription ? Object.keys(schema.fields)[0] : 'description';
        const mainDescriptionLabel = usesCustomDescription ? schema.fields[mainDescriptionKey].label : 'Descrição';

        let headers = `<th>${mainDescriptionLabel}</th><th>Unidade</th><th>Frequência</th>`; 
        
        for (const key in schema.fields) { 
            if (usesCustomDescription && key === mainDescriptionKey) continue;
            headers += `<th>${schema.fields[key].label}</th>`; 
        } 
        headers += '<th>Ações</th>'; 
        headerRow.innerHTML = headers; 
        assetsThead.appendChild(headerRow); 
    }
    
    async function loadAssetTypologies() { 
        if (!currentSourceType) return; 
        try { 
            const response = await fetch(`/api/asset-typologies?source_type=${currentSourceType}`); 
            const typologies = await response.json(); 
            assetsTbody.innerHTML = ''; 
            typologies.forEach(typo => { 
                const tr = document.createElement('tr'); 
                
                // --- Lista de Schemas que usam Descrição Customizada ---
                const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area'].includes(currentSourceType);
                const mainDescriptionKey = usesCustomDescription ? Object.keys(assetSchemas[currentSourceType].fields)[0] : 'description';

                const mainDescription = usesCustomDescription 
                    ? (typo.asset_fields[mainDescriptionKey] || typo.description) 
                    : typo.description;
                
                // Lógica de limpeza de dados para exibição
                const displayFields = { ...typo.asset_fields };
                if (currentSourceType === 'combustao_movel') {
                    const tipoEntrada = displayFields.tipo_entrada;
                    if (tipoEntrada === 'consumo') {
                        displayFields.tipo_veiculo = ''; 
                    } else if (tipoEntrada === 'distancia') {
                        displayFields.combustivel = ''; 
                        displayFields.unidade_consumo = '';
                    }
                } else if (currentSourceType === 'business_travel_land') {
                     const tipoReporte = displayFields.tipo_reporte;
                     if (tipoReporte === 'Consumo') {
                         // modal e reembolso são globais
                     } else if (tipoReporte === 'Distância') {
                         displayFields.combustivel = '';
                         displayFields.unidade_consumo = '';
                     }
                } else if (currentSourceType === 'downstream_transport' || currentSourceType === 'waste_transport') {
                     const tipoReporte = displayFields.tipo_reporte;
                     if (tipoReporte === 'Consumo') {
                         displayFields.classificacao_veiculo = '';
                         displayFields.unidade_distancia = '';
                     } else if (tipoReporte === 'Distância') {
                         displayFields.combustivel = '';
                         displayFields.unidade_consumo = '';
                     }
                } else if (currentSourceType === 'employee_commuting') {
                     const tipoReporte = displayFields.tipo_reporte;
                     if (tipoReporte === 'Consumo') {
                         // Mantém combustível
                     } else if (tipoReporte === 'Distância') {
                         displayFields.tipo_combustivel = '';
                         displayFields.unidade_consumo = '';
                     } else if (tipoReporte === 'Endereço') {
                         displayFields.tipo_combustivel = '';
                         displayFields.unidade_consumo = '';
                     }
                }
                
                const frequencyText = typo.reporting_frequency === 'mensal' ? 'Mensal' : 'Anual';
                let rowHtml = `<td>${mainDescription}</td><td>${typo.unit_name}</td><td>${frequencyText}</td>`; 
                const schema = assetSchemas[currentSourceType]; 
                
                for (const key in schema.fields) { 
                    if (usesCustomDescription && key === mainDescriptionKey) continue;
                    if (key === 'responsible_contact_id') {
                        rowHtml += `<td>${typo.responsible_contact_name || ''}</td>`;
                    } else {
                        rowHtml += `<td>${displayFields[key] || ''}</td>`; 
                    }
                } 
                rowHtml += `<td> <button class="action-btn edit-btn" data-id="${typo.id}">Editar</button> <button class="action-btn delete-btn" data-id="${typo.id}">Deletar</button> </td>`; 
                tr.innerHTML = rowHtml; 
                assetsTbody.appendChild(tr); 
            }); 
        } catch (error) { 
            console.error("Erro ao carregar tipologias:", error); 
        } 
    }
    
    async function handleFormSubmit(e) { 
        e.preventDefault(); 
        const id = assetIdInput.value; 
        const asset_fields = {}; 
        
        let responsibleContactId = null;
        let reportingFrequency = document.getElementById('reporting-frequency').value;

        form.querySelectorAll('[data-key]').forEach(input => {
             const fieldWrapper = input.closest('.form-group');
             if (fieldWrapper && fieldWrapper.style.display !== 'none') {
                 const key = input.dataset.key;
                 if (key === 'responsible_contact_id') {
                     responsibleContactId = input.value;
                 } else if (key !== 'reporting_frequency') {
                     asset_fields[key] = input.value;
                 }
             }
        });

        // --- Lista de Schemas que usam Descrição Customizada ---
        const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area'].includes(currentSourceType);
        const mainDescriptionKey = usesCustomDescription ? Object.keys(assetSchemas[currentSourceType].fields)[0] : null;

        const descriptionValue = usesCustomDescription
            ? asset_fields[mainDescriptionKey]
            : document.getElementById('asset-description').value;
        
        const unitValue = document.getElementById('asset-unit').value; 
        const data = { 
            description: descriptionValue, 
            unit_id: unitValue, 
            source_type: currentSourceType, 
            asset_fields: asset_fields,
            responsible_contact_id: responsibleContactId,
            reporting_frequency: reportingFrequency
        }; 
        
        const method = id ? 'PUT' : 'POST'; 
        const url = id ? `/api/asset-typologies/${id}` : '/api/asset-typologies'; 
        try { 
            const response = await fetch(url, { method: method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }); 
            if (!response.ok) { 
                const errorData = await response.json(); 
                throw new Error(errorData.error || 'Falha ao salvar a fonte.'); 
            } 
            
            if (id) {
                resetForm();
            } else {
                assetIdInput.value = '';
            }
            
            loadAssetTypologies(); 
        } catch (error) { 
            console.error("Erro ao salvar:", error); 
            alert(`Ocorreu um erro ao salvar: ${error.message}`); 
        } 
    }
    
    async function handleTableClick(e) {
        const target = e.target;
        const id = target.dataset.id;
        if (!id) return;

        if (target.classList.contains('edit-btn')) {
            const response = await fetch(`/api/asset-typologies?source_type=${currentSourceType}`);
            const typologies = await response.json();
            const typoToEdit = typologies.find(t => t.id == id);
            
            if (typoToEdit) {
                assetIdInput.value = typoToEdit.id;
                
                // --- Lista de Schemas que usam Descrição Customizada ---
                const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area'].includes(currentSourceType);
                if (!usesCustomDescription) {
                    document.getElementById('asset-description').value = typoToEdit.description;
                }
                
                document.getElementById('asset-unit').value = typoToEdit.unit_id;
                
                await buildDynamicForm(assetSchemas[currentSourceType]); 
                
                document.getElementById('reporting-frequency').value = typoToEdit.reporting_frequency;

                form.querySelectorAll('[data-key]').forEach(input => {
                    const key = input.dataset.key;
                    if (key === 'responsible_contact_id') {
                        input.value = typoToEdit.responsible_contact_id || '';
                    } else if (typoToEdit.asset_fields[key] !== undefined) {
                        input.value = typoToEdit.asset_fields[key];
                        
                        // Lógica especial para checkbox-group
                        if (assetSchemas[currentSourceType].fields[key].type === 'checkbox-group') {
                            const selectedValues = (typoToEdit.asset_fields[key] || '').split(', ');
                            const container = input.closest('.form-group');
                            container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                                cb.checked = selectedValues.includes(cb.value);
                            });
                        }
                    }
                        
                    const conditionalTriggers = ['tipo_entrada', 'tratamento_ou_destino', 'uso_solo_anterior', 'destinacao_final', 'fonte_energia', 'tipo_item', 'tipo_reporte', 'combustivel', 'tipo_combustivel', 'area_plantada', 'bioma'];
                    if (conditionalTriggers.includes(key)) {
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });

                formTitle.textContent = `Editando Fonte: ${typoToEdit.description}`;
                cancelBtn.style.display = 'inline-block';
                window.scrollTo(0,0);
            }
        } else if (target.classList.contains('delete-btn')) {
            if (confirm('Tem certeza que deseja deletar esta fonte?')) {
                try {
                    await fetch(`/api/asset-typologies/${id}`, { method: 'DELETE' });
                    loadAssetTypologies();
                } catch (error) {
                    console.error("Erro ao deletar:", error);
                    alert('Ocorreu um erro ao deletar. Verifique o console.');
                }
            }
        }
    }
    
    function resetForm() {
        form.reset();
        assetIdInput.value = '';
        if (currentSourceType) {
            formTitle.textContent = `Adicionar Nova Fonte`;
        }
        cancelBtn.style.display = 'none';

        const descriptionGroup = document.getElementById('asset-description').parentElement;
        // --- Lista de Schemas que usam Descrição Customizada ---
        const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area'].includes(currentSourceType);

        if (usesCustomDescription) {
            descriptionGroup.style.display = 'none';
            descriptionGroup.querySelector('input').required = false;
        } else {
            descriptionGroup.style.display = '';
            descriptionGroup.querySelector('input').required = true;
        }

        const triggerFields = ['field-tipo_entrada', 'field-tratamento_ou_destino', 'uso_solo_anterior', 'field-combustivel', 'field-combustivel_estacionario', 'field-destinacao_final', 'field-fonte_energia', 'field-tipo_item', 'field-tipo_reporte', 'field-tipo_combustivel', 'field-area_plantada', 'field-bioma'];
        triggerFields.forEach(id => {
            const trigger = document.getElementById(id);
            if (trigger) trigger.dispatchEvent(new Event('change'));
        });
        
        // Resetar checkboxes
        form.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
    }

    async function buildDynamicForm(schema) { 
        specificFieldsContainer.innerHTML = '';
        form.querySelectorAll('.dynamic-field').forEach(el => el.remove()); 
        
        const fieldElements = {};
        const triggerFields = new Set();
        const autoFillTriggers = new Set();
        // --- Lista de Schemas que usam Descrição Customizada ---
        const usesCustomDescription = ['solid_waste', 'electricity_purchase', 'downstream_transport', 'waste_transport', 'home_office', 'air_travel', 'employee_commuting', 'energy_generation', 'planted_forest', 'conservation_area'].includes(currentSourceType);
        
        const firstRowContainer = document.querySelector('#asset-form .form-row');
        const descriptionFieldGroup = document.getElementById('asset-description').parentElement;

        const validationSchema = validationSchemas[currentSourceType];
        
        if (validationSchema && validationSchema.autoFillMap) {
            Object.keys(validationSchema.autoFillMap).forEach(key => autoFillTriggers.add(key));
        }

        let dependencyConfig = null;
        if (validationSchema && validationSchema.dependencyMap) {
            dependencyConfig = validationSchema.dependencyMap;
            triggerFields.add(dependencyConfig.triggerField);
        }

        for (const key in schema.fields) {
            if (schema.fields[key].showIf) {
                triggerFields.add(schema.fields[key].showIf.field);
            }
        }
        
        const frequencyWrapper = document.createElement('div');
        frequencyWrapper.className = 'form-row dynamic-field';
        frequencyWrapper.innerHTML = `
            <div class="form-group">
                <label for="reporting-frequency">Frequência de Reporte</label>
                <select id="reporting-frequency" data-key="reporting_frequency">
                    <option value="anual">Anual</option>
                    <option value="mensal">Mensal</option>
                </select>
            </div>
        `;
        specificFieldsContainer.appendChild(frequencyWrapper);


        for (const key in schema.fields) { 
            const field = schema.fields[key]; 
            const wrapper = document.createElement('div');
            wrapper.className = 'form-group dynamic-field';
            wrapper.id = `row-${key}`; 
            
            const label = document.createElement('label'); 
            label.setAttribute('for', `field-${key}`); 
            label.textContent = field.label; 
            
            let input; 
            
            if (field.type === 'select') {
                input = document.createElement('select');
            } else if (field.type === 'checkbox-group') {
                input = document.createElement('input');
                input.type = 'hidden'; 
                
                const checkboxContainer = document.createElement('div');
                checkboxContainer.style.display = 'flex';
                checkboxContainer.style.flexWrap = 'wrap';
                checkboxContainer.style.gap = '10px';
                checkboxContainer.style.marginTop = '5px';

                field.options.forEach(opt => {
                    const cbWrapper = document.createElement('div');
                    cbWrapper.style.display = 'flex';
                    cbWrapper.style.alignItems = 'center';
                    
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.value = opt;
                    cb.id = `cb-${key}-${opt}`;
                    cb.style.marginRight = '5px';
                    
                    const cbLabel = document.createElement('label');
                    cbLabel.htmlFor = `cb-${key}-${opt}`;
                    cbLabel.textContent = opt;
                    cbLabel.style.fontWeight = 'normal';
                    cbLabel.style.marginBottom = '0';

                    cb.addEventListener('change', () => {
                        const checkedOptions = Array.from(checkboxContainer.querySelectorAll('input[type="checkbox"]:checked'))
                                                    .map(c => c.value);
                        input.value = checkedOptions.join(', ');
                    });

                    cbWrapper.appendChild(cb);
                    cbWrapper.appendChild(cbLabel);
                    checkboxContainer.appendChild(cbWrapper);
                });
                
                wrapper.appendChild(label);
                wrapper.appendChild(checkboxContainer);
            } else { 
                input = document.createElement('input'); 
                input.type = field.type || 'text';
                if(field.placeholder) input.placeholder = field.placeholder;
            }
            
            input.id = `field-${key}`; 
            input.dataset.key = key; 
            input.required = !field.showIf && field.type !== 'checkbox-group'; 
            if (field.disabled) input.disabled = true;

            if (field.type === 'select') {
                input.innerHTML = '<option value="">-- Selecione --</option>';

                if (field.isContact) {
                    contactsList.forEach(contact => {
                        const option = document.createElement('option');
                        option.value = contact.id;
                        option.textContent = `${contact.name} (${contact.unit_name || 'N/A'})`;
                        input.appendChild(option);
                    });
                } else {
                    const displayMap = validationSchema.displayValueMap?.[key];
                    const options = validationSchema.validOptions?.[key] || field.options || [];

                    options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = (displayMap && displayMap[opt]) ? displayMap[opt] : opt;
                        input.appendChild(option);
                    });
                }
            }
            
            fieldElements[key] = { row: wrapper, input: input, config: field };

            if (field.type !== 'checkbox-group') {
                wrapper.appendChild(label); 
                wrapper.appendChild(input); 
            } else {
                wrapper.appendChild(input); 
            }

            const mainDescriptionKey = usesCustomDescription ? Object.keys(schema.fields)[0] : null;

            if (usesCustomDescription && key === mainDescriptionKey) {
                firstRowContainer.insertBefore(wrapper, descriptionFieldGroup);
            } else {
                let targetRow = Array.from(specificFieldsContainer.querySelectorAll('.form-row.dynamic-field')).pop();
                if (!targetRow || targetRow.children.length >= 2) {
                    targetRow = document.createElement('div');
                    targetRow.className = 'form-row dynamic-field';
                    specificFieldsContainer.appendChild(targetRow);
                }
                wrapper.className = 'form-group dynamic-field';
                targetRow.appendChild(wrapper);
            }


            if (triggerFields.has(key) || autoFillTriggers.has(key)) {
                input.addEventListener('change', () => {
                    const selectedValue = input.value;
                    
                    // Lógica ShowIf
                    for (const fieldKey in fieldElements) {
                        const element = fieldElements[fieldKey];
                        const showIfConfig = element.config.showIf;
                        
                        if (showIfConfig && showIfConfig.field === key) {
                            const conditionValues = Array.isArray(showIfConfig.value) ? showIfConfig.value : [showIfConfig.value];
                            const isVisible = conditionValues.includes(selectedValue);
                            
                            element.row.style.display = isVisible ? '' : 'none';
                            element.input.required = isVisible;
                        }
                    }

                    // Lógica AutoFill
                    if (autoFillTriggers.has(key)) {
                        const rule = validationSchema.autoFillMap[key];
                        const targetValue = rule.map[selectedValue];
                        const targetField = fieldElements[rule.targetColumn];
                        if (targetField && targetValue !== undefined) {
                            targetField.input.value = targetValue;
                        } else if (targetField) {
                            targetField.input.value = '';
                        }
                    }

                    // Lógica de Dependência (Dropdown Dinâmico)
                    if (dependencyConfig && dependencyConfig.triggerField === key) {
                        const targetFieldKey = dependencyConfig.targetField;
                        const targetElement = fieldElements[targetFieldKey];
                        
                        if (targetElement && targetElement.input.tagName === 'SELECT') {
                            targetElement.input.innerHTML = '<option value="">-- Selecione --</option>';
                            const dependentOptions = dependencyConfig.data[selectedValue];
                            if (dependentOptions && Array.isArray(dependentOptions)) {
                                dependentOptions.forEach(opt => {
                                    const option = document.createElement('option');
                                    option.value = opt;
                                    option.textContent = opt;
                                    targetElement.input.appendChild(option);
                                });
                            }
                        }
                    }
                });
            }
        }
        
        new Set([...triggerFields, ...autoFillTriggers]).forEach(triggerKey => {
            const triggerElement = fieldElements[triggerKey];
            if (triggerElement) {
                triggerElement.input.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
        
        resetForm();
    }
    
    sourceSelector.addEventListener('change', handleSourceSelection);
    form.addEventListener('submit', handleFormSubmit);
    assetsTbody.addEventListener('click', handleTableClick);
    cancelBtn.addEventListener('click', resetForm);
    
    initializePage();
});
</file>

<file path="backend/server.js">
// arquivo: backend/server.js

// --- 1. IMPORTAÇÕES ---
const express = require('express');
const cors = require('cors');
const path = require('path');
const multer = require('multer');
const csv = require('csv-parser');
const xlsx = require('xlsx');
const fs = require('fs');
const bcrypt = require('bcrypt');
const db = require('./database.js'); 
const { validationSchemas } = require('../shared/validators.js');

// --- 2. CONFIGURAÇÕES ---
const app = express();
const PORT = process.env.PORT || 8080;
const saltRounds = 10;
const upload = multer({ dest: path.join(__dirname, 'uploads/') });

// --- 3. MIDDLEWARES ---
app.use(cors());
app.use(express.json());
const frontendPath = path.join(__dirname, '..', 'frontend');
app.use(express.static(frontendPath));
const sharedPath = path.join(__dirname, '..', 'shared');
app.use('/shared', express.static(sharedPath));

app.use((req, res, next) => {
    if (req.path.endsWith('.js')) res.contentType('text/javascript');
    next();
});

// --- 4. ROTA PRINCIPAL ---
app.get('/', (req, res) => {
    res.sendFile(path.join(frontendPath, 'login.html'));
});

// --- 5. ROTAS DA API ---

// Rotas de Autenticação
app.post('/api/register', async (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({ message: "Email e senha são obrigatórios." });
    }
    try {
        const hashedPassword = await bcrypt.hash(password, saltRounds);
        const sql = "INSERT INTO users (email, password) VALUES (?, ?)";
        db.run(sql, [email, hashedPassword], function(err) {
            if (err) {
                if (err.message.includes('UNIQUE constraint failed')) {
                    return res.status(409).json({ message: "E-mail já cadastrado." });
                }
                return res.status(500).json({ message: "Erro ao registrar usuário.", error: err.message });
            }
            res.status(201).json({ message: "Usuário registrado com sucesso!", userId: this.lastID });
        });
    } catch (error) {
        res.status(500).json({ message: "Erro interno no servidor.", error: error.message });
    }
});

app.post('/api/login', (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({ message: "Email e senha são obrigatórios." });
    }
    const sql = "SELECT * FROM users WHERE email = ?";
    db.get(sql, [email], (err, user) => {
        if (err) {
            return res.status(500).json({ message: "Erro no servidor.", error: err.message });
        }
        if (!user) {
            return res.status(404).json({ message: "Usuário não encontrado." });
        }
        bcrypt.compare(password, user.password, (err, result) => {
            if (err) {
                return res.status(500).json({ message: "Erro ao verificar senha.", error: err.message });
            }
            if (result) {
                res.status(200).json({ message: "Login bem-sucedido!" });
            } else {
                res.status(401).json({ message: "Senha incorreta." });
            }
        });
    });
});

// Rotas de Contatos (Responsáveis)
app.get('/api/contacts', (req, res) => {
    const sqlContacts = `
        SELECT 
            c.id, c.name, c.unit_id, c.email, c.phone,
            u.name as unit_name 
        FROM contacts c
        LEFT JOIN units u ON c.unit_id = u.id
        ORDER BY c.name
    `;
    db.all(sqlContacts, [], (err, contacts) => {
        if (err) return res.status(500).json({ "error": err.message });

        const sqlAssociations = "SELECT * FROM contact_source_associations";
        db.all(sqlAssociations, [], (err, associations) => {
            if (err) return res.status(500).json({ "error": err.message });
            
            const contactsWithSources = contacts.map(contact => {
                const associatedSources = associations
                    .filter(assoc => assoc.contact_id === contact.id)
                    .map(assoc => assoc.source_type);
                return { ...contact, sources: associatedSources };
            });

            res.json(contactsWithSources);
        });
    });
});
app.post('/api/contacts', (req, res) => {
    const { name, unit_id, email, phone, sources = [] } = req.body;
    if (!name) return res.status(400).json({ "error": "O nome é obrigatório." });

    db.run("INSERT INTO contacts (name, unit_id, email, phone) VALUES (?, ?, ?, ?)", [name, unit_id, email, phone], function(err) {
        if (err) return res.status(500).json({ "error": err.message });
        
        const contactId = this.lastID;
        if (sources.length === 0) {
            return res.status(201).json({ "id": contactId });
        }

        const placeholders = sources.map(() => '(?, ?)').join(',');
        const sql = `INSERT INTO contact_source_associations (contact_id, source_type) VALUES ${placeholders}`;
        
        const params = [];
        sources.forEach(sourceType => {
            params.push(contactId, sourceType);
        });

        db.run(sql, params, function(err) {
            if (err) return res.status(500).json({ "error": `Erro ao salvar associações: ${err.message}` });
            res.status(201).json({ "id": contactId });
        });
    });
});
app.put('/api/contacts/:id', (req, res) => {
    const contactId = req.params.id;
    const { name, unit_id, email, phone, sources = [] } = req.body;

    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        db.run("UPDATE contacts SET name = ?, unit_id = ?, email = ?, phone = ? WHERE id = ?", [name, unit_id, email, phone, contactId]);
        db.run("DELETE FROM contact_source_associations WHERE contact_id = ?", [contactId]);

        if (sources.length > 0) {
            const placeholders = sources.map(() => '(?, ?)').join(',');
            const sql = `INSERT INTO contact_source_associations (contact_id, source_type) VALUES ${placeholders}`;
            const params = [];
            sources.forEach(sourceType => params.push(contactId, sourceType));
            db.run(sql, params);
        }

        db.run("COMMIT", (err) => {
            if (err) {
                db.run("ROLLBACK");
                return res.status(500).json({ "error": `Erro na transação: ${err.message}` });
            }
            res.status(200).json({ changes: 1 });
        });
    });
});
app.delete('/api/contacts/:id', (req, res) => {
    db.run("DELETE FROM contacts WHERE id = ?", [req.params.id], function(err) {
        if (err) return res.status(500).json({ "error": err.message });
        res.status(200).json({ deleted: this.changes });
    });
});

// --- ROTAS DE UNIDADES ---
app.get('/api/units', (req, res) => {
    db.all("SELECT * FROM units ORDER BY name", [], (err, rows) => {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.json(rows);
    });
});
app.post('/api/units', (req, res) => {
    const { name, cidade, estado, pais, numero_colaboradores } = req.body;
    if (!name || !cidade || !estado || !pais || !numero_colaboradores) { 
        return res.status(400).json({ "error": "Todos os campos são obrigatórios." }); 
    }
    const sql = "INSERT INTO units (name, cidade, estado, pais, numero_colaboradores) VALUES (?, ?, ?, ?, ?)";
    const params = [name, cidade, estado, pais, numero_colaboradores];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(201).json({ "id": this.lastID });
    });
});
app.put('/api/units/:id', (req, res) => {
    const { name, cidade, estado, pais, numero_colaboradores } = req.body;
    if (!name || !cidade || !estado || !pais || !numero_colaboradores) { 
        return res.status(400).json({ "error": "Todos os campos são obrigatórios." }); 
    }
    const sql = "UPDATE units SET name = ?, cidade = ?, estado = ?, pais = ?, numero_colaboradores = ? WHERE id = ?";
    const params = [name, cidade, estado, pais, numero_colaboradores, req.params.id];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ changes: this.changes });
    });
});
app.delete('/api/units/:id', (req, res) => {
    db.run("DELETE FROM units WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

// Rotas de Upload e Template
app.post('/api/upload', upload.single('file'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).send('Nenhum arquivo enviado.');
        }
        const filePath = req.file.path;
        const { source_type } = req.body; 

        const normalizeHeader = (header) => {
            return header.toString()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                .trim()
                .replace(/[\(\)]/g, '')
                .replace(/[^\w\s-]/g, '')
                .replace(/[\s-]+/g, '_');
        };
        
        const processAndSendData = (data) => {
            const processedData = data.map(row => {
                const newRow = {};
                for (const key in row) {
                    let value = row[key];

                    if (source_type === 'combustao_movel' && key === 'tipo_entrada' && typeof value === 'string') {
                         const normalizedInput = value
                            .toLowerCase()
                            .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                            .trim();
                        
                        if (normalizedInput === 'por consumo') {
                            value = 'consumo';
                        } else if (normalizedInput === 'por distancia') {
                            value = 'distancia';
                        }
                    }

                    if (typeof value === 'string') {
                        value = value.trim();
                    }
                    newRow[key] = value;
                }
                return newRow;
            });
            fs.unlinkSync(filePath);
            res.status(200).json(processedData);
        };
        
        const schema = validationSchemas[source_type];
        if (!schema) {
            fs.unlinkSync(filePath);
            return res.status(400).json({ message: 'Tipo de fonte inválido fornecido.' });
        }
        const headerMap = {};
        for(const key in schema.headerDisplayNames) {
            headerMap[normalizeHeader(schema.headerDisplayNames[key])] = key;
        }

        if (req.file.originalname.endsWith('.xlsx') || req.file.originalname.endsWith('.xls')) {
            const workbook = xlsx.readFile(filePath);
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            
            const jsonData = xlsx.utils.sheet_to_json(worksheet, { defval: "", raw: true });

            const results = jsonData.map(row => {
                const newRow = {};
                for (const excelHeader in row) {
                    const normalized = normalizeHeader(excelHeader);
                    const schemaKey = headerMap[normalized];
                    if (schemaKey) {
                        newRow[schemaKey] = row[excelHeader] !== null && row[excelHeader] !== undefined ? String(row[excelHeader]) : "";
                    }
                }
                return newRow;
            });
            
            processAndSendData(results);
        } else {
            let results = [];
            fs.createReadStream(filePath)
                .pipe(csv({
                    mapHeaders: ({ header }) => headerMap[normalizeHeader(header)] || normalizeHeader(header)
                }))
                .on('data', (data) => results.push(data))
                .on('end', () => {
                    processAndSendData(results);
                });
        }
    } catch (error) {
        console.error("Erro no upload:", error);
        if (req.file && fs.existsSync(req.file.path)) {
            fs.unlinkSync(req.file.path);
        }
        res.status(500).json({ message: 'Erro interno ao processar o arquivo.' });
    }
});
app.get('/api/template/:tableName', (req, res) => {
    const { tableName } = req.params;
    const { format = 'csv' } = req.query;
    const schema = validationSchemas[tableName];
    if (!schema) { return res.status(404).send('Tipo de tabela não encontrado.'); }
    const headers = Object.values(schema.headerDisplayNames);
    if (format === 'xlsx') {
        const workbook = xlsx.utils.book_new();
        const worksheet = xlsx.utils.aoa_to_sheet([headers]);
        xlsx.utils.book_append_sheet(workbook, worksheet, 'Dados');
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=${tableName}_template.xlsx`);
        res.status(200).send(buffer);
    } else {
        const csvContent = headers.join(',');
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=${tableName}_template.csv`);
        res.status(200).send(csvContent);
    }
});
app.post('/api/export', (req, res) => {
    const { data, tableName } = req.body;
    if (!Array.isArray(data) || data.length === 0) { return res.status(400).send('Nenhum dado fornecido para exportação.'); }
    try {
        const worksheet = xlsx.utils.json_to_sheet(data);
        if (data.length > 0) {
            const headers = Object.keys(data[0]);
            worksheet['!cols'] = headers.map(header => {
                const maxLength = Math.max(...data.map(row => (row[header] || "").toString().length), header.length);
                return { wch: maxLength + 2 };
            });
        }
        const workbook = xlsx.utils.book_new();
        const sheetName = (tableName ? tableName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Dados Exportados').substring(0, 31);
        xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        const fileName = tableName ? `${tableName}_export.xlsx` : 'export.xlsx';
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=${fileName}`);
        res.status(200).send(buffer);
    } catch (error) {
        console.error("Erro ao exportar para Excel:", error);
        res.status(500).json({ message: "Erro interno ao gerar o arquivo Excel." });
    }
});
app.post('/api/save-data/:tableName', (req, res) => {
    const { tableName } = req.params;
    const dataRows = req.body;
    
    // --- SPRINT 21: Mapeamento de tabelas ---
    const allowedTables = { 
        combustao_movel: 'mobile_combustion_data', 
        combustao_estacionaria: 'stationary_combustion_data', 
        dados_producao_venda: 'production_sales_data', 
        ippu_lubrificantes: 'lubricants_ippu_data', 
        emissoes_fugitivas: 'fugitive_emissions_data', 
        fertilizantes: 'fertilizers_data',
        efluentes_controlados: 'effluents_controlled_data',
        efluentes_domesticos: 'domestic_effluents_data',
        mudanca_uso_solo: 'land_use_change_data',
        solid_waste: 'solid_waste_data',
        electricity_purchase: 'electricity_purchase_data',
        purchased_goods_services: 'purchased_goods_services_data',
        capital_goods: 'capital_goods_data',
        upstream_transport: 'upstream_transport_data',
        business_travel_land: 'business_travel_land_data',
        downstream_transport: 'downstream_transport_data',
        waste_transport: 'waste_transport_data',
        home_office: 'home_office_data',
        air_travel: 'air_travel_data',
        employee_commuting: 'employee_commuting_data',
        energy_generation: 'energy_generation_data',
        planted_forest: 'planted_forest_data',
        conservation_area: 'conservation_area_data'
    };

    if (!allowedTables[tableName]) { return res.status(400).json({ message: "Tipo de tabela inválido." }); }
    if (!dataRows || dataRows.length === 0) { return res.status(400).json({ message: "Nenhum dado para salvar." }); }
    
    const dbTableName = allowedTables[tableName];
    
    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        let errorOccurred = false;
        
        dataRows.forEach(row => {
            if (errorOccurred) return;

            const booleanFields = {
                'controlado_empresa': 'controlado_empresa',
                'fossa_septica_propriedade': 'fossa_septica_propriedade',
                'local_controlado_empresa': 'local_controlado_empresa',
                'informar_cidade_uf': 'informar_cidade_uf',
                'bens_terceiros': 'bens_terceiros',
                'km_reembolsado': 'km_reembolsado',
                'area_plantada': 'area_plantada'
            };
            
            for (const frontEndKey in booleanFields) {
                if (row.hasOwnProperty(frontEndKey)) {
                    let val = row[frontEndKey];
                    if (val && typeof val === 'string') {
                         val = val.trim();
                         if(['sim', 's', 'Sim'].includes(val)) val = 'Sim';
                         else if(['nao', 'n', 'não', 'Não'].includes(val)) val = 'Não';
                    }
                    row[booleanFields[frontEndKey]] = val;
                }
            }

            const sanitizedRow = {};
            
            // --- SPRINT 21: Auto-preencher Descrição para Conservation Area ---
            if (tableName === 'conservation_area') {
                // Combina Bioma e Fitofisionomia para ter uma descrição útil no banco
                row.descricao = `${row.bioma || ''} - ${row.fitofisionomia || ''}`;
            }

            for (const key in row) {
                if (row[key] !== '' && row[key] !== null && row[key] !== undefined) {
                    sanitizedRow[key] = row[key];
                }
            }
            
            if (Object.keys(sanitizedRow).length === 0) return;
            
            const columns = Object.keys(sanitizedRow);
            const placeholders = columns.map(() => '?').join(', ');
            const sql = `INSERT INTO ${dbTableName} (${columns.join(', ')}) VALUES (${placeholders})`;
            const values = Object.values(sanitizedRow);

            db.run(sql, values, (err) => {
                if (err) { console.error("Erro ao inserir linha:", err, "SQL:", sql, "Valores:", values); errorOccurred = true; }
            });
        });

        const operation = errorOccurred ? "ROLLBACK" : "COMMIT";
        db.run(operation, (err) => {
            if (err) { return res.status(500).json({ message: `Erro crítico durante a transação (${operation}).` }); }
            if (errorOccurred) { return res.status(500).json({ message: "Erro ao salvar os dados. A transação foi revertida." }); }
            res.status(201).json({ message: `Dados de "${tableName}" salvos com sucesso!` });
        });
    });
});

// --- ROTAS DE CADASTRO DE FONTES ---
app.get('/api/asset-typologies', (req, res) => {
    const { source_type } = req.query;
    let sql = `
        SELECT 
            T.*, 
            U.name as unit_name,
            C.name as responsible_contact_name 
        FROM asset_typologies T 
        JOIN units U ON T.unit_id = U.id
        LEFT JOIN contacts C ON T.responsible_contact_id = C.id
    `;
    const params = [];
    if (source_type) {
        sql += " WHERE T.source_type = ?";
        params.push(source_type);
    }
    sql += " ORDER BY U.name, T.description";
    
    db.all(sql, params, (err, rows) => {
        if (err) {
            res.status(500).json({ "error": err.message });
            return;
        }
        
        const results = rows.map(row => {
            const fields = JSON.parse(row.asset_fields || '{}');
            return { ...row, asset_fields: fields };
        });
        
        res.json(results);
    });
});
app.post('/api/asset-typologies', (req, res) => {
    const { unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency } = req.body;
    if (!unit_id || !source_type || !description || !asset_fields || !reporting_frequency) { return res.status(400).json({ "error": "Campos obrigatórios faltando." }); }
    const assetFieldsStr = JSON.stringify(asset_fields);
    const contactId = responsible_contact_id || null;

    if (unit_id === 'all') {
        db.all("SELECT id FROM units", [], (err, units) => {
            if (err) return res.status(500).json({ "error": `Erro ao buscar unidades: ${err.message}` });
            if (!units || units.length === 0) return res.status(404).json({ "error": "Nenhuma unidade cadastrada para aplicar a regra." });

            const sql = `INSERT INTO asset_typologies (unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency) VALUES (?, ?, ?, ?, ?, ?)`;
            db.serialize(() => {
                db.run("BEGIN TRANSACTION");
                let errorOccurred = false;
                units.forEach(unit => {
                    if (errorOccurred) return;
                    db.run(sql, [unit.id, source_type, description, assetFieldsStr, contactId, reporting_frequency], function(err) {
                        if (err) { console.error("Erro ao inserir tipologia para unidade " + unit.id, err); errorOccurred = true; }
                    });
                });
                const operation = errorOccurred ? "ROLLBACK" : "COMMIT";
                db.run(operation, (err) => {
                    if (err) return res.status(500).json({ message: `Erro crítico durante a transação (${operation}).` });
                    if (errorOccurred) return res.status(500).json({ message: "Erro ao salvar as fontes. A operação foi revertida." });
                    res.status(201).json({ "message": `Fonte '${description}' criada para ${units.length} unidades com sucesso.` });
                });
            });
        });
    } else {
        const sql = `INSERT INTO asset_typologies (unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency) VALUES (?, ?, ?, ?, ?, ?)`;
        db.run(sql, [unit_id, source_type, description, assetFieldsStr, contactId, reporting_frequency], function(err) {
            if (err) { return res.status(500).json({ "error": err.message }); }
            res.status(201).json({ "id": this.lastID });
        });
    }
});
app.put('/api/asset-typologies/:id', (req, res) => {
    const { unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency } = req.body;
    if (!unit_id || !source_type || !description || !asset_fields || !reporting_frequency) { return res.status(400).json({ "error": "Campos obrigatórios faltando." }); }
    const sql = `UPDATE asset_typologies SET unit_id = ?, source_type = ?, description = ?, asset_fields = ?, responsible_contact_id = ?, reporting_frequency = ? WHERE id = ?`;
    const params = [unit_id, source_type, description, JSON.stringify(asset_fields), responsible_contact_id || null, reporting_frequency, req.params.id];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ changes: this.changes });
    });
});

app.delete('/api/asset-typologies/:id', (req, res) => {
    db.run("DELETE FROM asset_typologies WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

app.get('/api/options', (req, res) => {
    const { field_key } = req.query;
    if (!field_key) { return res.status(400).json({ "error": "O parâmetro 'field_key' é obrigatório." }); }
    
    db.all("SELECT * FROM managed_options WHERE field_key = ? ORDER BY value", [field_key], (err, rows) => {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.json(rows);
    });
});
app.post('/api/options', (req, res) => {
    const { field_key, value } = req.body;
    if (!field_key || !value) { return res.status(400).json({ "error": "Campos 'field_key' e 'value' são obrigatórios." }); }
    
    db.run("INSERT INTO managed_options (field_key, value) VALUES (?, ?)", [field_key, value], function(err) {
        if (err) { 
            console.error("Erro ao inserir em managed_options:", err.message);
            res.status(500).json({ "error": err.message }); 
            return;
        }
        res.status(201).json({ "id": this.lastID });
    });
});
app.delete('/api/options/:id', (req, res) => {
    db.run("DELETE FROM managed_options WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

app.get('/api/intelligent-template/:sourceType', (req, res) => {
    const { sourceType } = req.params;
    const { unitId, year, format } = req.query;
    const schema = validationSchemas[sourceType];
    if (!schema) { return res.status(404).send('Tipo de fonte não encontrado.'); }

    const descriptionKeyMap = { 
        combustao_estacionaria: 'descricao_da_fonte', 
        combustao_movel: 'descricao_fonte', 
        dados_producao_venda: 'produto', 
        ippu_lubrificantes: 'fonte_emissao', 
        emissoes_fugitivas: 'fonte_emissao', 
        fertilizantes: 'tipo_fertilizante',
        efluentes_controlados: 'tratamento_ou_destino',
        mudanca_uso_solo: 'uso_solo_anterior',
        solid_waste: 'destinacao_final',
        electricity_purchase: 'fonte_energia',
        purchased_goods_services: 'descricao_item',
        capital_goods: 'bem_capital',
        upstream_transport: 'insumo_transportado',
        business_travel_land: 'descricao_viagem',
        downstream_transport: 'insumo_transportado',
        waste_transport: 'insumo_transportado',
        home_office: 'regime_trabalho',
        air_travel: 'descricao_viagem',
        employee_commuting: 'descricao_identificadora',
        energy_generation: 'fonte_geracao',
        planted_forest: 'identificacao_area',
        conservation_area: 'bioma' // --- SPRINT 21: Mapeado 'bioma' como chave principal do template ---
    };
    
    const getTypologies = new Promise((resolve, reject) => {
        let sql = `
            SELECT 
                T.*, 
                U.name as unit_name
            FROM asset_typologies T 
            JOIN units U ON T.unit_id = U.id
            WHERE T.source_type = ?
        `;
        const params = [sourceType];
        if (unitId && unitId !== 'all') { sql += " AND T.unit_id = ?"; params.push(unitId); }
        db.all(sql, params, (err, rows) => { if (err) return reject(err); resolve(rows); });
    });

    getTypologies.then((typologies) => {
        const dataForExcel = [];
        const headers = schema.headerDisplayNames;
        const headerKeys = Object.keys(headers);
        const reportYear = year || new Date().getFullYear();
        const mainDescriptionKey = descriptionKeyMap[sourceType];

        typologies.forEach(typo => {
            const frequency = typo.reporting_frequency || 'anual';
            const periods = frequency === 'mensal' ? ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"] : ["Anual"];
            const assetFields = JSON.parse(typo.asset_fields || '{}');
            
            periods.forEach(period => {
                const row = {};
                headerKeys.forEach(key => { row[key] = ''; });

                row['ano'] = reportYear;
                row['periodo'] = period;
                row['unidade_empresarial'] = typo.unit_name;
                
                if (mainDescriptionKey) {
                    if (['solid_waste', 'electricity_purchase'].includes(sourceType)) {
                        row[mainDescriptionKey] = assetFields[mainDescriptionKey] || '';
                    } else if (sourceType === 'energy_generation') {
                        row[mainDescriptionKey] = assetFields.fonte_geracao || typo.description;
                    } else if (sourceType === 'conservation_area') {
                        // SPRINT 21: Para conservation_area, usa 'bioma' da fonte como chave principal
                        row[mainDescriptionKey] = assetFields.bioma || '';
                    } else {
                        row[mainDescriptionKey] = typo.description;
                    }
                }
                
                for (const assetKey in assetFields) { 
                    if (row.hasOwnProperty(assetKey)) { 
                        row[assetKey] = assetFields[assetKey]; 
                    } 
                }
                
                if (sourceType === 'solid_waste' && assetFields.destinacao_final === 'Aterro') {
                    row['informar_cidade_uf'] = assetFields.cidade_uf_destino || '';
                }
                if (sourceType === 'efluentes_controlados') {
                    row['unidade_efluente_liquido'] = frequency === 'mensal' ? 'm3/mês' : 'm3/ano';
                    row['unidade_nitrogenio'] = 'kgN/m3';
                } else if (sourceType === 'emissoes_fugitivas' || sourceType === 'fertilizantes') {
                    row['unidade'] = 'kg';
                } else if (sourceType === 'capital_goods') {
                    row['unidade'] = 'Unidades';
                }
                
                if (schema.autoFillMap) {
                    for (const triggerKey in schema.autoFillMap) {
                        const rule = schema.autoFillMap[triggerKey];
                        const triggerValue = row[triggerKey];
                        if (triggerValue) {
                            const targetValue = rule.map[triggerValue];
                            if (targetValue !== undefined) {
                                row[rule.targetColumn] = targetValue;
                            }
                        }
                    }
                }
                
                dataForExcel.push(row);
            });
        });

        if (format === 'json') {
            return res.json(dataForExcel);
        }
        
        try {
            const dataWithHeaderNames = dataForExcel.map(row => {
                const newRow = {};
                for (const key in row) {
                    if (headers[key]) {
                        newRow[headers[key]] = row[key];
                    }
                }
                return newRow;
            });

            const worksheet = xlsx.utils.json_to_sheet(dataWithHeaderNames, { header: Object.values(headers) });
            worksheet['!cols'] = Object.values(headers).map(header => ({ wch: Math.max(header.length, 15) + 2 }));
            const workbook = xlsx.utils.book_new();
            const sheetName = schema.displayName.substring(0, 31);
            xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
            const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
            const fileName = `${sourceType}_template_preenchido_${year}.xlsx`;
            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', `attachment; filename=${fileName}_template.xlsx`);
            res.status(200).send(buffer);
        } catch (error) {
            console.error("Erro ao gerar o template inteligente:", error);
            res.status(500).json({ message: "Erro interno ao gerar o arquivo Excel." });
        }
    }).catch(err => {
        console.error("Erro ao processar dados para o template:", err);
        res.status(500).json({ message: "Erro interno ao processar a geração do template." });
    });
});

app.listen(PORT, () => {
    console.log(`Servidor iniciado com sucesso na porta ${PORT}`);
});
</file>

</files>

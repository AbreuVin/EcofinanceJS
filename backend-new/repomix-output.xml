This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
dev.db
package.json
prisma.config.ts
prisma/migrations/20260105150207_init/migration.sql
prisma/migrations/20260107233753_init/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
prisma/seed.ts
src/controllers/authController.ts
src/controllers/configController.ts
src/controllers/esgDataController.ts
src/controllers/userController.ts
src/index.ts
src/interfaces/crudDelegate.ts
src/middleware/authMiddleware.ts
src/repositories/configRepository.ts
src/repositories/prisma.ts
src/repositories/userRepository.ts
src/routes/authRoutes.ts
src/routes/esgRoutes.ts
src/routes/userRoutes.ts
src/schemas/esgSchemas.ts
src/schemas/userSchema.ts
src/services/authService.ts
src/services/configService.ts
src/services/esgGenericService.ts
src/services/userService.ts
src/types/auth.ts
src/utils/jwtUtils.ts
src/utils/modelRegistry.ts
src/utils/passwordUtils.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
node_modules
# Keep environment variables out of version control
.env

/generated/prisma
</file>

<file path="package.json">
{
  "name": "backend-new",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc",
    "start": "node dist/index.js",
    "prisma:seed": "ts-node prisma/seed.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@prisma/adapter-better-sqlite3": "^7.2.0",
    "@prisma/client": "^7.2.0",
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.3",
    "zod": "^4.3.5"
  },
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^25.0.3",
    "prisma": "^7.2.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.9.3"
  }
}
</file>

<file path="prisma.config.ts">
// This file was generated by Prisma, and assumes you have installed the following:
// npm install --save-dev prisma dotenv
import "dotenv/config";
import { defineConfig } from "prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: "file:./dev.db",
  },
});
</file>

<file path="prisma/migrations/20260105150207_init/migration.sql">
-- CreateTable
CREATE TABLE "Company" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "cnpj" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "phone" TEXT,
    "role" TEXT NOT NULL DEFAULT 'USER',
    "companyId" TEXT,
    "unitId" INTEGER,
    "parentId" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "User_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "User_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "User_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "User" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "UserPermission" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "userId" TEXT NOT NULL,
    "sourceType" TEXT NOT NULL,
    CONSTRAINT "UserPermission_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Unit" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "city" TEXT NOT NULL,
    "state" TEXT NOT NULL,
    "country" TEXT NOT NULL,
    "numberOfWorkers" INTEGER NOT NULL,
    "companyId" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "Unit_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "Company_name_key" ON "Company"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Company_cnpj_key" ON "Company"("cnpj");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "UserPermission_userId_sourceType_key" ON "UserPermission"("userId", "sourceType");
</file>

<file path="prisma/migrations/20260107233753_init/migration.sql">
-- CreateTable
CREATE TABLE "AssetTypology" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "unitId" INTEGER NOT NULL,
    "sourceType" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "assetFields" TEXT NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "responsibleContactId" INTEGER,
    "reportingFrequency" TEXT NOT NULL DEFAULT 'anual',
    CONSTRAINT "AssetTypology_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ManagedOption" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "fieldKey" TEXT NOT NULL,
    "value" TEXT NOT NULL
);

-- CreateTable
CREATE TABLE "MobileCombustionData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "inputType" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "vehicleType" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "MobileCombustionData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "StationaryCombustionData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "StationaryCombustionData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ProductionSalesData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "product" TEXT NOT NULL,
    "quantitySold" INTEGER NOT NULL,
    "measureUnit" TEXT NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ProductionSalesData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "LubricantsIppuData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "emissionSource" TEXT,
    "lubricantType" TEXT,
    "consumption" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "LubricantsIppuData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "FugitiveEmissionsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "emissionSource" TEXT,
    "gasType" TEXT,
    "quantityReplaced" REAL,
    "unitMeasure" TEXT,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FugitiveEmissionsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "FertilizersData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "fertilizerType" TEXT,
    "quantityKg" REAL,
    "unitMeasure" TEXT,
    "percentNitrogen" REAL,
    "percentCarbonate" REAL,
    "isCompanyControlled" BOOLEAN NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FertilizersData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EffluentsControlledData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "treatmentOrDest" TEXT NOT NULL,
    "treatmentType" TEXT,
    "finalDestType" TEXT,
    "qtyEffluentM3" REAL NOT NULL,
    "unitEffluent" TEXT NOT NULL,
    "qtyOrganic" REAL NOT NULL,
    "unitOrganic" TEXT NOT NULL,
    "qtyNitrogen" REAL NOT NULL,
    "unitNitrogen" TEXT NOT NULL,
    "organicRemovedSludge" REAL,
    "unitSludge" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EffluentsControlledData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "DomesticEffluentsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "workerType" TEXT NOT NULL,
    "numWorkers" INTEGER NOT NULL,
    "avgWorkHours" REAL NOT NULL,
    "septicTankOwner" TEXT NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "DomesticEffluentsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "LandUseChangeData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "prevLandUse" TEXT NOT NULL,
    "biome" TEXT,
    "phytophysiognomy" TEXT,
    "areaType" TEXT,
    "areaHectares" REAL NOT NULL,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "LandUseChangeData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "SolidWasteData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "finalDestination" TEXT,
    "wasteType" TEXT,
    "quantityGenerated" REAL,
    "unitMeasure" TEXT,
    "cityStateDest" TEXT,
    "locationControlled" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "internalTracking" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "SolidWasteData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ElectricityPurchaseData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "energySource" TEXT,
    "specifySource" TEXT,
    "consumption" REAL,
    "measureUnit" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "traceability" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ElectricityPurchaseData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "PurchasedGoodsServicesData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "itemDescription" TEXT,
    "itemType" TEXT,
    "quantity" REAL,
    "unitMeasure" TEXT,
    "acquisitionValue" REAL,
    "thirdPartyGoods" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "PurchasedGoodsServicesData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "CapitalGoodsData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "capitalGood" TEXT,
    "quantity" INTEGER,
    "unitMeasure" TEXT,
    "acquisitionValue" REAL,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "CapitalGoodsData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "UpstreamTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "transportMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "origin" TEXT,
    "destination" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "UpstreamTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "BusinessTravelLandData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "tripDescription" TEXT,
    "travelMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "kmReimbursed" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "BusinessTravelLandData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "DownstreamTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "transportMode" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "origin" TEXT,
    "destination" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "DownstreamTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "WasteTransportData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "transportedItem" TEXT,
    "reportType" TEXT,
    "fuel" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "vehicleClass" TEXT,
    "distance" REAL,
    "distanceUnit" TEXT,
    "transportedLoad" REAL,
    "tripCount" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "WasteTransportData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "HomeOfficeData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "workRegime" TEXT,
    "numEmployees" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "HomeOfficeData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "AirTravelData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "tripDescription" TEXT,
    "airportCodeOrigin" TEXT,
    "airportCodeDest" TEXT,
    "tripCount" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "AirTravelData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EmployeeCommutingData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "identifier" TEXT,
    "methodUsed" TEXT,
    "reportType" TEXT,
    "fuelType" TEXT,
    "consumption" REAL,
    "consumptionUnit" TEXT,
    "distanceKm" REAL,
    "employeeAddress" TEXT,
    "workAddress" TEXT,
    "daysCommuted" INTEGER,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EmployeeCommutingData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "EnergyGenerationData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "sourceDescription" TEXT,
    "generationSource" TEXT,
    "totalGeneration" REAL,
    "measureUnit" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "EnergyGenerationData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "PlantedForestData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "areaId" TEXT,
    "speciesName" TEXT,
    "areaPrePreLast" REAL,
    "agePrePreLast" INTEGER,
    "agePreLast" INTEGER,
    "areaHarvestedPreLast" REAL,
    "currentArea" REAL,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "PlantedForestData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "ConservationAreaData" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "year" INTEGER NOT NULL,
    "period" TEXT NOT NULL,
    "unitId" INTEGER NOT NULL,
    "description" TEXT,
    "biome" TEXT,
    "phytophysiognomy" TEXT,
    "plantedArea" TEXT,
    "plantingStatus" TEXT,
    "areaStartYear" REAL,
    "areaEndYear" REAL,
    "changeReason" TEXT,
    "responsible" TEXT,
    "deptResponsible" TEXT,
    "email" TEXT,
    "phone" TEXT,
    "comments" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "ConservationAreaData_unitId_fkey" FOREIGN KEY ("unitId") REFERENCES "Unit" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "ManagedOption_fieldKey_value_key" ON "ManagedOption"("fieldKey", "value");
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "sqlite"
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
}

model Company {
  id   String  @id @default(uuid())
  name String  @unique
  cnpj String? @unique

  // Relations
  users User[]
  units Unit[]

  createdAt DateTime @default(now())
}

model User {
  id       String  @id @default(uuid())
  email    String  @unique
  password String
  name     String // Moved from Contact
  phone    String? // Moved from Contact
  role     String  @default("USER") // MASTER, ADMIN, USER

  // Multi-tenancy
  companyId String?
  company   Company? @relation(fields: [companyId], references: [id])

  // Unit Assignment: A user now "belongs" to a unit (optional for MASTER/ADMIN)
  unitId Int?
  unit   Unit? @relation(fields: [unitId], references: [id])

  // Hierarchy
  parentId String?
  parent   User?   @relation("UserHierarchy", fields: [parentId], references: [id])
  children User[]  @relation("UserHierarchy")

  // Permissions: These define which Spreadsheets (SourceTypes) the user manages
  permissions UserPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserPermission {
  id         String @id @default(uuid())
  userId     String
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  sourceType String // e.g., "combustao_movel", "solid_waste"

  @@unique([userId, sourceType])
}

model Unit {
  id              Int    @id @default(autoincrement())
  name            String
  city            String
  state           String
  country         String
  numberOfWorkers Int

  // Multi-tenancy
  companyId String
  company   Company @relation(fields: [companyId], references: [id])

  // Users belonging to this unit
  users User[]

  createdAt                   DateTime                     @default(now())
  assetTypologies             AssetTypology[]
  mobileCombustionDatas       MobileCombustionData[]
  stationaryCombustionDatas   StationaryCombustionData[]
  productionSalesDatas        ProductionSalesData[]
  lubricantsIppuDatas         LubricantsIppuData[]
  fugitiveEmissionsDatas      FugitiveEmissionsData[]
  fertilizersDatas            FertilizersData[]
  effluentsControlledDatas    EffluentsControlledData[]
  domesticEffluentsDatas      DomesticEffluentsData[]
  landUseChangeDatas          LandUseChangeData[]
  solidWasteDatas             SolidWasteData[]
  electricityPurchaseDatas    ElectricityPurchaseData[]
  purchasedGoodsServicesDatas PurchasedGoodsServicesData[]
  capitalGoodsDatas           CapitalGoodsData[]
  upstreamTransportDatas      UpstreamTransportData[]
  businessTravelLandDatas     BusinessTravelLandData[]
  downstreamTransportDatas    DownstreamTransportData[]
  wasteTransportDatas         WasteTransportData[]
  homeOfficeDatas             HomeOfficeData[]
  airTravelDatas              AirTravelData[]
  employeeCommutingDatas      EmployeeCommutingData[]
  energyGenerationDatas       EnergyGenerationData[]
  plantedForestDatas          PlantedForestData[]
  conservationAreaDatas       ConservationAreaData[]
}

// --- CONFIGURATION & METADATA ---

model AssetTypology {
  id                   Int     @id @default(autoincrement())
  unitId               Int
  unit                 Unit    @relation(fields: [unitId], references: [id], onDelete: Cascade)
  sourceType           String
  description          String
  assetFields          String // JSON string
  isActive             Boolean @default(true)
  responsibleContactId Int?
  reportingFrequency   String  @default("anual")
}

model ManagedOption {
  id       Int    @id @default(autoincrement())
  fieldKey String
  value    String

  @@unique([fieldKey, value])
}

// --- ESG DATA TABLES ---

// 1. Mobile Combustion
model MobileCombustionData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription   String?
  isCompanyControlled Boolean
  inputType           String? // 'consumo' or 'distancia'
  fuelType            String?
  consumption         Float?
  consumptionUnit     String?
  distance            Float?
  distanceUnit        String?
  vehicleType         String?

  comments  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 2. Stationary Combustion
model StationaryCombustionData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription   String?
  fuelType            String?
  consumption         Float?
  unitMeasure         String? // Renamed from 'unit' to avoid conflict with relation
  isCompanyControlled Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 3. Production & Sales
model ProductionSalesData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  product      String
  quantitySold Int
  measureUnit  String
  comments     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 4. Lubricants & IPPU
model LubricantsIppuData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  emissionSource      String?
  lubricantType       String?
  consumption         Float?
  unitMeasure         String?
  isCompanyControlled Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 5. Fugitive Emissions
model FugitiveEmissionsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  emissionSource      String?
  gasType             String?
  quantityReplaced    Float?
  unitMeasure         String?
  isCompanyControlled Boolean
  comments            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 6. Fertilizers
model FertilizersData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  fertilizerType      String?
  quantityKg          Float?
  unitMeasure         String?
  percentNitrogen     Float?
  percentCarbonate    Float?
  isCompanyControlled Boolean
  comments            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 7. Controlled Effluents
model EffluentsControlledData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  treatmentOrDest String
  treatmentType   String?
  finalDestType   String?

  qtyEffluentM3 Float
  unitEffluent  String

  qtyOrganic  Float
  unitOrganic String

  qtyNitrogen  Float
  unitNitrogen String

  organicRemovedSludge Float?
  unitSludge           String?

  comments String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 8. Domestic Effluents
model DomesticEffluentsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  workerType      String
  numWorkers      Int
  avgWorkHours    Float
  septicTankOwner String
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 9. Land Use Change
model LandUseChangeData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  prevLandUse      String
  biome            String?
  phytophysiognomy String?
  areaType         String?
  areaHectares     Float
  comments         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 10. Solid Waste
model SolidWasteData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  finalDestination   String?
  wasteType          String?
  quantityGenerated  Float?
  unitMeasure        String?
  cityStateDest      String?
  locationControlled String?

  responsible      String?
  deptResponsible  String?
  email            String?
  phone            String?
  internalTracking String?
  comments         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 11. Electricity Purchase
model ElectricityPurchaseData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  energySource  String?
  specifySource String?
  consumption   Float?
  measureUnit   String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  traceability    String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 12. Purchased Goods & Services
model PurchasedGoodsServicesData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  itemDescription  String?
  itemType         String?
  quantity         Float?
  unitMeasure      String?
  acquisitionValue Float?
  thirdPartyGoods  String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 13. Capital Goods
model CapitalGoodsData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  capitalGood      String?
  quantity         Int?
  unitMeasure      String?
  acquisitionValue Float?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 14. Upstream Transport
model UpstreamTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  transportMode   String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?
  origin          String?
  destination     String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 15. Business Travel (Land)
model BusinessTravelLandData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  tripDescription String?
  travelMode      String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  distance        Float?
  distanceUnit    String?
  kmReimbursed    String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 16. Downstream Transport
model DownstreamTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  transportMode   String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?
  origin          String?
  destination     String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 17. Waste Transport
model WasteTransportData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  transportedItem String?
  reportType      String?
  fuel            String?
  consumption     Float?
  consumptionUnit String?
  vehicleClass    String?
  distance        Float?
  distanceUnit    String?
  transportedLoad Float?
  tripCount       Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 18. Home Office
model HomeOfficeData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  workRegime   String?
  numEmployees Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 19. Air Travel
model AirTravelData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  tripDescription   String?
  airportCodeOrigin String?
  airportCodeDest   String?
  tripCount         Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 20. Employee Commuting
model EmployeeCommutingData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  identifier      String?
  methodUsed      String?
  reportType      String?
  fuelType        String?
  consumption     Float?
  consumptionUnit String?
  distanceKm      Float?
  employeeAddress String?
  workAddress     String?
  daysCommuted    Int?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 21. Energy Generation
model EnergyGenerationData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  sourceDescription String?
  generationSource  String?
  totalGeneration   Float?
  measureUnit       String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 22. Planted Forest
model PlantedForestData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  areaId      String?
  speciesName String?

  areaPrePreLast       Float?
  agePrePreLast        Int?
  agePreLast           Int?
  areaHarvestedPreLast Float?
  currentArea          Float?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 23. Conservation Area
model ConservationAreaData {
  id     Int    @id @default(autoincrement())
  year   Int
  period String
  unitId Int
  unit   Unit   @relation(fields: [unitId], references: [id])

  description      String?
  biome            String?
  phytophysiognomy String?

  plantedArea    String?
  plantingStatus String?
  areaStartYear  Float?
  areaEndYear    Float?
  changeReason   String?

  responsible     String?
  deptResponsible String?
  email           String?
  phone           String?
  comments        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
</file>

<file path="prisma/seed.ts">
import * as bcrypt from 'bcrypt'
import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";
import { PrismaClient } from "../generated/prisma";

const adapter = new PrismaBetterSqlite3({
    url: "file:./dev.db"
})

const prisma = new PrismaClient({ adapter });

async function main() {
    await prisma.assetTypology.deleteMany();
    await prisma.unit.deleteMany();
    await prisma.company.deleteMany();

    const masterPass = await bcrypt.hash('master123', 10)
    await prisma.user.upsert({
        where: { email: 'master@ecofinance.com' },
        update: {},
        create: {
            email: 'master@ecofinance.com',
            password: masterPass,
            name: 'System Master',
            role: 'MASTER'
        },
    });
    console.log('Seed: MASTER user created.');

    const company = await prisma.company.upsert({
        where: { name: 'EcoFinance Demo Corp' },
        update: {},
        create: {
            name: 'EcoFinance Demo Corp',
            cnpj: '12.345.678/0001-90'
        }
    });
    console.log('Seed: Company ensured.');

    const unit = await prisma.unit.upsert({
        where: { id: 1 },
        update: {},
        create: {
            name: 'Sao Paulo HQ',
            city: 'Sao Paulo',
            state: 'SP',
            country: 'Brasil',
            numberOfWorkers: 150,
            companyId: company.id
        }
    });
    console.log(`Seed: Unit ensured with ID: ${unit.id}`);
}

main().catch(e => console.error(e)).finally(() => prisma.$disconnect());
</file>

<file path="src/controllers/authController.ts">
import { Request, Response } from 'express';
import * as authService from '../services/authService';

export const handleLogin = async (req: Request, res: Response) => {
    try {
        const token = await authService.login(req.body.email, req.body.password);
        res.json({ token });
    } catch (error: any) {
        res.status(401).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/configController.ts">
import { Request, Response } from 'express';
import * as configService from '../services/configService';

// --- ASSET TYPOLOGIES ---

export const getTypologies = async (req: Request, res: Response) => {
    try {
        const { unitId, sourceType } = req.query;

        const data = await configService.getTypologies(
            unitId ? Number(unitId) : undefined,
            sourceType ? String(sourceType) : undefined
        );

        res.json(data);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
};

export const createTypology = async (req: Request, res: Response) => {
    try {
        const result = await configService.createTypology(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        // Distinguish Zod validation errors from Server errors
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};

export const deleteTypology = async (req: Request, res: Response) => {
    try {
        const id = Number(req.params.id);
        if (isNaN(id)) return res.status(400).json({ error: "Invalid ID" });

        await configService.deleteTypology(id);
        res.status(204).send();
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

// --- MANAGED OPTIONS ---

export const getOptions = async (req: Request, res: Response) => {
    try {
        const { fieldKey } = req.query;
        if (!fieldKey) return res.status(400).json({ error: "fieldKey required" });

        const options = await configService.getOptions(String(fieldKey));
        res.json(options);
    } catch (err: any) {
        res.status(500).json({ error: err.message });
    }
};

export const createOption = async (req: Request, res: Response) => {
    try {
        const result = await configService.createOption(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};
</file>

<file path="src/controllers/esgDataController.ts">
import { Request, Response } from 'express';
import { getServiceOrThrow } from '../utils/modelRegistry';

export const getByUnit = async (req: Request, res: Response) => {
    try {
        const { sourceType } = req.params;
        const { unitId, year } = req.query;

        if (!unitId) return res.status(400).json({ error: "unitId is required" });

        const service = getServiceOrThrow(sourceType);
        const data = await service.getByUnitAndYear(Number(unitId), year ? Number(year) : undefined);

        res.json(data);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

export const createEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType } = req.params;
        const service = getServiceOrThrow(sourceType);

        const result = await service.create(req.body);
        res.status(201).json(result);
    } catch (err: any) {
        // Zod validation error handling
        if (err.errors) {
            return res.status(400).json({ error: "Validation failed", details: err.errors });
        }
        res.status(400).json({ error: err.message });
    }
};

export const updateEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType, id } = req.params;
        const service = getServiceOrThrow(sourceType);

        const result = await service.update(Number(id), req.body);
        res.json(result);
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};

export const deleteEntry = async (req: Request, res: Response) => {
    try {
        const { sourceType, id } = req.params;
        const service = getServiceOrThrow(sourceType);

        await service.delete(Number(id));
        res.status(204).send();
    } catch (err: any) {
        res.status(400).json({ error: err.message });
    }
};
</file>

<file path="src/controllers/userController.ts">
import { Request, Response } from 'express';
import * as userService from '../services/userService';
import { createUserSchema } from "../schemas/userSchema";

export const createUser = async (req: Request, res: Response) => {
    try {
        const validatedData = createUserSchema.parse(req.body);

        const newUser = await userService.registerUser(validatedData, req.user);

        const { password, ...safeUser } = newUser;
        res.status(201).json(safeUser);
    } catch (error: any) {
        if (error.name === 'ZodError') {
            return res.status(400).json({ errors: error.errors });
        }

        res.status(400).json({ error: error.message });
    }
};
</file>

<file path="src/index.ts">
import express from 'express';
import cors from 'cors';
import * as dotenv from 'dotenv';

import authRoutes from './routes/authRoutes';
import userRoutes from './routes/userRoutes';
import esgRoutes from './routes/esgRoutes';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/esg', esgRoutes);

app.get('/health', (req, res) => res.json({ status: 'OK' }));

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});
</file>

<file path="src/interfaces/crudDelegate.ts">
export interface CrudDelegate<T> {
    findMany(args?: any): Promise<T[]>;

    findUnique(args: any): Promise<T | null>;

    create(args: { data: any }): Promise<T>;

    update(args: { where: any; data: any }): Promise<T>;

    delete(args: { where: any }): Promise<T>;

    count(args?: any): Promise<number>;
}
</file>

<file path="src/middleware/authMiddleware.ts">
import { NextFunction, Request, Response } from 'express';
import * as jwt from 'jsonwebtoken';
import { AppJwtPayload } from "../types/auth";

declare global {
    namespace Express {
        interface Request {
            user?: AppJwtPayload; // Make optional, populated only after auth
        }
    }
}

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers.authorization;

    if (!authHeader?.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'No token provided or invalid format' });
    }

    const token = authHeader.split(' ')[1];

    if (!token) return res.status(401).json({ error: 'No token provided' });

    try {
        req.user = jwt.verify(token, process.env.JWT_SECRET!) as AppJwtPayload;
        next();
    } catch (err) {
        res.status(401).json({ error: 'Invalid token' });
    }
};
</file>

<file path="src/repositories/configRepository.ts">
import prisma from './prisma';
import { Prisma } from "../../generated/prisma";

export const findTypologies = async (filters: { unitId?: number; sourceType?: string }) => {
    const where: Prisma.AssetTypologyWhereInput = {};
    if (filters.unitId) where.unitId = filters.unitId;
    if (filters.sourceType) where.sourceType = filters.sourceType;

    return prisma.assetTypology.findMany({
        where,
        orderBy: { description: 'asc' }
    });
};

export const createTypology = async (data: Prisma.AssetTypologyCreateInput) => {
    return prisma.assetTypology.create({ data });
};

export const deleteTypology = async (id: number) => {
    return prisma.assetTypology.delete({
        where: { id }
    });
};

export const findOptions = async (fieldKey: string) => {
    return prisma.managedOption.findMany({
        where: { fieldKey },
        orderBy: { value: 'asc' }
    });
};

export const createOption = async (data: Prisma.ManagedOptionCreateInput) => {
    return prisma.managedOption.create({ data });
};
</file>

<file path="src/repositories/prisma.ts">
import { PrismaClient } from "../../generated/prisma";
import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";

const adapter = new PrismaBetterSqlite3({
    url: "file:./dev.db"
})

const prisma = new PrismaClient({ adapter });

export default prisma;
</file>

<file path="src/repositories/userRepository.ts">
import prisma from "./prisma";
import { CreateUserDTO } from "../schemas/userSchema";

export const create = async (userData: CreateUserDTO) => {
    return prisma.user.create({
        data: {
            email: userData.email,
            password: userData.password,
            name: userData.name,
            role: userData.role,
            companyId: userData.companyId,
            unitId: userData.unitId,
            parentId: userData.parentId,
        }
    })
}

export const findByEmail = async (email: string) => {
    return prisma.user.findUnique({
        where: { email },
        include: { company: true }
    })
}
</file>

<file path="src/routes/authRoutes.ts">
import { Router } from "express";
import * as authController from "../controllers/authController";

const router = Router()

router.post("/login", authController.handleLogin)

export default router
</file>

<file path="src/routes/esgRoutes.ts">
import { Router } from 'express';
import { authenticate } from '../middleware/authMiddleware';
import * as esgController from '../controllers/esgDataController';
import * as configController from '../controllers/configController';

const router = Router();

// --- Configuration Routes ---
router.get('/config/typologies', authenticate, configController.getTypologies);
router.post('/config/typologies', authenticate, configController.createTypology);
router.delete('/config/typologies/:id', authenticate, configController.deleteTypology);

router.get('/config/options', authenticate, configController.getOptions);
router.post('/config/options', authenticate, configController.createOption);

// --- Generic ESG Data Routes ---
// :sourceType matches the keys in esgRegistry (e.g., "mobile_combustion")
router.get('/data/:sourceType', authenticate, esgController.getByUnit);
router.post('/data/:sourceType', authenticate, esgController.createEntry);
router.put('/data/:sourceType/:id', authenticate, esgController.updateEntry);
router.delete('/data/:sourceType/:id', authenticate, esgController.deleteEntry);

export default router;
</file>

<file path="src/routes/userRoutes.ts">
import { Router } from "express";
import * as userController from '../controllers/userController';
import { authenticate } from "../middleware/authMiddleware";

const router = Router()

router.post("/create-user", authenticate, userController.createUser)

export default router
</file>

<file path="src/schemas/esgSchemas.ts">
import { z } from 'zod';

// --- 1. SHARED PATTERNS (DRY Principle) ---

// Base schema for almost all ESG data tables
const baseEsgSchema = z.object({
    year: z.number().int().min(2000).max(2100),
    period: z.string().min(1, "Period is required"), // e.g., "Janeiro" or "Annual"
    unitId: z.number().int().positive("Unit ID is required"),
    comments: z.string().optional(),
});

// Helper for nullable floats (common in ESG data)
const nullableFloat = z.number().optional().nullable();
const nullableString = z.string().optional().nullable();
const nullableInt = z.number().int().optional().nullable();

// --- 2. CONFIGURATION SCHEMAS ---

export const managedOptionSchema = z.object({
    fieldKey: z.string().min(1),
    value: z.string().min(1),
});

export const assetTypologySchema = z.object({
    unitId: z.number().int().positive(),
    sourceType: z.string().min(1),
    description: z.string().min(1),
    // DX Improvement: Accept object, transform to string for DB
    assetFields: z.record(z.string(), z.any()).transform((val) => JSON.stringify(val)),
    isActive: z.boolean().default(true),
    responsibleContactId: z.number().int().optional().nullable(),
    reportingFrequency: z.enum(['mensal', 'anual']).default('anual'),
});

// --- 3. DATA TABLES (Combustion & Energy) ---

export const mobileCombustionSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    isCompanyControlled: z.boolean(),
    inputType: z.enum(['consumo', 'distancia']).optional().nullable(),
    fuelType: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    vehicleType: nullableString,
});

export const stationaryCombustionSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    fuelType: nullableString,
    consumption: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const electricityPurchaseSchema = baseEsgSchema.extend({
    energySource: nullableString,
    specifySource: nullableString,
    consumption: nullableFloat,
    measureUnit: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
    traceability: nullableString,
});

export const energyGenerationSchema = baseEsgSchema.extend({
    sourceDescription: nullableString,
    generationSource: nullableString,
    totalGeneration: nullableFloat,
    measureUnit: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 4. DATA TABLES (Logistics & Transport) ---

// Base for transport since they share many fields
const baseTransportSchema = baseEsgSchema.extend({
    transportedItem: nullableString,
    reportType: nullableString,
    fuel: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    vehicleClass: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    transportedLoad: nullableFloat,
    tripCount: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const upstreamTransportSchema = baseTransportSchema.extend({
    transportMode: nullableString,
    origin: nullableString,
    destination: nullableString,
});

export const downstreamTransportSchema = baseTransportSchema.extend({
    transportMode: nullableString,
    origin: nullableString,
    destination: nullableString,
});

export const wasteTransportSchema = baseTransportSchema; // Matches base exactly

export const businessTravelLandSchema = baseEsgSchema.extend({
    tripDescription: nullableString,
    travelMode: nullableString,
    reportType: nullableString,
    fuel: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distance: nullableFloat,
    distanceUnit: nullableString,
    kmReimbursed: nullableString, // Boolean-ish string in legacy, keep flexible or strict?
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const airTravelSchema = baseEsgSchema.extend({
    tripDescription: nullableString,
    airportCodeOrigin: nullableString.refine(v => !v || v.length === 3, "Airport code must be 3 letters"),
    airportCodeDest: nullableString.refine(v => !v || v.length === 3, "Airport code must be 3 letters"),
    tripCount: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const employeeCommutingSchema = baseEsgSchema.extend({
    identifier: nullableString,
    methodUsed: nullableString,
    reportType: nullableString,
    fuelType: nullableString,
    consumption: nullableFloat,
    consumptionUnit: nullableString,
    distanceKm: nullableFloat,
    employeeAddress: nullableString,
    workAddress: nullableString,
    daysCommuted: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 5. DATA TABLES (Production & Materials) ---

export const productionSalesSchema = baseEsgSchema.extend({
    product: z.string().min(1),
    quantitySold: z.number().int(),
    measureUnit: z.string().min(1),
});

export const purchasedGoodsServicesSchema = baseEsgSchema.extend({
    itemDescription: nullableString,
    itemType: nullableString,
    quantity: nullableFloat,
    unitMeasure: nullableString,
    acquisitionValue: nullableFloat,
    thirdPartyGoods: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const capitalGoodsSchema = baseEsgSchema.extend({
    capitalGood: nullableString,
    quantity: nullableInt,
    unitMeasure: nullableString,
    acquisitionValue: nullableFloat,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- 6. DATA TABLES (Emissions & Waste) ---

export const lubricantsIppuSchema = baseEsgSchema.extend({
    emissionSource: nullableString,
    lubricantType: nullableString,
    consumption: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const fugitiveEmissionsSchema = baseEsgSchema.extend({
    emissionSource: nullableString,
    gasType: nullableString,
    quantityReplaced: nullableFloat,
    unitMeasure: nullableString,
    isCompanyControlled: z.boolean(),
});

export const fertilizersSchema = baseEsgSchema.extend({
    fertilizerType: nullableString,
    quantityKg: nullableFloat,
    unitMeasure: nullableString,
    percentNitrogen: nullableFloat.refine(val => !val || (val >= 0 && val <= 100), "Percentage must be 0-100"),
    percentCarbonate: nullableFloat.refine(val => !val || (val >= 0 && val <= 100), "Percentage must be 0-100"),
    isCompanyControlled: z.boolean(),
});

export const solidWasteSchema = baseEsgSchema.extend({
    finalDestination: nullableString,
    wasteType: nullableString,
    quantityGenerated: nullableFloat,
    unitMeasure: nullableString,
    cityStateDest: nullableString,
    locationControlled: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
    internalTracking: nullableString,
});

export const effluentsControlledSchema = baseEsgSchema.extend({
    treatmentOrDest: z.string().min(1),
    treatmentType: nullableString,
    finalDestType: nullableString,
    qtyEffluentM3: z.number(),
    unitEffluent: z.string(),
    qtyOrganic: z.number(),
    unitOrganic: z.string(),
    qtyNitrogen: z.number(),
    unitNitrogen: z.string(),
    organicRemovedSludge: nullableFloat,
    unitSludge: nullableString,
});

export const domesticEffluentsSchema = baseEsgSchema.extend({
    workerType: z.string().min(1),
    numWorkers: z.number().int(),
    avgWorkHours: z.number(),
    septicTankOwner: z.string(), // "Sim", "No" or specific owner
});

// --- 7. DATA TABLES (Land Use & Forestry) ---

export const landUseChangeSchema = baseEsgSchema.extend({
    prevLandUse: z.string().min(1),
    biome: nullableString,
    phytophysiognomy: nullableString,
    areaType: nullableString,
    areaHectares: z.number(),
});

export const plantedForestSchema = baseEsgSchema.extend({
    areaId: nullableString,
    speciesName: nullableString,
    areaPrePreLast: nullableFloat,
    agePrePreLast: nullableInt,
    agePreLast: nullableInt,
    areaHarvestedPreLast: nullableFloat,
    currentArea: nullableFloat,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const conservationAreaSchema = baseEsgSchema.extend({
    description: nullableString,
    biome: nullableString,
    phytophysiognomy: nullableString,
    plantedArea: nullableString,
    plantingStatus: nullableString,
    areaStartYear: nullableFloat,
    areaEndYear: nullableFloat,
    changeReason: nullableString,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

export const homeOfficeSchema = baseEsgSchema.extend({
    workRegime: nullableString,
    numEmployees: nullableInt,
    responsible: nullableString,
    deptResponsible: nullableString,
    email: z.string().email().optional().nullable(),
    phone: nullableString,
});

// --- TYPES EXPORT ---
// Example usage: type MobileCombustionInput = z.infer<typeof mobileCombustionSchema>;
</file>

<file path="src/schemas/userSchema.ts">
import { z } from 'zod';

// Define the schema strictly
export const createUserSchema = z.object({
    email: z.string().email(),
    password: z.string().min(8, "Password must be at least 8 characters"),
    name: z.string().min(2),
    role: z.enum(['MASTER', 'ADMIN', 'USER']).default('USER'),
    companyId: z.string().uuid().nullable().optional(),
    unitId: z.number().int().nullable().optional(),
    parentId: z.string().nullable().optional(),
});

// Infer the DTO type from the schema (Single Source of Truth)
export type CreateUserDTO = z.infer<typeof createUserSchema>;
</file>

<file path="src/services/authService.ts">
import * as userRepository from '../repositories/userRepository';
import { comparePassword } from '../utils/passwordUtils';
import { generateToken } from '../utils/jwtUtils';

export const login = async (email: string, pass: string) => {
    const user = await userRepository.findByEmail(email);
    if (!user || !(await comparePassword(pass, user.password))) throw new Error('Invalid credentials');
    return generateToken({ id: user.id, role: user.role, companyId: user.companyId });
};
</file>

<file path="src/services/configService.ts">
import * as configRepo from '../repositories/configRepository';
import { assetTypologySchema, managedOptionSchema } from '../schemas/esgSchemas';

// --- ASSET TYPOLOGIES ---

export const getTypologies = async (unitId?: number, sourceType?: string) => {
    return configRepo.findTypologies({ unitId, sourceType });
};

export const createTypology = async (rawData: unknown) => {
    // Zod handles validation AND the transformation of assetFields object -> JSON string
    const cleanData = assetTypologySchema.parse(rawData);

    // Type casting needed here because Zod output structure matches DB expectation
    // but Typescript might need a nudge to match Prisma generated types exactly
    return configRepo.createTypology(cleanData as any);
};

export const deleteTypology = async (id: number) => {
    return configRepo.deleteTypology(id);
};

// --- MANAGED OPTIONS ---

export const getOptions = async (fieldKey: string) => {
    return configRepo.findOptions(fieldKey);
};

export const createOption = async (rawData: unknown) => {
    const cleanData = managedOptionSchema.parse(rawData);
    return configRepo.createOption(cleanData as any);
};
</file>

<file path="src/services/esgGenericService.ts">
import { CrudDelegate } from "../interfaces/curdDelegate";
import { ZodObject } from "zod";
import { AppJwtPayload } from "../types/auth";

export class EsgGenericService<T> {
    constructor(
        private delegate: CrudDelegate<T>,
        private schema: ZodObject<any, any>
    ) {}

    async getByUnitAndYear(unitId: number, year?: number) {
        const where: any = { unitId };
        if (year) where.year = year;
        return this.delegate.findMany({ where, orderBy: { createdAt: 'desc' } });
    }

    async create(data: any) {
        const cleanData = this.schema.parse(data);

        return this.delegate.create({
            data: cleanData
        });
    }

    async update(id: number, data: any) {
        const cleanData = this.schema.partial().parse(data); // Allow partial updates
        return this.delegate.update({
            where: { id },
            data: cleanData
        });
    }

    async delete(id: number) {
        return this.delegate.delete({
            where: { id }
        });
    }
}
</file>

<file path="src/services/userService.ts">
import { CreateUserDTO, UserPayload } from "../types/user";
import * as userRepository from "../repositories/userRepository";
import { hashPassword } from "../utils/passwordUtils";

export const registerUser = async (userData: CreateUserDTO, currentUser: UserPayload) => {
    const exists = await userRepository.findByEmail(userData.email);
    if (exists) throw new Error('User already exists');

    const companyId = currentUser.role === 'ADMIN' ? currentUser.companyId : userData.companyId;
    const hashedPassword = await hashPassword(userData.password);

    return userRepository.create({
        ...userData,
        password: hashedPassword,
        companyId,
        parentId: currentUser.id
    });
}
</file>

<file path="src/types/auth.ts">
import { JwtPayload } from "jsonwebtoken";

export interface AppJwtPayload extends JwtPayload {
    id: string;
    role: string;
    companyId: string | null;
}
</file>

<file path="src/utils/jwtUtils.ts">
import * as jwt from 'jsonwebtoken';
import * as dotenv from 'dotenv';

dotenv.config();

const JWT_SECRET = process.env.JWT_SECRET || 'super-secret';

export const generateToken = (payload: object) => jwt.sign(payload, JWT_SECRET, { expiresIn: '8h' });
</file>

<file path="src/utils/modelRegistry.ts">
import prisma from "../repositories/prisma";
import * as schemas from "../schemas/esgSchemas";
import { EsgGenericService } from "../services/esgGenericService";

// Helper type to define the map structure
type RegistryEntry = {
    service: EsgGenericService<any>;
    name: string; // Display name
};

// Singleton map
export const esgRegistry: Record<string, RegistryEntry> = {
    // --- Combustion & Energy ---
    'mobile_combustion': {
        service: new EsgGenericService(prisma.mobileCombustionData, schemas.mobileCombustionSchema),
        name: 'Mobile Combustion'
    },
    'stationary_combustion': {
        service: new EsgGenericService(prisma.stationaryCombustionData, schemas.stationaryCombustionSchema),
        name: 'Stationary Combustion'
    },
    'electricity_purchase': {
        service: new EsgGenericService(prisma.electricityPurchaseData, schemas.electricityPurchaseSchema),
        name: 'Electricity Purchase'
    },
    'energy_generation': {
        service: new EsgGenericService(prisma.energyGenerationData, schemas.energyGenerationSchema),
        name: 'Energy Generation'
    },

    // --- Transport ---
    'upstream_transport': {
        service: new EsgGenericService(prisma.upstreamTransportData, schemas.upstreamTransportSchema),
        name: 'Upstream Transport'
    },
    'downstream_transport': {
        service: new EsgGenericService(prisma.downstreamTransportData, schemas.downstreamTransportSchema),
        name: 'Downstream Transport'
    },
    'waste_transport': {
        service: new EsgGenericService(prisma.wasteTransportData, schemas.wasteTransportSchema),
        name: 'Waste Transport'
    },
    'business_travel_land': {
        service: new EsgGenericService(prisma.businessTravelLandData, schemas.businessTravelLandSchema),
        name: 'Business Travel (Land)'
    },
    'air_travel': {
        service: new EsgGenericService(prisma.airTravelData, schemas.airTravelSchema),
        name: 'Air Travel'
    },
    'employee_commuting': {
        service: new EsgGenericService(prisma.employeeCommutingData, schemas.employeeCommutingSchema),
        name: 'Employee Commuting'
    },

    // --- Production & Materials ---
    'production_sales': {
        service: new EsgGenericService(prisma.productionSalesData, schemas.productionSalesSchema),
        name: 'Production & Sales'
    },
    'purchased_goods': {
        service: new EsgGenericService(prisma.purchasedGoodsServicesData, schemas.purchasedGoodsServicesSchema),
        name: 'Purchased Goods'
    },
    'capital_goods': {
        service: new EsgGenericService(prisma.capitalGoodsData, schemas.capitalGoodsSchema),
        name: 'Capital Goods'
    },

    // --- Emissions & Waste ---
    'lubricants_ippu': {
        service: new EsgGenericService(prisma.lubricantsIppuData, schemas.lubricantsIppuSchema),
        name: 'Lubricants & IPPU'
    },
    'fugitive_emissions': {
        service: new EsgGenericService(prisma.fugitiveEmissionsData, schemas.fugitiveEmissionsSchema),
        name: 'Fugitive Emissions'
    },
    'fertilizers': {
        service: new EsgGenericService(prisma.fertilizersData, schemas.fertilizersSchema),
        name: 'Fertilizers'
    },
    'solid_waste': {
        service: new EsgGenericService(prisma.solidWasteData, schemas.solidWasteSchema),
        name: 'Solid Waste'
    },
    'effluents_controlled': {
        service: new EsgGenericService(prisma.effluentsControlledData, schemas.effluentsControlledSchema),
        name: 'Controlled Effluents'
    },
    'domestic_effluents': {
        service: new EsgGenericService(prisma.domesticEffluentsData, schemas.domesticEffluentsSchema),
        name: 'Domestic Effluents'
    },

    // --- Land & Forest ---
    'land_use_change': {
        service: new EsgGenericService(prisma.landUseChangeData, schemas.landUseChangeSchema),
        name: 'Land Use Change'
    },
    'planted_forest': {
        service: new EsgGenericService(prisma.plantedForestData, schemas.plantedForestSchema),
        name: 'Planted Forest'
    },
    'conservation_area': {
        service: new EsgGenericService(prisma.conservationAreaData, schemas.conservationAreaSchema),
        name: 'Conservation Area'
    },
    'home_office': {
        service: new EsgGenericService(prisma.homeOfficeData, schemas.homeOfficeSchema),
        name: 'Home Office'
    }
};

export const getServiceOrThrow = (sourceType: string) => {
    const entry = esgRegistry[sourceType];
    if (!entry) throw new Error(`Invalid source type: ${sourceType}`);
    return entry.service;
};
</file>

<file path="src/utils/passwordUtils.ts">
import * as bcrypt from 'bcrypt';

const SALT_ROUNDS = 10; // Standard balance between security and performance

export const hashPassword = async (password: string): Promise<string> => {
    return bcrypt.hash(password, SALT_ROUNDS);
};

export const comparePassword = async (password: string, hash: string): Promise<boolean> => {
    return bcrypt.compare(password, hash);
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "strict": true,
    "typeRoots": ["./node_modules/@types", "./src/types"]
  },
  "include": ["src/**/*"]
}
</file>

</files>

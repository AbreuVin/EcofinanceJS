import { r as __toESM, t as __commonJS } from "./chunk-DUEDWNxO.js";
import { t as require_react } from "./react-x9Y-BYRK.js";

//#region node_modules/regexparam/dist/index.mjs
/**
* @param {string|RegExp} input The route pattern
* @param {boolean} [loose] Allow open-ended matching. Ignored with `RegExp` input.
*/
function parse(input, loose) {
	if (input instanceof RegExp) return {
		keys: false,
		pattern: input
	};
	var c, o, tmp, ext, keys = [], pattern = "", arr = input.split("/");
	arr[0] || arr.shift();
	while (tmp = arr.shift()) {
		c = tmp[0];
		if (c === "*") {
			keys.push(c);
			pattern += tmp[1] === "?" ? "(?:/(.*))?" : "/(.*)";
		} else if (c === ":") {
			o = tmp.indexOf("?", 1);
			ext = tmp.indexOf(".", 1);
			keys.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
			pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
			if (!!~ext) pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
		} else pattern += "/" + tmp;
	}
	return {
		keys,
		pattern: new RegExp("^" + pattern + (loose ? "(?=$|/)" : "/?$"), "i")
	};
}

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
/**
* @license React
* use-sync-external-store-shim.development.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_use_sync_external_store_shim_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js": ((exports) => {
	(function() {
		function is(x, y) {
			return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
		}
		function useSyncExternalStore$2(subscribe, getSnapshot) {
			didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
			var value = getSnapshot();
			if (!didWarnUncachedGetSnapshot) {
				var cachedValue = getSnapshot();
				objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
			}
			cachedValue = useState$1({ inst: {
				value,
				getSnapshot
			} });
			var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
			useLayoutEffect(function() {
				inst.value = value;
				inst.getSnapshot = getSnapshot;
				checkIfSnapshotChanged(inst) && forceUpdate({ inst });
			}, [
				subscribe,
				value,
				getSnapshot
			]);
			useEffect(function() {
				checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				return subscribe(function() {
					checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				});
			}, [subscribe]);
			useDebugValue(value);
			return value;
		}
		function checkIfSnapshotChanged(inst) {
			var latestGetSnapshot = inst.getSnapshot;
			inst = inst.value;
			try {
				var nextValue = latestGetSnapshot();
				return !objectIs(inst, nextValue);
			} catch (error) {
				return !0;
			}
		}
		function useSyncExternalStore$1$1(subscribe, getSnapshot) {
			return getSnapshot();
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState$1 = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1$1 : useSyncExternalStore$2;
		exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/shim/index.js
var require_shim = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/shim/index.js": ((exports, module) => {
	module.exports = require_use_sync_external_store_shim_development();
}) });

//#endregion
//#region node_modules/wouter/src/use-sync-external-store.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var import_shim = require_shim();

//#endregion
//#region node_modules/wouter/src/react-deps.js
var useBuiltinInsertionEffect = import_react.useInsertionEffect;
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect = canUseDOM ? import_react.useLayoutEffect : import_react.useEffect;
const useInsertionEffect = useBuiltinInsertionEffect || useIsomorphicLayoutEffect;
const useEvent = (fn) => {
	const ref = import_react.useRef([fn, (...args) => ref[0](...args)]).current;
	useInsertionEffect(() => {
		ref[0] = fn;
	});
	return ref[1];
};

//#endregion
//#region node_modules/wouter/src/use-browser-location.js
/**
* History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History
*/
var eventPopstate = "popstate";
var eventPushState = "pushState";
var eventReplaceState = "replaceState";
var events = [
	eventPopstate,
	eventPushState,
	eventReplaceState,
	"hashchange"
];
var subscribeToLocationUpdates = (callback) => {
	for (const event of events) addEventListener(event, callback);
	return () => {
		for (const event of events) removeEventListener(event, callback);
	};
};
const useLocationProperty = (fn, ssrFn) => (0, import_shim.useSyncExternalStore)(subscribeToLocationUpdates, fn, ssrFn);
var currentSearch = () => location.search;
const useSearch$1 = ({ ssrSearch } = {}) => useLocationProperty(currentSearch, ssrSearch != null ? () => ssrSearch : currentSearch);
var currentPathname = () => location.pathname;
const usePathname = ({ ssrPath } = {}) => useLocationProperty(currentPathname, ssrPath != null ? () => ssrPath : currentPathname);
const navigate = (to, { replace = false, state = null } = {}) => history[replace ? eventReplaceState : eventPushState](state, "", to);
const useBrowserLocation = (opts = {}) => [usePathname(opts), navigate];
var patchKey = Symbol.for("wouter_v3");
if (typeof history !== "undefined" && typeof window[patchKey] === "undefined") {
	for (const type of [eventPushState, eventReplaceState]) {
		const original = history[type];
		history[type] = function() {
			const result = original.apply(this, arguments);
			const event = new Event(type);
			event.arguments = arguments;
			dispatchEvent(event);
			return result;
		};
	}
	Object.defineProperty(window, patchKey, { value: true });
}

//#endregion
//#region node_modules/wouter/src/paths.js
var _relativePath = (base, path) => !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || "/" : "~" + path;
/**
* When basepath is `undefined` or '/' it is ignored (we assume it's empty string)
*/
var baseDefaults = (base = "") => base === "/" ? "" : base;
const absolutePath = (to, base) => to[0] === "~" ? to.slice(1) : baseDefaults(base) + to;
const relativePath = (base = "", path) => _relativePath(unescape(baseDefaults(base)), unescape(path));
var stripQm = (str) => str[0] === "?" ? str.slice(1) : str;
var unescape = (str) => {
	try {
		return decodeURI(str);
	} catch (_e) {
		return str;
	}
};
const sanitizeSearch = (search) => unescape(stripQm(search));

//#endregion
//#region node_modules/wouter/src/index.js
var defaultRouter = {
	hook: useBrowserLocation,
	searchHook: useSearch$1,
	parser: parse,
	base: "",
	ssrPath: void 0,
	ssrSearch: void 0,
	ssrContext: void 0,
	hrefs: (x) => x,
	aroundNav: (n, t, o) => n(t, o)
};
var RouterCtx = (0, import_react.createContext)(defaultRouter);
const useRouter = () => (0, import_react.useContext)(RouterCtx);
/**
* Parameters context. Used by `useParams()` to get the
* matched params from the innermost `Route` component.
*/
var Params0 = {}, ParamsCtx = (0, import_react.createContext)(Params0);
const useParams = () => (0, import_react.useContext)(ParamsCtx);
var useLocationFromRouter = (router) => {
	const [location$1, navigate$1] = router.hook(router);
	return [relativePath(router.base, location$1), useEvent((to, opts) => router.aroundNav(navigate$1, absolutePath(to, router.base), opts))];
};
const useLocation = () => useLocationFromRouter(useRouter());
const useSearch = () => {
	const router = useRouter();
	return sanitizeSearch(router.searchHook(router));
};
const matchRoute = (parser, route, path, loose) => {
	const { pattern, keys } = route instanceof RegExp ? {
		keys: false,
		pattern: route
	} : parser(route || "*", loose);
	const result = pattern.exec(path) || [];
	const [$base, ...matches] = result;
	return $base !== void 0 ? [
		true,
		(() => {
			const groups = keys !== false ? Object.fromEntries(keys.map((key, i) => [key, matches[i]])) : result.groups;
			let obj = { ...matches };
			groups && Object.assign(obj, groups);
			return obj;
		})(),
		...loose ? [$base] : []
	] : [false, null];
};
const useRoute = (pattern) => matchRoute(useRouter().parser, pattern, useLocation()[0]);
const Router = ({ children, ...props }) => {
	const parent_ = useRouter();
	const parent = props.hook ? defaultRouter : parent_;
	let value = parent;
	const [path, search = props.ssrSearch ?? ""] = props.ssrPath?.split("?") ?? [];
	if (path) props.ssrSearch = search, props.ssrPath = path;
	props.hrefs = props.hrefs ?? props.hook?.hrefs;
	props.searchHook = props.searchHook ?? props.hook?.searchHook;
	let ref = (0, import_react.useRef)({}), prev = ref.current, next = prev;
	for (let k in parent) {
		const option = k === "base" ? parent[k] + (props[k] ?? "") : props[k] ?? parent[k];
		if (prev === next && option !== next[k]) ref.current = next = { ...next };
		next[k] = option;
		if (option !== parent[k] || option !== value[k]) value = next;
	}
	return (0, import_react.createElement)(RouterCtx.Provider, {
		value,
		children
	});
};
var h_route = ({ children, component }, params) => {
	if (component) return (0, import_react.createElement)(component, { params });
	return typeof children === "function" ? children(params) : children;
};
var useCachedParams = (value) => {
	let prev = (0, import_react.useRef)(Params0);
	const curr = prev.current;
	return prev.current = Object.keys(value).length !== Object.keys(curr).length || Object.entries(value).some(([k, v]) => v !== curr[k]) ? value : curr;
};
function useSearchParams() {
	const [location$1, navigate$1] = useLocation();
	const search = useSearch();
	const searchParams = (0, import_react.useMemo)(() => new URLSearchParams(search), [search]);
	let tempSearchParams = searchParams;
	return [searchParams, useEvent((nextInit, options) => {
		tempSearchParams = new URLSearchParams(typeof nextInit === "function" ? nextInit(tempSearchParams) : nextInit);
		navigate$1(location$1 + "?" + tempSearchParams, options);
	})];
}
const Route = ({ path, nest, match, ...renderProps }) => {
	const router = useRouter();
	const [location$1] = useLocationFromRouter(router);
	const [matches, routeParams, base] = match ?? matchRoute(router.parser, path, location$1, nest);
	const params = useCachedParams({
		...useParams(),
		...routeParams
	});
	if (!matches) return null;
	const children = base ? (0, import_react.createElement)(Router, { base }, h_route(renderProps, params)) : h_route(renderProps, params);
	return (0, import_react.createElement)(ParamsCtx.Provider, {
		value: params,
		children
	});
};
const Link = (0, import_react.forwardRef)((props, ref) => {
	const router = useRouter();
	const [currentPath, navigate$1] = useLocationFromRouter(router);
	const { to = "", href: targetPath = to, onClick: _onClick, asChild, children, className: cls, replace, state, transition, ...restProps } = props;
	const onClick = useEvent((event) => {
		if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0) return;
		_onClick?.(event);
		if (!event.defaultPrevented) {
			event.preventDefault();
			navigate$1(targetPath, props);
		}
	});
	const href = router.hrefs(targetPath[0] === "~" ? targetPath.slice(1) : router.base + targetPath, router);
	return asChild && (0, import_react.isValidElement)(children) ? (0, import_react.cloneElement)(children, {
		onClick,
		href
	}) : (0, import_react.createElement)("a", {
		...restProps,
		onClick,
		href,
		className: cls?.call ? cls(currentPath === targetPath) : cls,
		children,
		ref
	});
});
var flattenChildren = (children) => Array.isArray(children) ? children.flatMap((c) => flattenChildren(c && c.type === import_react.Fragment ? c.props.children : c)) : [children];
const Switch = ({ children, location: location$1 }) => {
	const router = useRouter();
	const [originalLocation] = useLocationFromRouter(router);
	for (const element of flattenChildren(children)) {
		let match = 0;
		if ((0, import_react.isValidElement)(element) && (match = matchRoute(router.parser, element.props.path, location$1 || originalLocation, element.props.nest))[0]) return (0, import_react.cloneElement)(element, { match });
	}
	return null;
};
const Redirect = (props) => {
	const { to, href = to } = props;
	const router = useRouter();
	const [, navigate$1] = useLocationFromRouter(router);
	const redirect = useEvent(() => navigate$1(to || href, props));
	const { ssrContext } = router;
	useIsomorphicLayoutEffect(() => {
		redirect();
	}, []);
	if (ssrContext) ssrContext.redirectTo = to;
	return null;
};

//#endregion
export { Link, Redirect, Route, Router, Switch, matchRoute, useLocation, useParams, useRoute, useRouter, useSearch, useSearchParams };
//# sourceMappingURL=wouter.js.map
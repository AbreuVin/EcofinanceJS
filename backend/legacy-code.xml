This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
database.js
package.json
server.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="database.js">
// arquivo: backend/database.js

const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const { validationSchemas } = require('../shared/validators.js');

const dbPath = path.resolve(__dirname, 'ecofinance.db');

const db = new sqlite3.Database(dbPath, (err) => {
  if (err) {
    console.error('Erro ao abrir o banco de dados', err.message);
  } else {
    console.log('Conectado ao banco de dados SQLite em:', dbPath);
    
    db.serialize(() => {
        db.run(`CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, email TEXT UNIQUE, password TEXT)`, (err) => { if (err) console.error('Erro tabela users:', err); else console.log('Tabela "users" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS contacts (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, unit_id INTEGER, email TEXT, phone TEXT, FOREIGN KEY (unit_id) REFERENCES units(id) ON DELETE SET NULL)`, (err) => { if (err) console.error('Erro tabela contacts:', err); else console.log('Tabela "contacts" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS units (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, cidade TEXT, estado TEXT, pais TEXT, numero_colaboradores INTEGER)`, (err) => { if (err) console.error('Erro tabela units:', err); else console.log('Tabela "units" pronta.'); });
        db.run(`CREATE TABLE IF NOT EXISTS mobile_combustion_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, descricao_fonte TEXT, controlado_empresa BOOLEAN, tipo_entrada TEXT, combustivel TEXT, consumo REAL, unidade_consumo TEXT, distancia_percorrida REAL, unidade_distancia TEXT, tipo_veiculo TEXT)`, (err) => { if (err) console.error('Erro tabela mobile_combustion_data:', err); else console.log('Tabela "mobile_combustion_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS stationary_combustion_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, descricao_da_fonte TEXT, combustivel_estacionario TEXT, consumo REAL, unidade TEXT, controlado_empresa BOOLEAN)`, (err) => { if (err) console.error('Erro tabela stationary_combustion_data:', err); else console.log('Tabela "stationary_combustion_data" pronta.'); });

        db.run(`CREATE TABLE IF NOT EXISTS production_sales_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER NOT NULL, periodo TEXT, unidade_empresarial TEXT NOT NULL, produto TEXT NOT NULL, quantidade_vendida INTEGER CHECK(quantidade_vendida > 0), unidade_medida TEXT NOT NULL, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela production_sales_data:', err); else console.log('Tabela "production_sales_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS lubricants_ippu_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, fonte_emissao TEXT, tipo_lubrificante TEXT, consumo REAL, unidade TEXT, controlado_empresa BOOLEAN)`, (err) => { if (err) console.error('Erro tabela lubricants_ippu_data:', err); else console.log('Tabela "lubricants_ippu_data" pronta.'); });
        
        db.run(`CREATE TABLE IF NOT EXISTS fugitive_emissions_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, fonte_emissao TEXT, tipo_gas TEXT, quantidade_reposta REAL, unidade TEXT, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela fugitive_emissions_data:', err); else console.log('Tabela "fugitive_emissions_data" pronta.'); });

        db.run(`CREATE TABLE IF NOT EXISTS fertilizers_data (id INTEGER PRIMARY KEY AUTOINCREMENT, ano INTEGER, periodo TEXT, unidade_empresarial TEXT, tipo_fertilizante TEXT, quantidade_kg REAL, unidade TEXT, percentual_nitrogenio REAL, percentual_carbonato REAL, controlado_empresa BOOLEAN, comentarios TEXT)`, (err) => { if (err) console.error('Erro tabela fertilizers_data:', err); else console.log('Tabela "fertilizers_data" pronta.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS effluents_controlled_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                tratamento_ou_destino TEXT NOT NULL,
                tipo_tratamento TEXT,
                tipo_destino_final TEXT,
                qtd_efluente_liquido_m3 REAL NOT NULL,
                unidade_efluente_liquido TEXT NOT NULL,
                qtd_componente_organico REAL NOT NULL,
                unidade_componente_organico TEXT NOT NULL,
                qtd_nitrogenio_mg_l REAL NOT NULL,
                unidade_nitrogenio TEXT NOT NULL,
                componente_organico_removido_lodo REAL,
                unidade_comp_organico_removido_lodo TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela effluents_controlled_data:', err); else console.log('Tabela "effluents_controlled_data" pronta.'); });
        
        db.run(`DROP TABLE IF EXISTS domestic_effluents_data`);
        
        db.run(`
            CREATE TABLE IF NOT EXISTS domestic_effluents_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                tipo_trabalhador TEXT NOT NULL,
                num_trabalhadores INTEGER NOT NULL,
                carga_horaria_media REAL NOT NULL,
                fossa_septica_propriedade TEXT NOT NULL,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela domestic_effluents_data:', err); else console.log('Tabela "domestic_effluents_data" recriada com a nova estrutura.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS land_use_change_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER NOT NULL,
                periodo TEXT NOT NULL,
                unidade_empresarial TEXT NOT NULL,
                uso_solo_anterior TEXT NOT NULL,
                bioma TEXT,
                fitofisionomia TEXT,
                tipo_area TEXT,
                area_hectare REAL NOT NULL,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela land_use_change_data:', err); else console.log('Tabela "land_use_change_data" pronta.'); });
        
        db.run(`
            CREATE TABLE IF NOT EXISTS solid_waste_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                destinacao_final TEXT,
                tipo_residuo TEXT,
                quantidade_gerado REAL,
                unidade TEXT,
                informar_cidade_uf TEXT,
                local_controlado_empresa TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                rastreabilidade_interna TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela solid_waste_data:', err); else console.log('Tabela "solid_waste_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS electricity_purchase_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                fonte_energia TEXT,
                especificar_fonte TEXT,
                consumo REAL,
                unidade_medida TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                rastreabilidade TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela electricity_purchase_data:', err); else console.log('Tabela "electricity_purchase_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS purchased_goods_services_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_item TEXT,
                tipo_item TEXT,
                quantidade REAL,
                unidade TEXT,
                valor_aquisicao REAL,
                bens_terceiros TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela purchased_goods_services_data:', err); else console.log('Tabela "purchased_goods_services_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS capital_goods_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                bem_capital TEXT,
                quantidade INTEGER,
                unidade TEXT,
                valor_aquisicao REAL,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela capital_goods_data:', err); else console.log('Tabela "capital_goods_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS upstream_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                modal_transporte TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                local_embarque TEXT,
                local_destino TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela upstream_transport_data:', err); else console.log('Tabela "upstream_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS business_travel_land_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_viagem TEXT,
                modal_viagem TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                distancia_percorrida REAL,
                unidade_distancia TEXT,
                km_reembolsado TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela business_travel_land_data:', err); else console.log('Tabela "business_travel_land_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS downstream_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                modal_transporte TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                local_embarque TEXT,
                local_destino TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela downstream_transport_data:', err); else console.log('Tabela "downstream_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS waste_transport_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                insumo_transportado TEXT,
                tipo_reporte TEXT,
                combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                classificacao_veiculo TEXT,
                distancia_trecho REAL,
                unidade_distancia TEXT,
                carga_transportada REAL,
                numero_viagens INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela waste_transport_data:', err); else console.log('Tabela "waste_transport_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS home_office_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                regime_trabalho TEXT,
                num_funcionarios INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela home_office_data:', err); else console.log('Tabela "home_office_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS air_travel_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_viagem TEXT,
                codigo_aeroporto_partida TEXT,
                codigo_aeroporto_chegada TEXT,
                numero_viagens INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela air_travel_data:', err); else console.log('Tabela "air_travel_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS employee_commuting_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_identificadora TEXT,
                meio_utilizado TEXT,
                tipo_reporte TEXT,
                tipo_combustivel TEXT,
                consumo REAL,
                unidade_consumo TEXT,
                distancia_km REAL,
                endereco_funcionario TEXT,
                endereco_trabalho TEXT,
                dias_deslocados INTEGER,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela employee_commuting_data:', err); else console.log('Tabela "employee_commuting_data" pronta.'); });

        db.run(`
            CREATE TABLE IF NOT EXISTS energy_generation_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                descricao_fonte TEXT,
                fonte_geracao TEXT,
                total_geracao REAL,
                unidade_medida TEXT,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela energy_generation_data:', err); else console.log('Tabela "energy_generation_data" pronta.'); });

        // --- SPRINT 19: TABELA - Floresta Plantada ---
        db.run(`
            CREATE TABLE IF NOT EXISTS planted_forest_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ano INTEGER,
                periodo TEXT,
                unidade_empresarial TEXT,
                identificacao_area TEXT,
                nome_especie TEXT,
                area_antepenultimo REAL,
                idade_antepenultimo INTEGER,
                idade_penultimo INTEGER,
                area_colhida_penultimo REAL,
                area_atual REAL,
                responsavel TEXT,
                area_responsavel TEXT,
                email TEXT,
                telefone TEXT,
                comentarios TEXT
            )
        `, (err) => { if (err) console.error('Erro tabela planted_forest_data:', err); else console.log('Tabela "planted_forest_data" pronta.'); });

        // --- SPRINT 21: TABELA - Área de Conservação (ATUALIZADA) ---
        db.run(`DROP TABLE IF EXISTS conservation_area_data`, (err) => {
             // Drop para garantir a recriação correta com os novos campos
             if(!err) {
                db.run(`
                    CREATE TABLE IF NOT EXISTS conservation_area_data (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        ano INTEGER,
                        periodo TEXT,
                        unidade_empresarial TEXT,
                        descricao TEXT,
                        bioma TEXT,
                        fitofisionomia TEXT,
                        area_plantada TEXT,
                        plantio TEXT,
                        area_inicio_ano REAL,
                        area_fim_ano REAL,
                        motivo_alteracao TEXT,
                        responsavel TEXT,
                        area_responsavel TEXT,
                        email TEXT,
                        telefone TEXT,
                        comentarios TEXT
                    )
                `, (err) => { if (err) console.error('Erro tabela conservation_area_data:', err); else console.log('Tabela "conservation_area_data" atualizada e pronta.'); });
             }
        });


        db.run(`CREATE TABLE IF NOT EXISTS asset_typologies (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, unit_id INTEGER NOT NULL, source_type TEXT NOT NULL, description TEXT NOT NULL, asset_fields TEXT, is_active BOOLEAN DEFAULT TRUE)`, (err) => { if (err) console.error('Erro tabela asset_typologies:', err); else console.log('Tabela "asset_typologies" pronta.'); });
        
        db.all("PRAGMA table_info(asset_typologies)", (err, columns) => {
            if (err) {
                console.error("Erro ao ler colunas de asset_typologies:", err);
                return;
            }

            const hasResponsibleId = columns.some(col => col.name === 'responsible_contact_id');
            if (!hasResponsibleId) {
                db.run("ALTER TABLE asset_typologies ADD COLUMN responsible_contact_id INTEGER REFERENCES contacts(id) ON DELETE SET NULL", (err) => {
                    if (err) console.error("Erro ao adicionar coluna 'responsible_contact_id':", err);
                    else console.log("Coluna 'responsible_contact_id' adicionada a 'asset_typologies'.");
                });
            }

            const hasFrequency = columns.some(col => col.name === 'reporting_frequency');
            if (!hasFrequency) {
                db.run("ALTER TABLE asset_typologies ADD COLUMN reporting_frequency TEXT DEFAULT 'anual' NOT NULL", (err) => {
                    if (err) console.error("Erro ao adicionar coluna 'reporting_frequency':", err);
                    else console.log("Coluna 'reporting_frequency' adicionada a 'asset_typologies'.");
                });
            }
        });

        db.run(`DROP TABLE IF EXISTS source_configurations`, (err) => { 
            if (err) console.error('Erro ao remover tabela obsoleta source_configurations:', err); 
            else console.log('Tabela obsoleta "source_configurations" verificada/removida.'); 
        });

        db.run(`CREATE TABLE IF NOT EXISTS managed_options (id INTEGER PRIMARY KEY AUTOINCREMENT, field_key TEXT NOT NULL, value TEXT NOT NULL, UNIQUE(field_key, value))`, (err) => { if (err) console.error('Erro tabela managed_options:', err); else console.log('Tabela "managed_options" pronta.'); });
        db.run(`DROP TABLE IF EXISTS custom_options`, (err) => { if (err) console.error('Erro ao remover tabela antiga custom_options:', err); });
        
        db.run(`CREATE TABLE IF NOT EXISTS contact_source_associations (contact_id INTEGER NOT NULL, source_type TEXT NOT NULL, PRIMARY KEY (contact_id, source_type), FOREIGN KEY (contact_id) REFERENCES contacts (id) ON DELETE CASCADE)`, (err) => { if (err) console.error('Erro tabela contact_source_associations:', err); else console.log('Tabela "contact_source_associations" pronta.'); });

        
        console.log('Iniciando o seeding de opções padrão...');
        const sql = `INSERT OR IGNORE INTO managed_options (field_key, value) VALUES (?, ?)`;
        let totalOptions = 0;
        
        
        for (const schemaKey in validationSchemas) {
            const schema = validationSchemas[schemaKey];
            const options = schema.validOptions || {};
            
            for (const fieldKey in options) {
                const optionValues = Array.isArray(options[fieldKey]) ? options[fieldKey] : [];
                optionValues.forEach(value => {
                    db.run(sql, [fieldKey, value]);
                    totalOptions++;
                });
            }
        }
        console.log(`Seeding de opções padrão concluído. ${totalOptions} opções verificadas.`);
        
    });
  }
});

module.exports = db;
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "csv-parser": "^3.0.0",
    "express": "^4.19.2",
    "multer": "^1.4.5-lts.1",
    "sqlite3": "^5.1.7",
    "xlsx": "^0.18.5"
  }
}
</file>

<file path="server.js">
// arquivo: backend/server.js

// --- 1. IMPORTAÇÕES ---
const express = require('express');
const cors = require('cors');
const path = require('path');
const multer = require('multer');
const csv = require('csv-parser');
const xlsx = require('xlsx');
const fs = require('fs');
const bcrypt = require('bcrypt');
const db = require('./database.js'); 
const { validationSchemas } = require('../shared/validators.js');

// --- 2. CONFIGURAÇÕES ---
const app = express();
const PORT = process.env.PORT || 8080;
const saltRounds = 10;
const upload = multer({ dest: path.join(__dirname, 'uploads/') });

// --- 3. MIDDLEWARES ---
app.use(cors());
app.use(express.json());
const frontendPath = path.join(__dirname, '..', 'frontend');
app.use(express.static(frontendPath));
const sharedPath = path.join(__dirname, '..', 'shared');
app.use('/shared', express.static(sharedPath));

app.use((req, res, next) => {
    if (req.path.endsWith('.js')) res.contentType('text/javascript');
    next();
});

// --- 4. ROTA PRINCIPAL ---
app.get('/', (req, res) => {
    res.sendFile(path.join(frontendPath, 'login.html'));
});

// --- 5. ROTAS DA API ---

// Rotas de Autenticação
app.post('/api/register', async (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({ message: "Email e senha são obrigatórios." });
    }
    try {
        const hashedPassword = await bcrypt.hash(password, saltRounds);
        const sql = "INSERT INTO users (email, password) VALUES (?, ?)";
        db.run(sql, [email, hashedPassword], function(err) {
            if (err) {
                if (err.message.includes('UNIQUE constraint failed')) {
                    return res.status(409).json({ message: "E-mail já cadastrado." });
                }
                return res.status(500).json({ message: "Erro ao registrar usuário.", error: err.message });
            }
            res.status(201).json({ message: "Usuário registrado com sucesso!", userId: this.lastID });
        });
    } catch (error) {
        res.status(500).json({ message: "Erro interno no servidor.", error: error.message });
    }
});

app.post('/api/login', (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({ message: "Email e senha são obrigatórios." });
    }
    const sql = "SELECT * FROM users WHERE email = ?";
    db.get(sql, [email], (err, user) => {
        if (err) {
            return res.status(500).json({ message: "Erro no servidor.", error: err.message });
        }
        if (!user) {
            return res.status(404).json({ message: "Usuário não encontrado." });
        }
        bcrypt.compare(password, user.password, (err, result) => {
            if (err) {
                return res.status(500).json({ message: "Erro ao verificar senha.", error: err.message });
            }
            if (result) {
                res.status(200).json({ message: "Login bem-sucedido!" });
            } else {
                res.status(401).json({ message: "Senha incorreta." });
            }
        });
    });
});

// Rotas de Contatos (Responsáveis)
app.get('/api/contacts', (req, res) => {
    const sqlContacts = `
        SELECT 
            c.id, c.name, c.unit_id, c.email, c.phone,
            u.name as unit_name 
        FROM contacts c
        LEFT JOIN units u ON c.unit_id = u.id
        ORDER BY c.name
    `;
    db.all(sqlContacts, [], (err, contacts) => {
        if (err) return res.status(500).json({ "error": err.message });

        const sqlAssociations = "SELECT * FROM contact_source_associations";
        db.all(sqlAssociations, [], (err, associations) => {
            if (err) return res.status(500).json({ "error": err.message });
            
            const contactsWithSources = contacts.map(contact => {
                const associatedSources = associations
                    .filter(assoc => assoc.contact_id === contact.id)
                    .map(assoc => assoc.source_type);
                return { ...contact, sources: associatedSources };
            });

            res.json(contactsWithSources);
        });
    });
});
app.post('/api/contacts', (req, res) => {
    const { name, unit_id, email, phone, sources = [] } = req.body;
    if (!name) return res.status(400).json({ "error": "O nome é obrigatório." });

    db.run("INSERT INTO contacts (name, unit_id, email, phone) VALUES (?, ?, ?, ?)", [name, unit_id, email, phone], function(err) {
        if (err) return res.status(500).json({ "error": err.message });
        
        const contactId = this.lastID;
        if (sources.length === 0) {
            return res.status(201).json({ "id": contactId });
        }

        const placeholders = sources.map(() => '(?, ?)').join(',');
        const sql = `INSERT INTO contact_source_associations (contact_id, source_type) VALUES ${placeholders}`;
        
        const params = [];
        sources.forEach(sourceType => {
            params.push(contactId, sourceType);
        });

        db.run(sql, params, function(err) {
            if (err) return res.status(500).json({ "error": `Erro ao salvar associações: ${err.message}` });
            res.status(201).json({ "id": contactId });
        });
    });
});
app.put('/api/contacts/:id', (req, res) => {
    const contactId = req.params.id;
    const { name, unit_id, email, phone, sources = [] } = req.body;

    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        db.run("UPDATE contacts SET name = ?, unit_id = ?, email = ?, phone = ? WHERE id = ?", [name, unit_id, email, phone, contactId]);
        db.run("DELETE FROM contact_source_associations WHERE contact_id = ?", [contactId]);

        if (sources.length > 0) {
            const placeholders = sources.map(() => '(?, ?)').join(',');
            const sql = `INSERT INTO contact_source_associations (contact_id, source_type) VALUES ${placeholders}`;
            const params = [];
            sources.forEach(sourceType => params.push(contactId, sourceType));
            db.run(sql, params);
        }

        db.run("COMMIT", (err) => {
            if (err) {
                db.run("ROLLBACK");
                return res.status(500).json({ "error": `Erro na transação: ${err.message}` });
            }
            res.status(200).json({ changes: 1 });
        });
    });
});
app.delete('/api/contacts/:id', (req, res) => {
    db.run("DELETE FROM contacts WHERE id = ?", [req.params.id], function(err) {
        if (err) return res.status(500).json({ "error": err.message });
        res.status(200).json({ deleted: this.changes });
    });
});

// --- ROTAS DE UNIDADES ---
app.get('/api/units', (req, res) => {
    db.all("SELECT * FROM units ORDER BY name", [], (err, rows) => {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.json(rows);
    });
});
app.post('/api/units', (req, res) => {
    const { name, cidade, estado, pais, numero_colaboradores } = req.body;
    if (!name || !cidade || !estado || !pais || !numero_colaboradores) { 
        return res.status(400).json({ "error": "Todos os campos são obrigatórios." }); 
    }
    const sql = "INSERT INTO units (name, cidade, estado, pais, numero_colaboradores) VALUES (?, ?, ?, ?, ?)";
    const params = [name, cidade, estado, pais, numero_colaboradores];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(201).json({ "id": this.lastID });
    });
});
app.put('/api/units/:id', (req, res) => {
    const { name, cidade, estado, pais, numero_colaboradores } = req.body;
    if (!name || !cidade || !estado || !pais || !numero_colaboradores) { 
        return res.status(400).json({ "error": "Todos os campos são obrigatórios." }); 
    }
    const sql = "UPDATE units SET name = ?, cidade = ?, estado = ?, pais = ?, numero_colaboradores = ? WHERE id = ?";
    const params = [name, cidade, estado, pais, numero_colaboradores, req.params.id];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ changes: this.changes });
    });
});
app.delete('/api/units/:id', (req, res) => {
    db.run("DELETE FROM units WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

// Rotas de Upload e Template
app.post('/api/upload', upload.single('file'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).send('Nenhum arquivo enviado.');
        }
        const filePath = req.file.path;
        const { source_type } = req.body; 

        const normalizeHeader = (header) => {
            return header.toString()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                .trim()
                .replace(/[\(\)]/g, '')
                .replace(/[^\w\s-]/g, '')
                .replace(/[\s-]+/g, '_');
        };
        
        const processAndSendData = (data) => {
            const processedData = data.map(row => {
                const newRow = {};
                for (const key in row) {
                    let value = row[key];

                    if (source_type === 'combustao_movel' && key === 'tipo_entrada' && typeof value === 'string') {
                         const normalizedInput = value
                            .toLowerCase()
                            .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                            .trim();
                        
                        if (normalizedInput === 'por consumo') {
                            value = 'consumo';
                        } else if (normalizedInput === 'por distancia') {
                            value = 'distancia';
                        }
                    }

                    if (typeof value === 'string') {
                        value = value.trim();
                    }
                    newRow[key] = value;
                }
                return newRow;
            });
            fs.unlinkSync(filePath);
            res.status(200).json(processedData);
        };
        
        const schema = validationSchemas[source_type];
        if (!schema) {
            fs.unlinkSync(filePath);
            return res.status(400).json({ message: 'Tipo de fonte inválido fornecido.' });
        }
        const headerMap = {};
        for(const key in schema.headerDisplayNames) {
            headerMap[normalizeHeader(schema.headerDisplayNames[key])] = key;
        }

        // Adiciona mapeamento para a chave oculta se ela existir no arquivo
        headerMap['id_fonte'] = 'id_fonte';

        if (req.file.originalname.endsWith('.xlsx') || req.file.originalname.endsWith('.xls')) {
            const workbook = xlsx.readFile(filePath);
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            
            const jsonData = xlsx.utils.sheet_to_json(worksheet, { defval: "", raw: true });

            const results = jsonData.map(row => {
                const newRow = {};
                for (const excelHeader in row) {
                    const normalized = normalizeHeader(excelHeader);
                    const schemaKey = headerMap[normalized];
                    if (schemaKey) {
                        newRow[schemaKey] = row[excelHeader] !== null && row[excelHeader] !== undefined ? String(row[excelHeader]) : "";
                    }
                }
                return newRow;
            });
            
            processAndSendData(results);
        } else {
            let results = [];
            fs.createReadStream(filePath)
                .pipe(csv({
                    mapHeaders: ({ header }) => headerMap[normalizeHeader(header)] || normalizeHeader(header)
                }))
                .on('data', (data) => results.push(data))
                .on('end', () => {
                    processAndSendData(results);
                });
        }
    } catch (error) {
        console.error("Erro no upload:", error);
        if (req.file && fs.existsSync(req.file.path)) {
            fs.unlinkSync(req.file.path);
        }
        res.status(500).json({ message: 'Erro interno ao processar o arquivo.' });
    }
});
app.get('/api/template/:tableName', (req, res) => {
    const { tableName } = req.params;
    const { format = 'csv' } = req.query;
    const schema = validationSchemas[tableName];
    if (!schema) { return res.status(404).send('Tipo de tabela não encontrado.'); }
    const headers = Object.values(schema.headerDisplayNames);
    if (format === 'xlsx') {
        const workbook = xlsx.utils.book_new();
        const worksheet = xlsx.utils.aoa_to_sheet([headers]);
        xlsx.utils.book_append_sheet(workbook, worksheet, 'Dados');
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=${tableName}_template.xlsx`);
        res.status(200).send(buffer);
    } else {
        const csvContent = headers.join(',');
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=${tableName}_template.csv`);
        res.status(200).send(csvContent);
    }
});
app.post('/api/export', (req, res) => {
    const { data, tableName } = req.body;
    if (!Array.isArray(data) || data.length === 0) { return res.status(400).send('Nenhum dado fornecido para exportação.'); }
    try {
        const worksheet = xlsx.utils.json_to_sheet(data);
        if (data.length > 0) {
            const headers = Object.keys(data[0]);
            worksheet['!cols'] = headers.map(header => {
                const maxLength = Math.max(...data.map(row => (row[header] || "").toString().length), header.length);
                return { wch: maxLength + 2 };
            });
        }
        const workbook = xlsx.utils.book_new();
        const sheetName = (tableName ? tableName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Dados Exportados').substring(0, 31);
        xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        const fileName = tableName ? `${tableName}_export.xlsx` : 'export.xlsx';
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=${fileName}_export.xlsx`);
        res.status(200).send(buffer);
    } catch (error) {
        console.error("Erro ao exportar para Excel:", error);
        res.status(500).json({ message: "Erro interno ao gerar o arquivo Excel." });
    }
});
app.post('/api/save-data/:tableName', (req, res) => {
    const { tableName } = req.params;
    const dataRows = req.body;
    
    // --- SPRINT 21: Mapeamento de tabelas ---
    const allowedTables = { 
        combustao_movel: 'mobile_combustion_data', 
        combustao_estacionaria: 'stationary_combustion_data', 
        dados_producao_venda: 'production_sales_data', 
        ippu_lubrificantes: 'lubricants_ippu_data', 
        emissoes_fugitivas: 'fugitive_emissions_data', 
        fertilizantes: 'fertilizers_data',
        efluentes_controlados: 'effluents_controlled_data',
        efluentes_domesticos: 'domestic_effluents_data',
        mudanca_uso_solo: 'land_use_change_data',
        solid_waste: 'solid_waste_data',
        electricity_purchase: 'electricity_purchase_data',
        purchased_goods_services: 'purchased_goods_services_data',
        capital_goods: 'capital_goods_data',
        upstream_transport: 'upstream_transport_data',
        business_travel_land: 'business_travel_land_data',
        downstream_transport: 'downstream_transport_data',
        waste_transport: 'waste_transport_data',
        home_office: 'home_office_data',
        air_travel: 'air_travel_data',
        employee_commuting: 'employee_commuting_data',
        energy_generation: 'energy_generation_data',
        planted_forest: 'planted_forest_data',
        conservation_area: 'conservation_area_data'
    };

    if (!allowedTables[tableName]) { return res.status(400).json({ message: "Tipo de tabela inválido." }); }
    if (!dataRows || dataRows.length === 0) { return res.status(400).json({ message: "Nenhum dado para salvar." }); }
    
    const dbTableName = allowedTables[tableName];
    
    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        let errorOccurred = false;
        
        dataRows.forEach(row => {
            if (errorOccurred) return;

            const booleanFields = {
                'controlado_empresa': 'controlado_empresa',
                'fossa_septica_propriedade': 'fossa_septica_propriedade',
                'local_controlado_empresa': 'local_controlado_empresa',
                'informar_cidade_uf': 'informar_cidade_uf',
                'bens_terceiros': 'bens_terceiros',
                'km_reembolsado': 'km_reembolsado',
                'area_plantada': 'area_plantada'
            };
            
            for (const frontEndKey in booleanFields) {
                if (row.hasOwnProperty(frontEndKey)) {
                    let val = row[frontEndKey];
                    if (val && typeof val === 'string') {
                         val = val.trim();
                         if(['sim', 's', 'Sim'].includes(val)) val = 'Sim';
                         else if(['nao', 'n', 'não', 'Não'].includes(val)) val = 'Não';
                    }
                    row[booleanFields[frontEndKey]] = val;
                }
            }

            const sanitizedRow = {};
            
            // --- SPRINT 21: Auto-preencher Descrição para Conservation Area ---
            if (tableName === 'conservation_area') {
                // Combina Bioma e Fitofisionomia para ter uma descrição útil no banco
                row.descricao = `${row.bioma || ''} - ${row.fitofisionomia || ''}`;
            }
            
            // Remove a chave oculta antes de salvar
            delete row.id_fonte;

            for (const key in row) {
                if (row[key] !== '' && row[key] !== null && row[key] !== undefined) {
                    sanitizedRow[key] = row[key];
                }
            }
            
            if (Object.keys(sanitizedRow).length === 0) return;
            
            const columns = Object.keys(sanitizedRow);
            const placeholders = columns.map(() => '?').join(', ');
            const sql = `INSERT INTO ${dbTableName} (${columns.join(', ')}) VALUES (${placeholders})`;
            const values = Object.values(sanitizedRow);

            db.run(sql, values, (err) => {
                if (err) { console.error("Erro ao inserir linha:", err, "SQL:", sql, "Valores:", values); errorOccurred = true; }
            });
        });

        const operation = errorOccurred ? "ROLLBACK" : "COMMIT";
        db.run(operation, (err) => {
            if (err) { return res.status(500).json({ message: `Erro crítico durante a transação (${operation}).` }); }
            if (errorOccurred) { return res.status(500).json({ message: "Erro ao salvar os dados. A transação foi revertida." }); }
            res.status(201).json({ message: `Dados de "${tableName}" salvos com sucesso!` });
        });
    });
});

// --- ROTAS DE CADASTRO DE FONTES ---
app.get('/api/asset-typologies', (req, res) => {
    const { source_type } = req.query;
    let sql = `
        SELECT 
            T.*, 
            U.name as unit_name,
            C.name as responsible_contact_name 
        FROM asset_typologies T 
        JOIN units U ON T.unit_id = U.id
        LEFT JOIN contacts C ON T.responsible_contact_id = C.id
    `;
    const params = [];
    if (source_type) {
        sql += " WHERE T.source_type = ?";
        params.push(source_type);
    }
    sql += " ORDER BY U.name, T.description";
    
    db.all(sql, params, (err, rows) => {
        if (err) {
            res.status(500).json({ "error": err.message });
            return;
        }
        
        const results = rows.map(row => {
            const fields = JSON.parse(row.asset_fields || '{}');
            return { ...row, asset_fields: fields };
        });
        
        res.json(results);
    });
});
app.post('/api/asset-typologies', (req, res) => {
    const { unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency } = req.body;
    if (!unit_id || !source_type || !description || !asset_fields || !reporting_frequency) { return res.status(400).json({ "error": "Campos obrigatórios faltando." }); }
    const assetFieldsStr = JSON.stringify(asset_fields);
    const contactId = responsible_contact_id || null;

    if (unit_id === 'all') {
        db.all("SELECT id FROM units", [], (err, units) => {
            if (err) return res.status(500).json({ "error": `Erro ao buscar unidades: ${err.message}` });
            if (!units || units.length === 0) return res.status(404).json({ "error": "Nenhuma unidade cadastrada para aplicar a regra." });

            const sql = `INSERT INTO asset_typologies (unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency) VALUES (?, ?, ?, ?, ?, ?)`;
            db.serialize(() => {
                db.run("BEGIN TRANSACTION");
                let errorOccurred = false;
                units.forEach(unit => {
                    if (errorOccurred) return;
                    db.run(sql, [unit.id, source_type, description, assetFieldsStr, contactId, reporting_frequency], function(err) {
                        if (err) { console.error("Erro ao inserir tipologia para unidade " + unit.id, err); errorOccurred = true; }
                    });
                });
                const operation = errorOccurred ? "ROLLBACK" : "COMMIT";
                db.run(operation, (err) => {
                    if (err) return res.status(500).json({ message: `Erro crítico durante a transação (${operation}).` });
                    if (errorOccurred) return res.status(500).json({ message: "Erro ao salvar as fontes. A operação foi revertida." });
                    res.status(201).json({ "message": `Fonte '${description}' criada para ${units.length} unidades com sucesso.` });
                });
            });
        });
    } else {
        const sql = `INSERT INTO asset_typologies (unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency) VALUES (?, ?, ?, ?, ?, ?)`;
        db.run(sql, [unit_id, source_type, description, assetFieldsStr, contactId, reporting_frequency], function(err) {
            if (err) { return res.status(500).json({ "error": err.message }); }
            res.status(201).json({ "id": this.lastID });
        });
    }
});
app.put('/api/asset-typologies/:id', (req, res) => {
    const { unit_id, source_type, description, asset_fields, responsible_contact_id, reporting_frequency } = req.body;
    if (!unit_id || !source_type || !description || !asset_fields || !reporting_frequency) { return res.status(400).json({ "error": "Campos obrigatórios faltando." }); }
    const sql = `UPDATE asset_typologies SET unit_id = ?, source_type = ?, description = ?, asset_fields = ?, responsible_contact_id = ?, reporting_frequency = ? WHERE id = ?`;
    const params = [unit_id, source_type, description, JSON.stringify(asset_fields), responsible_contact_id || null, reporting_frequency, req.params.id];
    db.run(sql, params, function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ changes: this.changes });
    });
});

app.delete('/api/asset-typologies/:id', (req, res) => {
    db.run("DELETE FROM asset_typologies WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

app.get('/api/options', (req, res) => {
    const { field_key } = req.query;
    if (!field_key) { return res.status(400).json({ "error": "O parâmetro 'field_key' é obrigatório." }); }
    
    db.all("SELECT * FROM managed_options WHERE field_key = ? ORDER BY value", [field_key], (err, rows) => {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.json(rows);
    });
});
app.post('/api/options', (req, res) => {
    const { field_key, value } = req.body;
    if (!field_key || !value) { return res.status(400).json({ "error": "Campos 'field_key' e 'value' são obrigatórios." }); }
    
    db.run("INSERT INTO managed_options (field_key, value) VALUES (?, ?)", [field_key, value], function(err) {
        if (err) { 
            console.error("Erro ao inserir em managed_options:", err.message);
            res.status(500).json({ "error": err.message }); 
            return;
        }
        res.status(201).json({ "id": this.lastID });
    });
});
app.delete('/api/options/:id', (req, res) => {
    db.run("DELETE FROM managed_options WHERE id = ?", [req.params.id], function(err) {
        if (err) { res.status(500).json({ "error": err.message }); return; }
        res.status(200).json({ deleted: this.changes });
    });
});

app.get('/api/intelligent-template/:sourceType', (req, res) => {
    const { sourceType } = req.params;
    const { unitId, year, format } = req.query;
    const schema = validationSchemas[sourceType];
    if (!schema) { return res.status(404).send('Tipo de fonte não encontrado.'); }

    // --- ATUALIZADO: Mapeamento de descrições ---
    const descriptionKeyMap = { 
        combustao_estacionaria: 'descricao_da_fonte', 
        combustao_movel: 'descricao_fonte', 
        dados_producao_venda: 'produto', 
        ippu_lubrificantes: 'fonte_emissao', 
        emissoes_fugitivas: 'fonte_emissao', 
        fertilizantes: 'tipo_fertilizante',
        efluentes_controlados: 'tratamento_ou_destino',
        mudanca_uso_solo: 'uso_solo_anterior',
        solid_waste: 'destinacao_final',
        electricity_purchase: 'fonte_energia',
        purchased_goods_services: 'descricao_item',
        capital_goods: 'bem_capital',
        upstream_transport: 'insumo_transportado',
        business_travel_land: 'descricao_viagem',
        downstream_transport: 'insumo_transportado',
        waste_transport: 'insumo_transportado',
        home_office: 'regime_trabalho',
        air_travel: 'descricao_viagem',
        employee_commuting: 'descricao_identificadora',
        energy_generation: 'fonte_geracao',
        planted_forest: 'identificacao_area',
        conservation_area: 'bioma',
        // Adicionado Efluentes Domésticos
        efluentes_domesticos: 'tipo_trabalhador'
    };
    
    const getTypologies = new Promise((resolve, reject) => {
        let sql = `
            SELECT 
                T.*, 
                U.name as unit_name
            FROM asset_typologies T 
            JOIN units U ON T.unit_id = U.id
            WHERE T.source_type = ?
        `;
        const params = [sourceType];
        if (unitId && unitId !== 'all') { sql += " AND T.unit_id = ?"; params.push(unitId); }
        db.all(sql, params, (err, rows) => { if (err) return reject(err); resolve(rows); });
    });

    getTypologies.then((typologies) => {
        const dataForExcel = [];
        const headers = schema.headerDisplayNames;
        const headerKeys = Object.keys(headers);
        const reportYear = year || new Date().getFullYear();
        const mainDescriptionKey = descriptionKeyMap[sourceType];

        typologies.forEach(typo => {
            const frequency = typo.reporting_frequency || 'anual';
            const periods = frequency === 'mensal' ? ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"] : ["Anual"];
            const assetFields = JSON.parse(typo.asset_fields || '{}');
            
            periods.forEach(period => {
                const row = {};
                headerKeys.forEach(key => { row[key] = ''; });

                row['ano'] = reportYear;
                row['periodo'] = period;
                row['unidade_empresarial'] = typo.unit_name;
                row['id_fonte'] = typo.id; // --- Chave Primária Oculta ---
                
                if (mainDescriptionKey) {
                    if (['solid_waste', 'electricity_purchase'].includes(sourceType)) {
                        row[mainDescriptionKey] = assetFields[mainDescriptionKey] || '';
                    } else if (sourceType === 'energy_generation') {
                        row[mainDescriptionKey] = assetFields.fonte_geracao || typo.description;
                    } else if (sourceType === 'conservation_area') {
                        row[mainDescriptionKey] = assetFields.bioma || '';
                    } else if (sourceType === 'efluentes_domesticos') {
                        // Garante que o tipo de trabalhador seja o preenchido no cadastro
                        row[mainDescriptionKey] = assetFields.tipo_trabalhador || '';
                    } else {
                        row[mainDescriptionKey] = typo.description;
                    }
                }
                
                // --- INSERÇÃO DE DADOS DO CADASTRO NO JSON (Para Front-end) ---
                for (const assetKey in assetFields) { 
                    if (row.hasOwnProperty(assetKey)) { 
                        row[assetKey] = assetFields[assetKey]; 
                    } 
                }
                
                // --- Preenchimentos Específicos ---
                if (sourceType === 'solid_waste' && assetFields.destinacao_final === 'Aterro') {
                    row['informar_cidade_uf'] = assetFields.cidade_uf_destino || '';
                }
                if (sourceType === 'efluentes_controlados') {
                    row['unidade_efluente_liquido'] = frequency === 'mensal' ? 'm3/mês' : 'm3/ano';
                    row['unidade_nitrogenio'] = 'kgN/m3';
                } else if (sourceType === 'emissoes_fugitivas' || sourceType === 'fertilizantes') {
                    row['unidade'] = 'kg';
                } else if (sourceType === 'capital_goods') {
                    row['unidade'] = 'Unidades';
                }
                
                // --- AutoFill (Unidades baseadas em Combustível) ---
                if (schema.autoFillMap) {
                    for (const triggerKey in schema.autoFillMap) {
                        const rule = schema.autoFillMap[triggerKey];
                        const triggerValue = row[triggerKey];
                        if (triggerValue) {
                            const targetValue = rule.map[triggerValue];
                            if (targetValue !== undefined) {
                                row[rule.targetColumn] = targetValue;
                            }
                        }
                    }
                }
                
                dataForExcel.push(row);
            });
        });

        if (format === 'json') {
            return res.json(dataForExcel);
        }
        
        try {
            // --- LÓGICA DE EXCLUSÃO DE COLUNAS DO EXCEL ---
            const excludeColumns = [];
            
            // Regra para Controlado pela Empresa (Agora inclui combustao_movel)
            if (['combustao_estacionaria', 'combustao_movel', 'ippu_lubrificantes', 'emissoes_fugitivas', 'fertilizantes'].includes(sourceType)) {
                excludeColumns.push('controlado_empresa');
            }
            
            // Regra para Unidade
            if (['combustao_estacionaria', 'ippu_lubrificantes'].includes(sourceType)) {
                 excludeColumns.push('unidade'); 
            }
            
            // Regra para Unidade de Consumo (Específica para Combustão Móvel)
            if (sourceType === 'combustao_movel') {
                excludeColumns.push('unidade_consumo');
            }

            // --- NOVA REGRA: Efluentes Domésticos ---
            if (sourceType === 'efluentes_domesticos') {
                // Remove do Excel para evitar erros de digitação (Case Sensitive)
                excludeColumns.push('fossa_septica_propriedade');
            }

            const dataWithHeaderNames = dataForExcel.map(row => {
                const newRow = {};
                for (const key in row) {
                    if (key === 'id_fonte') continue; // Remove ID oculto do Excel visual
                    if (excludeColumns.includes(key)) continue; // Remove colunas proibidas

                    if (headers[key]) {
                        newRow[headers[key]] = row[key];
                    }
                }
                return newRow;
            });

            // Filtra os cabeçalhos também
            const finalHeaders = Object.keys(headers)
                .filter(key => !excludeColumns.includes(key))
                .map(key => headers[key]);

            const worksheet = xlsx.utils.json_to_sheet(dataWithHeaderNames, { header: finalHeaders });
            worksheet['!cols'] = finalHeaders.map(header => ({ wch: Math.max(header.length, 15) + 2 }));
            const workbook = xlsx.utils.book_new();
            const sheetName = schema.displayName.substring(0, 31);
            xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
            const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
            const fileName = `${sourceType}_template_preenchido_${year}.xlsx`;
            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', `attachment; filename=${fileName}_template.xlsx`);
            res.status(200).send(buffer);
        } catch (error) {
            console.error("Erro ao gerar o template inteligente:", error);
            res.status(500).json({ message: "Erro interno ao gerar o arquivo Excel." });
        }
    }).catch(err => {
        console.error("Erro ao processar dados para o template:", err);
        res.status(500).json({ message: "Erro interno ao processar a geração do template." });
    });
});

app.listen(PORT, () => {
    console.log(`Servidor iniciado com sucesso na porta ${PORT}`);
});
</file>

</files>
